{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../Assimilate/dist/package/API.js","webpack:///../Assimilate/dist/package/Assimilate.js","webpack:///../Assimilate/dist/package/Validator.js","webpack:///../Assimilate/dist/package/use/utils/Partial.js","webpack:///../Assimilate/dist/package/use/utils/noop.js","webpack:///../Assimilate/dist/package/use/validator/ajv.js","webpack:///../Assimilate/dist/package/use/validator/djv.js","webpack:///../Assimilate/dist/package/use/validator/tv4.js","webpack:///../json-schema-form-core/dist/cjs/Core.js","webpack:///../json-schema-form-core/dist/cjs/lib/canonical-title-map.js","webpack:///../json-schema-form-core/dist/cjs/lib/merge.js","webpack:///../json-schema-form-core/dist/cjs/lib/resolve.js","webpack:///../json-schema-form-core/dist/cjs/lib/schema-defaults.js","webpack:///../json-schema-form-core/dist/cjs/lib/select.js","webpack:///../json-schema-form-core/dist/cjs/lib/sf-path.js","webpack:///../json-schema-form-core/dist/cjs/lib/traverse.js","webpack:///../json-schema-form-core/dist/cjs/lib/validate.js","webpack:///../json-schema-form-core/dist/package/src/ext/json-refs.js","webpack:///../json-schema-form-core/index.js","webpack:///../json-schema-form-core/node_modules/objectpath/index.js","webpack:///../json-schema-form-core/node_modules/objectpath/lib/ObjectPath.js","webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/directives/schema-validate.directive.js","webpack:///./src/directives/sf-array.directive.js","webpack:///./src/directives/sf-changed.directive.js","webpack:///./src/directives/sf-field.directive.js","webpack:///./src/directives/sf-key.directive.js","webpack:///./src/directives/sf-message.directive.js","webpack:///./src/directives/sf-schema.directive.js","webpack:///./src/schema-form.module.js","webpack:///./src/services/schema-form-decorators.provider.js","webpack:///./src/services/schema-form.provider.js","webpack:///./src/services/sf-builder.provider.js","webpack:///./src/services/sf-error-message.provider.js","webpack:///./src/services/sf-path.provider.js","webpack:///external {\"commonjs\":\"ajv\",\"amd\":\"ajv\",\"root\":\"ajv\"}","webpack:///external \"angular\"","webpack:///external {\"commonjs\":\"djv\",\"amd\":\"djv\",\"root\":\"djv\"}","webpack:///external {\"commonjs\":\"tv4\",\"amd\":\"tv4\",\"root\":\"tv4\"}"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA,6DAA6D,qCAAqC,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA,2DAA2D,uCAAuC,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA,4DAA4D,sCAAsC,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kCAAkC,qDAAqD,EAAE;AACzF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gF;;;;;;;;;;;;ACnHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uF;;;;;;;;;;;;ACVA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;;AAEpD;AACA;AACA;;AAEA;AACA;AACA,sF;;;;;;;;;;;;AC3IA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8F;;;;;;;;;;;;AC5BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2F;;;;;;;;;;;;ACXA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yDAAyD,4CAA4C,EAAE;AACvG;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,WAAW;AACX,8F;;;;;;;;;;;;AC3BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAA8C,kDAAkD,yBAAyB,wHAAwH,EAAE,WAAW;AACvR;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,WAAW;AACX,8F;;;;;;;;;;;;ACzCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0DAA0D,4CAA4C,EAAE;AACxG;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,WAAW;AACX,8F;;;;;;;;;;;;ACvCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4F;;;;;;;;;;;;ACnBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAsC;AACxE,aAAa;AACb;AACA;AACA;AACA,kCAAkC,sCAAsC;AACxE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+G;;;;;;;;;;;;AC3BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAmD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iG;;;;;;;;;;;;AC5HA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kCAAkC,uBAAuB,EAAE;AAC3D,mCAAmC,wBAAwB,EAAE;AAC7D,KAAK;AACL;AACA;AACA,uCAAuC,0BAA0B,EAAE;AACnE,qCAAqC,iBAAiB,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA,mG;;;;;;;;;;;;ACzBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,uBAAuB,0BAA0B;AACjD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2G;;;;;;;;;;;;AC/SA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kG;;;;;;;;;;;;AC5EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA,8BAA8B,eAAe;AAC7C,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mG;;;;;;;;;;;;ACtCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,oG;;;;;;;;;;;;ACrDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,YAAY,OAAO;AACnB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oG;;;;;;;;;;;wEC/DA,yBAAa,SAA2D,mBAAmB,eAAqN,CAAkB,aAAa,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AAC5yB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,aAAa,yBAAyB,sBAAsB,aAAa;AACzE;AACA,uDAAuD,oCAAoC;AAC3F,8CAA8C,uCAAuC;AACrF,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,MAAM;AACN,aAAa,gCAAgC;AAC7C;AACA,aAAa,iCAAiC;AAC9C;AACA,aAAa,OAAO;AACpB;AACA,MAAM,4DAA4D;AAClE;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,aAAa,qCAAqC;AAClD,aAAa,SAAS;AACtB;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,aAAa,qCAAqC;AAClD,aAAa,SAAS;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,EAAE;AAClB;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mCAAmC;AACnD,kEAAkE;AAClE,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,qCAAqC;AACrD,kEAAkE;AAClE,gBAAgB,oBAAoB;AACpC,kEAAkE;AAClE,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,MAAM,oDAAoD;AAC1D,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,eAAe,OAAO;AACtB;AACA,cAAc,MAAM;AACpB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,eAAe,OAAO;AACtB;AACA,cAAc,MAAM;AACpB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,gCAAgC;AAC7C;AACA,eAAe,OAAO;AACtB,2BAA2B,2CAA2C;AACtE;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA,+CAA+C,wCAAwC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D,2BAA2B,+BAA+B;AAC1D;AACA,aAAa,OAAO;AACpB,MAAM,4DAA4D;AAClE,aAAa,gCAAgC;AAC7C;AACA,eAAe,QAAQ,4BAA4B,2CAA2C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,SAAS;AACxB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,gCAAgC;AAC7C;AACA,eAAe,QAAQ,4BAA4B,0CAA0C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB;AACvB;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE,2BAA2B,kCAAkC;AAC7D;AACA,aAAa,OAAO;AACpB,MAAM,4DAA4D;AAClE,aAAa,gCAAgC;AAC7C;AACA,eAAe,QAAQ,4BAA4B,mDAAmD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,EAAE,yFAAyF;;AAE9F;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA,GAAG,GAAG;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,gCAAgC;AACzF,yDAAyD,yBAAyB,sBAAsB,EAAE,EAAE;AAC5G,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,yBAAyB,EAAE;AACvD;AACA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,QAAQ;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sCAAsC,EAAE;AAC7E,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,QAAQ;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA,GAAG;;AAEH,GAAG,qIAAqI;;AAExI,GAAG,GAAG;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;;AAEA;AACA,YAAY,UAAU;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,sBAAsB;AACvD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH,GAAG,EAAE,aAAa;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,SAAS;AACvB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,yCAAyC;AACtD;AACA,aAAa,0CAA0C;AACvD;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA,GAAG,EAAE,sEAAsE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,GAAG,GAAG;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,yCAAyC;AACtD,aAAa,0CAA0C;AACvD;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,GAAG,EAAE,gBAAgB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA,8BAA8B,UAAU;;AAExC,GAAG,GAAG;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG,GAAG;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,GAAG;AACN;;AAEA;AACA;;AAEA,GAAG,EAAE,2BAA2B;;AAEhC;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,MAAM;AACnB;AACA;AACA;;AAEA,8C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,GAAG;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG,GAAG;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA,GAAG,wCAAwC;AAC3C;AACA,GAAG,OAAO;AACV;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,+CAA+C,EAAE;AAC5D,WAAW,gDAAgD,EAAE;AAC7D,WAAW,gDAAgD,EAAE;AAC7D,WAAW,4CAA4C,EAAE;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,sCAAsC;;AAEzD;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;AAEhB,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,iBAAiB;AACjD;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC,gCAAgC;AAChC;AACA;AACA;AACA;AACA,4BAA4B,aAAa,iBAAiB;AAC1D;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA,YAAY,cAAc;AAC1B,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB,WAAW,YAAY;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,EAAE,4EAA4E;AACjF;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG,GAAG;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,cAAc;AACd;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAoD;AACtE;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,sCAAsC;AACnD,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,EAAE,iBAAiB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,GAAG,GAAG;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,WAAW;AACX,mCAAmC;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B,6CAA6C,qBAAqB;;AAElE;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;;AAE3D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,GAAG,GAAG;AACN;AACA;AACA;AACA;;AAEA,GAAG,EAAE,6DAA6D;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,EAAE,YAAY;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,yEAAyE;AACzE,6EAA6E,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA,sEAAsE,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,GAAG,EAAE,6BAA6B;AAClC;AACA;AACA;AACA;AACA,4EAA4E,KAAK,sCAAsC,EAAE,uDAAuD,gRAAgR,IAAI,qCAAqC,EAAE,iBAAiB,EAAE,EAAE,EAAE,cAAc,GAAG;AACnhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,GAAG,EAAE,YAAY;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8dAA8d,suBAAsuB,IAAI,m1EAAm1E,EAAE;AAC7hH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kYAAkY,EAAE;AACpY;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,8DAA8D;AAC9D,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,GAAG,EAAE,+BAA+B,EAAE,GAAG;AACzC,GAAG;AACH,6CAA6C,cAAc;;;;;;;;;;;;;AChyK3D;;;;;;;;;;;;ACAA;;;;;;;;;;;;;kCCAA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA;;AAEA,8BAA8B,iGAAiG,EAAE;AACjI,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,GAAG;AAAA;AACH;;AAEA;AACA,QAOA;;AAEA,CAAC,G;;;;;;;;;;;ACtGD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzLD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC,EAAE;AACnE,kCAAkC,+BAA+B,EAAE;;AAEnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8BAA8B;AAChG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AChNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qDAAqD;AACtG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0CAA0C,EAAE;AACnE,iBAAiB,WAAW,cAAc;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC9OA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,4CAA4C;AAC5C;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iCAAiC;AACzF;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kG;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;ACxXA;AAAA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACrCA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+DAA+D,aAAa;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,oDAAoD,+BAA+B,EAAE;;AAErF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc,YAAY,EAAE;AAC3E,kDAAkD,cAAc,YAAY,EAAE;AAC9E;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACtGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB,IAAI;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrPA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iCAAiC;AAC7F;AACA;AACA,6CAA6C,iCAAiC;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB,OAAO;AAC/B;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,wCAAwC;AACrG;AACA,4DAA4D;AAC5D;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA,gCAAgC;AAChC,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,yCAAyC,4BAA4B;AACzF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;;AAE1C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;AClkBC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO,aAAa;AACpC,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA,gBAAgB,MAAM;AACtB;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1HA;AAAA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;;AAEA,uBAAuB,qBAAqB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,EAAE;AACxD;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;AC1VA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D,YAAY,WAAW,uCAAuC,gBAAgB;AAC9E,YAAY,WAAW,qCAAqC,gBAAgB;AAC5E,YAAY,WAAW,0CAA0C,gBAAgB;AACjF,YAAY,WAAW,qCAAqC,gBAAgB;AAC5E;AACA;AACA,iCAAiC,kBAAkB,mBAAmB,kBAAkB;AACxF,gCAAgC,kBAAkB,mBAAmB,kBAAkB;AACvF,2CAA2C,gBAAgB;AAC3D;AACA,gDAAgD,sBAAsB;AACtE,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA,gCAAgC,cAAc,aAAa,iBAAiB;AAC5E,+BAA+B,cAAc,aAAa,iBAAiB;AAC3E;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,IAAI;AACnB,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;ACtIiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA,sCAAsC,sDAAsD,6BAA6B;AACzH,2B;;;;;;;;;;;ACDA,yB;;;;;;;;;;;ACAA,sCAAsC,sDAAsD,6BAA6B;AACzH,2B;;;;;;;;;;;ACDA,sCAAsC,sDAAsD,6BAA6B;AACzH,2B","file":"angular-schema-form.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Partial_1 = require(\"./use/utils/Partial\");\r\n/**\r\n * @function\r\n * @name test\r\n * @description\r\n * Validate object along with schema\r\n *\r\n * @requires env::validate\r\n *\r\n * @param {object} env\r\n * @param {object|string} path\r\n * @param {object} instance\r\n * @returns {boolean} isValid\r\n */\r\nvar test = Partial_1.partial(function (env, path, instance) { return env.validate(path, instance); });\r\n/**\r\n * @function\r\n * @name is\r\n * @description\r\n * Validate object along with schema\r\n *\r\n * @requires env::validate\r\n *\r\n * @param {object} env\r\n * @param {object|string} path\r\n * @param {object} instance\r\n * @returns {boolean} isValid\r\n */\r\nvar is = Partial_1.partial(function (env, path, instance) { return !!env.validate(path, instance); });\r\n/**\r\n * @function\r\n * @name not\r\n * @description\r\n * Validate object along with negative schema context\r\n *\r\n * @requires env::validate\r\n *\r\n * @param {object} env\r\n * @param {object|string} path\r\n * @param {object} instance\r\n * @returns {boolean} isNotValid\r\n */\r\nvar not = Partial_1.partial(function (env, path, instance) { return !env.validate(path, instance); });\r\n/**\r\n * @function\r\n * @name find\r\n * @description\r\n * Finds & returns first appropriate instance\r\n *\r\n * @requires is\r\n *\r\n * @param {object|array} references\r\n * @param {object} instance\r\n * @returns {?}\r\n */\r\nvar find = Partial_1.partial(function (env, references, instance) {\r\n    var isArray = Array.isArray(references);\r\n    var foundKey = Object.keys(references)\r\n        .find(function (path) {\r\n        return is(env, isArray ? references[path] : path, instance);\r\n    });\r\n    var found = isArray ? +foundKey : references[foundKey];\r\n    return typeof foundKey === 'undefined' ? undefined : found;\r\n});\r\n/**\r\n * @function\r\n * @name filter\r\n * @description\r\n * Filters & returns appropriate instances\r\n *\r\n * @requires is\r\n *\r\n * @param {object/array} references\r\n * @param {object} instance\r\n * @returns {array} indexes\r\n */\r\nvar filter = Partial_1.partial(function (env, references, instance) {\r\n    var isArray = Array.isArray(references);\r\n    return Object.keys(references)\r\n        .filter(function (path) {\r\n        return is(env, isArray ? references[path] : path, instance);\r\n    })\r\n        .map(function (foundKey) { return (isArray ? +foundKey : references[foundKey]); });\r\n});\r\n/**\r\n * @function\r\n * @name match\r\n * @description\r\n * Finds & execute appropriate instance\r\n *\r\n * @requires find\r\n *\r\n * @param {object} env\r\n * @param {object/array} references\r\n * @param {object} instance\r\n * @returns {?}\r\n */\r\nvar match = Partial_1.partial(function (env, references, instance) {\r\n    var fn = find(env, references, instance);\r\n    if (typeof fn === 'function') {\r\n        return fn(instance);\r\n    }\r\n    return fn;\r\n});\r\nvar api = {\r\n    test: test,\r\n    is: is,\r\n    not: not,\r\n    find: find,\r\n    filter: filter,\r\n    match: match,\r\n};\r\nexports.api = api;\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/API.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Validator_1 = require(\"./Validator\");\r\nexports.Assimilate = Validator_1.Assimilate;\r\nexports.Validator = Validator_1.Validator;\r\nexports.Validate = Validator_1.Validate;\r\nrequire(\"./use/validator/ajv\");\r\nrequire(\"./use/validator/djv\");\r\nrequire(\"./use/validator/tv4\");\r\n// import './use/validator/JJV';\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/Assimilate.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar API_1 = require(\"./API\");\r\n/**\r\n * @module @json-schema/assimilate\r\n * @name assimilate\r\n * @description\r\n * Assimilate package wraps json schema validator environment with a set of utilities\r\n */\r\n/**\r\n * @function\r\n * @name Assimilate\r\n * @description\r\n * Entry point for Assimilate package\r\n *\r\n * @param {function} validator I am an external 3rd party validator library\r\n * @param {function?} adapter  I am a wrapper able to coerce validator behaviour to be inline with desired capabilities\r\n * @returns {function} is      I am a function for returning a true/false result to a validation request\r\n */\r\nexports.Assimilate = function (validator, adapter) {\r\n    var env;\r\n    switch (typeof adapter) {\r\n        case 'function':\r\n            env = adapter(validator);\r\n            break;\r\n        case 'undefined':\r\n        default:\r\n            env = validator();\r\n    }\r\n    var addSchema = env.addSchema, validate = env.validate;\r\n    var apis = Object.keys(API_1.api)\r\n        .reduce(function (accumulator, key, currentIndex, source) {\r\n        return Object.assign((_a = {},\r\n            _a[key] = API_1.api[key](env),\r\n            _a), accumulator);\r\n        var _a;\r\n    }, {});\r\n    // Entry point for generated environment\r\n    Object.assign(apis.is, apis.test, env, {\r\n        env: env,\r\n        addSchema: addSchema,\r\n        validate: apis.is,\r\n    }, apis);\r\n    return apis.is;\r\n};\r\n/**\r\n * I am a Validator class instance and I am usable with the\r\n * 'new' keyword to obtain multiple instances\r\n */\r\nvar ValidatorInstance = /** @class */ (function () {\r\n    function ValidatorInstance() {\r\n        this.libraries = {};\r\n    }\r\n    ValidatorInstance.prototype.addLibrary = function (name, library, defaultOptions, requiredOptions) {\r\n        this.libraries[name] = {\r\n            name: name,\r\n            lib: library,\r\n            ro: requiredOptions,\r\n            do: defaultOptions\r\n        };\r\n        this.using = name;\r\n        return this;\r\n    };\r\n    ValidatorInstance.prototype.use = function (library) {\r\n        this.using = library;\r\n        return this;\r\n    };\r\n    /**\r\n     * @param namespace  I am the reference to the schema to be used in jsonref or jsonpath\r\n     * @param jsonSchema The schema to validate against\r\n     */\r\n    ValidatorInstance.prototype.addSchema = function (namespace, jsonSchema) {\r\n        if (!this.libraries || !this.libraries[this.using]) {\r\n            throw ('A validation library must be provided prior to adding a schema');\r\n        }\r\n        ;\r\n        this.libraries[this.using].lib.addSchema(namespace, jsonSchema);\r\n        return this;\r\n    };\r\n    ValidatorInstance.prototype.validate = function (namespace, instance) {\r\n        if (!this.libraries || !this.libraries[this.using]) {\r\n            throw ('A validation library must be provided prior to validating an instance');\r\n        }\r\n        ;\r\n        var valid = this.libraries[this.using].lib.validate(namespace, instance);\r\n        this.errors = this.libraries[this.using].lib.getErrors();\r\n        return valid;\r\n    };\r\n    ValidatorInstance.prototype.validateRaw = function (namespace, instance) {\r\n        if (!this.libraries || !this.libraries[this.using]) {\r\n            throw ('A validation library must be provided prior to executing a raw validator');\r\n        }\r\n        ;\r\n        var valid = this.libraries[this.using].lib.test(namespace, instance);\r\n        this.errors = this.libraries[this.using].lib.getErrors();\r\n        return valid;\r\n    };\r\n    ValidatorInstance.prototype.getErrors = function () {\r\n        return this.errors;\r\n    };\r\n    return ValidatorInstance;\r\n}());\r\nexports.ValidatorInstance = ValidatorInstance;\r\n/**\r\n * I am a singleton export, all importers of me will be using the same instance\r\n */\r\nexports.Validator = new ValidatorInstance();\r\n/**\r\n * I am a prototype export, all importers of me will be using a separate instance\r\n */\r\nexports.Validate = new ValidatorInstance();\r\n/*\r\nAssimilate JSON Schema Validator Interface\r\nAjsvi\r\nVALIDATION\r\n===================================\r\nimport { Validator } from '@json-schema/assimilate/Validator';\r\nimport 'assimilate/use/AJV';\r\nimport 'assimilate/add/operator/is';\r\nimport 'assimilate/add/operator/not';\r\nimport 'assimilate/add/operator/find';\r\nimport 'assimilate/add/operator/filter';\r\nimport 'assimilate/add/operator/compile';\r\nimport 'assimilate/add/operator/compileAsync';\r\nimport 'assimilate/add/operator/validateSchema';\r\nimport 'assimilate/add/operator/getSchema';\r\nimport 'assimilate/add/operator/removeSchema';\r\nimport 'assimilate/add/output/verbose';\r\nimport 'assimilate/add/output/use-json-pointer';\r\nimport 'assimilate/util/JSONRef';\r\n\r\nValidator.Use(schema).of(1,2,3).map(x => x + '!!!'); // etc\r\n\r\nES6\r\n===================================\r\nimport Ajsvi from '@json-schema/assimilate/Ajsvi';\r\n\r\nAjsvi.Validator.Use(schema).With().(1,2,3);\r\n*/\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/Validator.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar noop_1 = require(\"./noop\");\r\n/**\r\n * @function\r\n * @name partial\r\n * @inner\r\n */\r\nfunction partial(fn) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    if (typeof fn !== 'function') {\r\n        return noop_1.noop;\r\n    }\r\n    if (args.length >= fn.length) {\r\n        return fn.apply(void 0, args);\r\n    }\r\n    return function executor() {\r\n        var evalArgs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            evalArgs[_i] = arguments[_i];\r\n        }\r\n        return partial.apply(null, [fn].concat(args, evalArgs));\r\n    };\r\n}\r\nexports.partial = partial;\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/use/utils/Partial.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * I am an empty function to use where a function is required but unavailable\r\n * @function\r\n * @name noop\r\n * @inner\r\n */\r\n/* tslint:disable:no-empty */\r\nfunction noop() { }\r\nexports.noop = noop;\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/use/utils/noop.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Validator_1 = require(\"../../Validator\");\r\ntry {\r\n    var ajv = require('ajv');\r\n    Validator_1.Validator.addLibrary('ajv', Validator_1.Assimilate(ajv, function (source) {\r\n        var env = source({ allErrors: true });\r\n        var addSchema = env.addSchema, validate = env.validate;\r\n        var errors = [];\r\n        var library = Object.assign(env, {\r\n            addSchema: function (key, schema) {\r\n                addSchema.call(env, schema, key);\r\n            },\r\n            validate: function (path, instance) {\r\n                var valid = validate.call(env, path, instance);\r\n                errors = [].concat(env.errors);\r\n                return valid;\r\n            },\r\n            getErrors: function () {\r\n                var result = errors.filter(function (n) { return [undefined, null].indexOf(n) === -1; });\r\n                return [].concat(result);\r\n            },\r\n        });\r\n        return library;\r\n    }));\r\n}\r\ncatch (e) { }\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/use/validator/ajv.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Validator_1 = require(\"../../Validator\");\r\ntry {\r\n    var djv = require('djv');\r\n    Validator_1.Validator.addLibrary('djv', Validator_1.Assimilate(djv, function (source) {\r\n        var errors = [];\r\n        var env = source({\r\n            errorHandler: function (type) {\r\n                var path = this.data.toString().replace(/^data/, '');\r\n                var dataPath = path.replace(/\\[\\'([^\\']+)\\'\\]/ig, '.$1').replace(/\\[(i[0-9]*)\\]/ig, '[\\'+$1+\\']');\r\n                var schemaPath = '#' + path.replace(/\\[i([0-9]*)\\]/ig, '/items').replace(/\\[\\'([^\\']+)\\'\\]/ig, '/properties/$1');\r\n                var schema = this.schema;\r\n                // if([ 'type', 'enum', 'minimum', 'maximum' ].indexOf(type)) {\r\n                schemaPath = schemaPath + '/' + type;\r\n                // };\r\n                // TODO decide if it is worth adding the schema -> schema: this.schema,\r\n                return \"{\\n          let dataPath = '\" + dataPath + \"';\\n          let schemaPath = '\" + schemaPath + \"';\\n          errors.push({\\n            keyword: '\" + type + \"',\\n            dataPath: dataPath,\\n            schemaPath: schemaPath\\n          });\\n        }\";\r\n            }\r\n        });\r\n        var test = env.validate;\r\n        var library = Object.assign(env, {\r\n            validate: function (path, instance) {\r\n                var result = test.call(env, path, instance);\r\n                var valid = !result;\r\n                errors.splice(0);\r\n                if (!valid) {\r\n                    errors = errors.concat(result);\r\n                }\r\n                ;\r\n                return valid;\r\n            },\r\n            getErrors: function () {\r\n                var result = [].concat(errors);\r\n                return result;\r\n            },\r\n        });\r\n        return library;\r\n    }));\r\n}\r\ncatch (e) { }\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/use/validator/djv.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Validator_1 = require(\"../../Validator\");\r\ntry {\r\n    var tv4_1 = require('tv4');\r\n    Validator_1.Validator.addLibrary('tv4', Validator_1.Assimilate(tv4_1, function (source) {\r\n        var _env = {};\r\n        var _schema = {};\r\n        var _errors = [];\r\n        var library = Object.assign(_env, {\r\n            addSchema: function (key, schema) {\r\n                // tv4.addSchema.call(tv4, key, schema);\r\n                _schema[key] = schema;\r\n            },\r\n            validate: function (key, instance) {\r\n                var result = tv4_1.validateMultiple.call(tv4_1, instance, _schema[key]);\r\n                if (Array.isArray(result.errors)) {\r\n                    result.error = result.errors.map(function (elem) {\r\n                        return {\r\n                            key: elem.schemaPath.split('/').slice(-1).pop(),\r\n                            dataPath: elem.dataPath.replace(/\\/([0-9]+)/ig, '[$1]').replace(/\\/([^\\/]+)/ig, '.$1'),\r\n                            schemaPath: '#' + elem.schemaPath,\r\n                            message: elem.message\r\n                        };\r\n                    });\r\n                }\r\n                // console.log(result.error);\r\n                _errors = [].concat(result.error);\r\n                return result.valid;\r\n            },\r\n            getErrors: function () {\r\n                var result = _errors.filter(function (n) { return [undefined, null].indexOf(n) === -1; });\r\n                return [].concat(result);\r\n            },\r\n        });\r\n        return library;\r\n    }));\r\n}\r\ncatch (e) { }\r\n//# sourceMappingURL=c:/users/marcel/documents/serious/git/assimilate/use/validator/tv4.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar schemaDefaultsImp = require(\"./lib/schema-defaults\");\r\nvar sfPathImp = require(\"./lib/sf-path\");\r\nvar canonical_title_map_1 = require(\"./lib/canonical-title-map\");\r\nvar merge_1 = require(\"./lib/merge\");\r\nexports.merge = merge_1.merge;\r\nvar select_1 = require(\"./lib/select\");\r\nexports.select = select_1.select;\r\nvar resolve_1 = require(\"./lib/resolve\");\r\nexports.jsonref = resolve_1.jsonref;\r\nvar traverse_1 = require(\"./lib/traverse\");\r\nexports.traverseSchema = traverse_1.traverseSchema;\r\nexports.traverseForm = traverse_1.traverseForm;\r\nvar validate_1 = require(\"./lib/validate\");\r\nexports.validate = validate_1.validate;\r\nexports.sfPath = sfPathImp;\r\nexports.schemaDefaults = schemaDefaultsImp;\r\nexports.canonicalTitleMap = canonical_title_map_1.default;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/Core.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * I take a titleMap in enum, array or object format and return it\r\n * in the array titleMap format.\r\n *\r\n * @param {Array<any>} titleMap\r\n * @param {*} originalEnum\r\n */\r\nfunction default_1(titleMap, originalEnum) {\r\n    if (!Array.isArray(titleMap)) {\r\n        var canonical_1 = [];\r\n        if (originalEnum) {\r\n            originalEnum.forEach(function (value) {\r\n                canonical_1.push({ name: titleMap[value], value: value });\r\n            });\r\n        }\r\n        else {\r\n            Object.keys(titleMap).forEach(function (value) {\r\n                canonical_1.push({ name: titleMap[value], value: value });\r\n            });\r\n        }\r\n        return canonical_1;\r\n    }\r\n    return titleMap;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/canonical-title-map.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar sf_path_1 = require(\"./sf-path\");\r\nvar schema_defaults_1 = require(\"./schema-defaults\");\r\nvar canonical_title_map_1 = require(\"./canonical-title-map\");\r\n// export function merge(schema, form, schemaDefaultTypes, ignore, options, readonly, asyncTemplates) {\r\n/**\r\n * @name merge\r\n */\r\nfunction merge(lookup, form, typeDefaults, ignore, options, readonly, asyncTemplates) {\r\n    if (typeDefaults === void 0) { typeDefaults = schema_defaults_1.createDefaults(); }\r\n    var formItems = [];\r\n    var formItemRest = [];\r\n    form = form || [];\r\n    var idx = form.indexOf('*');\r\n    options = options || {};\r\n    var stdForm = {};\r\n    var idxRest = form.indexOf('...');\r\n    if (typeof lookup === 'object' && lookup.hasOwnProperty('properties')) {\r\n        readonly = readonly || lookup.readonly || lookup.readOnly;\r\n        stdForm = schema_defaults_1.defaultForm(lookup, typeDefaults, ignore, options);\r\n        var defaultFormLookup = stdForm.lookup;\r\n        lookup = defaultFormLookup || lookup;\r\n        formItems = formItems.concat(stdForm.form);\r\n    }\r\n    ;\r\n    if (idx !== -1) {\r\n        form = form.slice(0, idx).concat(formItems).concat(form.slice(idx + 1));\r\n    }\r\n    // simple case, we have a \"...\", just put the formItemRest there\r\n    if (stdForm.form && idxRest !== -1) {\r\n        var formKeys_1 = form\r\n            .filter(function (obj) {\r\n            return ((typeof obj === 'string') || (obj.key !== undefined));\r\n        })\r\n            .map(function (obj) {\r\n            if (typeof obj === 'string') {\r\n                return obj;\r\n            }\r\n            else {\r\n                return obj.key;\r\n            }\r\n        });\r\n        formItemRest = formItemRest.concat(stdForm.form\r\n            .filter(function (obj) {\r\n            var isInside = formKeys_1.indexOf(obj.key[0]) !== -1;\r\n            return !isInside && obj !== undefined;\r\n        }));\r\n    }\r\n    ;\r\n    if (idxRest !== -1) {\r\n        form = form.slice(0, idxRest).concat(formItemRest).concat(form.slice(idxRest + 1));\r\n    }\r\n    ;\r\n    // ok let's merge!\r\n    // We look at the supplied form and extend it with schema standards\r\n    return form.map(function (obj) {\r\n        // handle the shortcut with just a name\r\n        if (typeof obj === 'string') {\r\n            obj = { key: obj };\r\n        }\r\n        if (obj.key) {\r\n            if (typeof obj.key === 'string') {\r\n                obj.key = sf_path_1.parse(obj.key);\r\n            }\r\n        }\r\n        // If it has a titleMap make sure it's a list\r\n        if (obj.titleMap) {\r\n            obj.titleMap = canonical_title_map_1.default(obj.titleMap);\r\n        }\r\n        // extend with std form from schema.\r\n        if (obj.key) {\r\n            var strid = sf_path_1.stringify(obj.key);\r\n            if (lookup[strid]) {\r\n                var schemaDefaults_1 = lookup[strid];\r\n                if (schemaDefaults_1) {\r\n                    Object.keys(schemaDefaults_1).forEach(function (attr) {\r\n                        if (obj[attr] === undefined) {\r\n                            obj[attr] = schemaDefaults_1[attr];\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Are we inheriting readonly?\r\n        if (readonly === true) {\r\n            obj.readonly = true;\r\n        }\r\n        // if it's a type with items, merge 'em!\r\n        if (obj.items) {\r\n            obj.items = merge(lookup, obj.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\r\n        }\r\n        // if its has tabs, merge them also!\r\n        if (obj.tabs) {\r\n            obj.tabs.forEach(function (tab) {\r\n                if (tab.items) {\r\n                    tab.items = merge(lookup, tab.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\r\n                }\r\n            });\r\n        }\r\n        // Special case: checkbox\r\n        // Since have to ternary state we need a default\r\n        if (obj.type === 'checkbox') {\r\n            // Check for schema property, as the checkbox may be part of the explicitly defined form\r\n            if (obj.schema === undefined) {\r\n                obj.schema = { default: false };\r\n            }\r\n            else if (obj.schema['default'] === undefined) {\r\n                obj.schema['default'] = false;\r\n            }\r\n            ;\r\n        }\r\n        ;\r\n        // Special case: template type with tempplateUrl that's needs to be loaded before rendering\r\n        // TODO: this is not a clean solution. Maybe something cleaner can be made when $ref support\r\n        // is introduced since we need to go async then anyway\r\n        if (asyncTemplates && obj.type === 'template' && !obj.template && obj.templateUrl) {\r\n            asyncTemplates.push(obj);\r\n        }\r\n        ;\r\n        return obj;\r\n    });\r\n}\r\nexports.merge = merge;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/merge.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar JsonRefs = require(\"@ext/json-refs\");\r\n/**\r\n * @name jsonref\r\n * @param {Object} schema\r\n * @param {function} callBack\r\n */\r\nfunction jsonref(schema, callBack) {\r\n    var promise = new Promise(function (resolve, reject) {\r\n        JsonRefs.resolveRefs(schema, {\r\n            'filter': ['relative', 'local', 'remote'],\r\n        })\r\n            .then(function (res) { resolve(res.resolved); })\r\n            .catch(function (err) { reject(new Error(err)); });\r\n    });\r\n    if (typeof (callBack) === 'function') {\r\n        promise\r\n            .then(function (resolved) { callBack(null, resolved); })\r\n            .catch(function (error) { callBack(error); });\r\n    }\r\n    return promise;\r\n}\r\nexports.jsonref = jsonref;\r\n;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/resolve.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar sf_path_1 = require(\"./sf-path\");\r\nvar canonical_title_map_1 = require(\"./canonical-title-map\");\r\n/* Utils */\r\nvar stripNullType = function (type) {\r\n    if (Array.isArray(type) && type.length === 2) {\r\n        if (type[0] === 'null') {\r\n            return type[1];\r\n        }\r\n        ;\r\n        if (type[1] === 'null') {\r\n            return type[0];\r\n        }\r\n        ;\r\n    }\r\n    ;\r\n    return type;\r\n};\r\n// Creates an default titleMap list from an enum, i.e. a list of strings.\r\nvar enumToTitleMap = function (enm) {\r\n    var titleMap = []; // canonical titleMap format is a list.\r\n    enm.forEach(function (name) {\r\n        titleMap.push({ name: name, value: name });\r\n    });\r\n    return titleMap;\r\n};\r\n/**\r\n * Creates a default form definition from a schema.\r\n */\r\nfunction defaultFormDefinition(schemaTypes, name, schema, options) {\r\n    var rules = schemaTypes[stripNullType(schema.type)];\r\n    if (rules) {\r\n        var def = void 0;\r\n        // We give each rule a possibility to recurse it's children.\r\n        var innerDefaultFormDefinition = function (childName, childSchema, childOptions) {\r\n            return defaultFormDefinition(schemaTypes, childName, childSchema, childOptions);\r\n        };\r\n        for (var i = 0; i < rules.length; i++) {\r\n            def = rules[i](name, schema, options, innerDefaultFormDefinition);\r\n            // first handler in list that actually returns something is our handler!\r\n            if (def) {\r\n                // Do we have form defaults in the schema under the x-schema-form-attribute?\r\n                if (def.schema['x-schema-form']) {\r\n                    Object.assign(def, def.schema['x-schema-form']);\r\n                }\r\n                return def;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.defaultFormDefinition = defaultFormDefinition;\r\n/**\r\n * Creates a form object with all common properties\r\n */\r\nfunction stdFormObj(name, schema, options) {\r\n    options = options || {};\r\n    // The Object.assign used to be a angular.copy. Should work though.\r\n    var f = options.global && options.global.formDefaults ?\r\n        Object.assign({}, options.global.formDefaults) : {};\r\n    if (options.global && options.global.supressPropertyTitles === true) {\r\n        f.title = schema.title;\r\n    }\r\n    else {\r\n        f.title = schema.title || name;\r\n    }\r\n    if (schema.description) {\r\n        f.description = schema.description;\r\n    }\r\n    if (options.required === true || schema.required === true) {\r\n        f.required = true;\r\n    }\r\n    if (schema.maxLength) {\r\n        f.maxlength = schema.maxLength;\r\n    }\r\n    if (schema.minLength) {\r\n        f.minlength = schema.minLength;\r\n    }\r\n    if (schema.readOnly || schema.readonly) {\r\n        f.readonly = true;\r\n    }\r\n    if (schema.minimum) {\r\n        f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0);\r\n    }\r\n    if (schema.maximum) {\r\n        f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0);\r\n    }\r\n    // Non standard attributes (DONT USE DEPRECATED)\r\n    // If you must set stuff like this in the schema use the x-schema-form attribute\r\n    if (schema.validationMessage) {\r\n        f.validationMessage = schema.validationMessage;\r\n    }\r\n    if (schema.enumNames) {\r\n        f.titleMap = canonical_title_map_1.default(schema.enumNames, schema['enum']);\r\n    }\r\n    f.schema = schema;\r\n    // Ng model options doesn't play nice with undefined, might be defined\r\n    // globally though\r\n    f.ngModelOptions = f.ngModelOptions || {};\r\n    return f;\r\n}\r\nexports.stdFormObj = stdFormObj;\r\n;\r\n/**\r\n * I map text schema types to the relevant form type mapping, with defaults\r\n */\r\nfunction text(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'string' && !schema['enum']) {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'text';\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.text = text;\r\n/**\r\n * I map number schema types to the relevant form type mapping, with defaults\r\n * default in json form for number and integer is a text field\r\n * input type=\"number\" would be more suitable don't ya think?\r\n */\r\nfunction number(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'number') {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'number';\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.number = number;\r\n/**\r\n * I map integer schema types to the relevant form type mapping, with defaults\r\n */\r\nfunction integer(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'integer') {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'number';\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.integer = integer;\r\n/**\r\n * I map checkbox schema types to the relevant form type mapping, with defaults\r\n */\r\nfunction checkbox(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'boolean') {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'checkbox';\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.checkbox = checkbox;\r\n/**\r\n * I map string with enum in schema to select form type, with defaults\r\n */\r\nfunction select(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'string' && schema['enum']) {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'select';\r\n        if (!f.titleMap) {\r\n            f.titleMap = enumToTitleMap(schema['enum']);\r\n        }\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.select = select;\r\n/**\r\n * I map array/enum schema types to the checkboxes form type, with defaults\r\n */\r\nfunction checkboxes(name, schema, options) {\r\n    if (stripNullType(schema.type) === 'array' && schema.items && schema.items['enum']) {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.key = options.path;\r\n        f.type = 'checkboxes';\r\n        if (!f.titleMap) {\r\n            f.titleMap = enumToTitleMap(schema.items['enum']);\r\n        }\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        return f;\r\n    }\r\n}\r\nexports.checkboxes = checkboxes;\r\n/**\r\n * I map object schema types to the fieldset form type, with defaults\r\n */\r\nfunction fieldset(name, schema, options, defaultFormDef) {\r\n    if (stripNullType(schema.type) === 'object') {\r\n        var f_1 = stdFormObj(name, schema, options);\r\n        f_1.type = 'fieldset';\r\n        f_1.key = options.path;\r\n        f_1.items = [];\r\n        options.lookup[sf_path_1.stringify(options.path)] = f_1;\r\n        // recurse down into properties\r\n        if (schema.properties) {\r\n            Object.keys(schema.properties).forEach(function (key) {\r\n                var value = schema.properties[key];\r\n                var path = options.path.slice();\r\n                path.push(key);\r\n                if (options.ignore[sf_path_1.stringify(path)] !== true) {\r\n                    var required = schema.required && schema.required.indexOf(key) !== -1;\r\n                    var def = defaultFormDef(key, value, {\r\n                        path: path,\r\n                        required: required || false,\r\n                        lookup: options.lookup,\r\n                        ignore: options.ignore,\r\n                        global: options.global,\r\n                    });\r\n                    if (def) {\r\n                        f_1.items.push(def);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return f_1;\r\n    }\r\n}\r\nexports.fieldset = fieldset;\r\n/**\r\n * I map array schema types to the relevant form type mapping, with defaults\r\n */\r\nfunction array(name, schema, options, defaultFormDef) {\r\n    if (stripNullType(schema.type) === 'array') {\r\n        var f = stdFormObj(name, schema, options);\r\n        f.type = 'array';\r\n        f.key = options.path;\r\n        options.lookup[sf_path_1.stringify(options.path)] = f;\r\n        var required = schema.required &&\r\n            schema.required.indexOf(options.path[options.path.length - 1]) !== -1;\r\n        // The default is to always just create one child. This works since if the\r\n        // schemas items declaration is of type: \"object\" then we get a fieldset.\r\n        // We also follow json form notatation, adding empty brackets \"[]\" to\r\n        // signify arrays.\r\n        var arrPath = options.path.slice();\r\n        arrPath.push('');\r\n        f.items = [\r\n            defaultFormDef(name, schema.items, {\r\n                path: arrPath,\r\n                required: required || false,\r\n                lookup: options.lookup,\r\n                ignore: options.ignore,\r\n                global: options.global,\r\n            }),\r\n        ];\r\n        return f;\r\n    }\r\n}\r\nexports.array = array;\r\n/**\r\n * I generate the default schema to form type mapping definitions from use against the provided schema\r\n */\r\nfunction createDefaults() {\r\n    // First sorted by schema type then a list.\r\n    // Order has importance. First handler returning an form snippet will be used.\r\n    return {\r\n        string: [select, text],\r\n        object: [fieldset],\r\n        number: [number],\r\n        integer: [integer],\r\n        boolean: [checkbox],\r\n        array: [checkboxes, array],\r\n    };\r\n}\r\nexports.createDefaults = createDefaults;\r\n;\r\n/**\r\n * Create form defaults from schema\r\n */\r\nfunction defaultForm(schema, defaultSchemaTypes, ignore, globalOptions) {\r\n    var form = [];\r\n    var lookup = {}; // Map path => form obj for fast lookup in merging\r\n    ignore = ignore || {};\r\n    globalOptions = globalOptions || {};\r\n    defaultSchemaTypes = defaultSchemaTypes || createDefaults();\r\n    if (schema.properties) {\r\n        Object.keys(schema.properties).forEach(function (key) {\r\n            if (ignore[key] !== true) {\r\n                var required = schema.required && schema.required.indexOf(key) !== -1;\r\n                var def = defaultFormDefinition(defaultSchemaTypes, key, schema.properties[key], {\r\n                    path: [key],\r\n                    lookup: lookup,\r\n                    ignore: ignore,\r\n                    required: required,\r\n                    global: globalOptions,\r\n                });\r\n                if (def) {\r\n                    form.push(def);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        throw new Error('Not implemented. Only type \"object\" allowed at root level of schema.');\r\n    }\r\n    return { form: form, lookup: lookup };\r\n}\r\nexports.defaultForm = defaultForm;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/schema-defaults.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar sfPath = require(\"./sf-path\");\r\nvar numRe = /^\\d+$/;\r\n/**\r\n  * @description\r\n  * Utility method to access deep properties without\r\n  * throwing errors when things are not defined.\r\n  * Can also set a value in a deep structure, creating objects when missing\r\n  * ex.\r\n  * var foo = Select('address.contact.name',obj)\r\n  * Select('address.contact.name',obj,'Leeroy')\r\n  *\r\n  * @param {string} projection A dot path to the property you want to get/set\r\n  * @param {object} obj   (optional) The object to project on, defaults to 'this'\r\n  * @param {Any}    valueToSet (opional)  The value to set, if parts of the path of\r\n  *                 the projection is missing empty objects will be created.\r\n  * @returns {Any|undefined} returns the value at the end of the projection path\r\n  *                          or undefined if there is none.\r\n  */\r\nfunction select(projection, obj, valueToSet) {\r\n    // if (!obj) {\r\n    //   obj = this;\r\n    // };\r\n    // Support [] array syntax\r\n    var parts = typeof projection === 'string' ? sfPath.parse(projection) : projection;\r\n    if (typeof valueToSet !== 'undefined' && parts.length === 1) {\r\n        // special case, just setting one variable\r\n        obj[parts[0]] = valueToSet;\r\n        return obj;\r\n    }\r\n    ;\r\n    if (typeof valueToSet !== 'undefined' &&\r\n        typeof obj[parts[0]] === 'undefined') {\r\n        // We need to look ahead to check if array is appropriate\r\n        obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {};\r\n    }\r\n    ;\r\n    var value = obj[parts[0]];\r\n    for (var i = 1; i < parts.length; i++) {\r\n        // Special case: We allow JSON Form syntax for arrays using empty brackets\r\n        // These will of course not work here so we exit if they are found.\r\n        if (parts[i] === '') {\r\n            return undefined;\r\n        }\r\n        ;\r\n        if (typeof valueToSet !== 'undefined') {\r\n            if (i === parts.length - 1) {\r\n                // last step. Let's set the value\r\n                value[parts[i]] = valueToSet;\r\n                return valueToSet;\r\n            }\r\n            else {\r\n                // Make sure to create new objects on the way if they are not there.\r\n                // We need to look ahead to check if array is appropriate\r\n                var tmp = value[parts[i]];\r\n                if (typeof tmp === 'undefined' || tmp === null) {\r\n                    tmp = numRe.test(parts[i + 1]) ? [] : {};\r\n                    value[parts[i]] = tmp;\r\n                }\r\n                ;\r\n                value = tmp;\r\n            }\r\n            ;\r\n        }\r\n        else if (value) {\r\n            // Just get nex value.\r\n            value = value[parts[i]];\r\n        }\r\n        ;\r\n    }\r\n    ;\r\n    return value;\r\n}\r\nexports.select = select;\r\n;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/select.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar op = require(\"objectpath\");\r\n// const op = require('objectpath/lib/ObjectPath').ObjectPath;\r\nexports.parse = op.parse;\r\nexports.stringify = op.stringify;\r\nexports.normalize = op.normalize;\r\n/**\r\n * I am a name formatter function for processing keys into names for classes or Id.\r\n *\r\n * @param  {Array<string>} key         I am the key array of a processed schema key\r\n * @param  {string}        separator   I am the separator between the key items and optional form name\r\n * @param  {string}        formName    I am an optional form name\r\n * @param  {boolean}       omitNumbers I determine if numeric values should be included in the output or withheld\r\n *\r\n * @return {string}                    I am the formatted key\r\n */\r\nfunction name(key, separator, formName, omitNumbers) {\r\n    if (formName === void 0) { formName = ''; }\r\n    if (omitNumbers === void 0) { omitNumbers = false; }\r\n    if (key) {\r\n        var fieldKey = key.slice();\r\n        var fieldSeparator = separator || '-';\r\n        if (omitNumbers) {\r\n            fieldKey = fieldKey.filter(function (currentKey) {\r\n                return typeof currentKey !== 'number';\r\n            });\r\n        }\r\n        ;\r\n        return ((formName.length !== 0)\r\n            ? formName + fieldSeparator\r\n            : '') + fieldKey.join(fieldSeparator);\r\n    }\r\n    ;\r\n    return '';\r\n}\r\nexports.name = name;\r\n;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/sf-path.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * I traverse a schema, applying a function(schema,path) on every sub schema\r\n * i.e. every property of an object.\r\n */\r\nfunction traverseSchema(schema, fn, path, ignoreArrays) {\r\n    ignoreArrays = ignoreArrays === undefined ? true : ignoreArrays;\r\n    path = path || [];\r\n    var traverse = function (schemaObject, processorFunction, pathArray) {\r\n        processorFunction(schemaObject, pathArray);\r\n        if (schemaObject.properties) {\r\n            Object.keys(schemaObject.properties).forEach(function (name) {\r\n                var currentPath = pathArray.slice();\r\n                currentPath.push(name);\r\n                traverse(schemaObject.properties[name], processorFunction, currentPath);\r\n            });\r\n        }\r\n        // Only support type \"array\" which have a schemaObject as \"items\".\r\n        if (!ignoreArrays && schemaObject.items) {\r\n            var arrPath = pathArray.slice();\r\n            arrPath.push('');\r\n            traverse(schemaObject.items, processorFunction, arrPath);\r\n        }\r\n    };\r\n    traverse(schema, fn, path || []);\r\n}\r\nexports.traverseSchema = traverseSchema;\r\n/**\r\n * I traverse a form definition, applying a function(schema,path) on every sub schema\r\n * i.e. every property of an object.\r\n *\r\n * @param {Object} form\r\n * @param {Function} fn\r\n */\r\nfunction traverseForm(form, fn) {\r\n    fn(form);\r\n    if (form.items) {\r\n        form.items.forEach(function (f) {\r\n            traverseForm(f, fn);\r\n        });\r\n    }\r\n    if (form.tabs) {\r\n        form.tabs.forEach(function (tab) {\r\n            if (tab.items) {\r\n                tab.items.forEach(function (f) {\r\n                    traverseForm(f, fn);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.traverseForm = traverseForm;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/traverse.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assimilate_1 = require(\"@jsonschema/assimilate\");\r\n/**\r\n * Validate a value against its form definition and schema.\r\n * The value should either be of proper type or a string, some type\r\n * coercion is applied.\r\n *\r\n * @param {Object} form A merged form definition, i.e. one with a schema.\r\n * @param {any} value the value to validate.\r\n * @return {Object} a tv4js result object.\r\n */\r\nfunction validate(form, value) {\r\n    if (!form) {\r\n        return { valid: true };\r\n    }\r\n    ;\r\n    var schema = form.schema;\r\n    if (!schema) {\r\n        return { valid: true };\r\n    }\r\n    ;\r\n    // Input of type text and textareas will give us a viewValue of ''\r\n    // when empty, this is a valid value in a schema and does not count as something\r\n    // that breaks validation of 'required'. But for our own sanity an empty field should\r\n    // not validate if it's required.\r\n    if (value === '') {\r\n        value = undefined;\r\n    }\r\n    ;\r\n    // Numbers fields will give a null value, which also means empty field\r\n    if (form.type === 'number' && value === null) {\r\n        value = undefined;\r\n    }\r\n    ;\r\n    // Version 4 of JSON Schema has the required property not on the\r\n    // property itself but on the wrapping object. Since we like to test\r\n    // only this property we wrap it in a fake object.\r\n    var wrap = { 'type': 'object', 'properties': {}, 'required': undefined };\r\n    var propName = form.key[form.key.length - 1];\r\n    var key = form.key.join('/');\r\n    wrap.properties[propName] = schema;\r\n    if (form.required) {\r\n        wrap.required = [propName];\r\n    }\r\n    ;\r\n    var valueWrap = {};\r\n    if (typeof value !== 'undefined') {\r\n        valueWrap[propName] = value;\r\n    }\r\n    ;\r\n    assimilate_1.Validator.addSchema(key, wrap);\r\n    var valid = assimilate_1.Validator.validate(key, valueWrap);\r\n    var error = assimilate_1.Validator.getErrors();\r\n    var result = {\r\n        valid: valid,\r\n        error: error[0],\r\n        errors: error\r\n    };\r\n    return result;\r\n}\r\nexports.validate = validate;\r\n;\r\n//# sourceMappingURL=C:/Users/Marcel/Documents/SERIOUS/git/json-schema-form-core/lib/validate.js.map","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.JsonRefs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n  /*\n   * The MIT License (MIT)\n   *\n   * Copyright (c) 2014 Jeremy Whitlock\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n  \n  'use strict';\n  \n  /**\n   * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and\n   * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.\n   *\n   * @module JsonRefs\n   */\n  \n  var path = require('path');\n  var PathLoader = require('path-loader');\n  var qs = require('querystring');\n  var slash = require('slash');\n  var URI = require('uri-js');\n  \n  var badPtrTokenRegex = /~(?:[^01]|$)/g;\n  var remoteCache = {};\n  var remoteTypes = ['relative', 'remote'];\n  var remoteUriTypes = ['absolute', 'uri'];\n  var uriDetailsCache = {};\n  \n  // Load promises polyfill if necessary\n  /* istanbul ignore if */\n  if (typeof Promise === 'undefined') {\n    require('native-promise-only');\n  }\n  \n  /* Internal Functions */\n  \n  // This is a very simplistic clone function that does not take into account non-JSON types.  For these types the\n  // original value is used as the clone.  So while it's not a complete deep clone, for the needs of this project\n  // this should be sufficient.\n  function clone (obj) {\n    var cloned;\n  \n    if (isType(obj, 'Array')) {\n      cloned = [];\n  \n      obj.forEach(function (value, index) {\n        cloned[index] = clone(value);\n      });\n    } else if (isType(obj, 'Object')) {\n      cloned = {};\n  \n      Object.keys(obj).forEach(function (key) {\n        cloned[key] = clone(obj[key]);\n      });\n    } else {\n      cloned = obj;\n    }\n  \n    return cloned;\n  }\n  \n  function combineQueryParams (qs1, qs2) {\n    var combined = {};\n  \n    function mergeQueryParams (obj) {\n      Object.keys(obj).forEach(function (key) {\n        combined[key] = obj[key];\n      });\n    }\n  \n    mergeQueryParams(qs.parse(qs1 || ''));\n    mergeQueryParams(qs.parse(qs2 || ''));\n  \n    return Object.keys(combined).length === 0 ? undefined : qs.stringify(combined);\n  }\n  \n  function combineURIs (u1, u2) {\n    // Convert Windows paths\n    if (isType(u1, 'String')) {\n      u1 = slash(u1);\n    }\n  \n    if (isType(u2, 'String')) {\n      u2 = slash(u2);\n    }\n  \n    var u2Details = parseURI(isType(u2, 'Undefined') ? '' : u2);\n    var u1Details;\n    var combinedDetails;\n  \n    if (remoteUriTypes.indexOf(u2Details.reference) > -1) {\n      combinedDetails = u2Details;\n    } else {\n      u1Details = isType(u1, 'Undefined') ? undefined : parseURI(u1);\n  \n      if (!isType(u1Details, 'Undefined')) {\n        combinedDetails = u1Details;\n  \n        // Join the paths\n        combinedDetails.path = slash(path.join(u1Details.path, u2Details.path));\n  \n        // Join query parameters\n        combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);\n      } else {\n        combinedDetails = u2Details;\n      }\n    }\n  \n    // Remove the fragment\n    combinedDetails.fragment = undefined;\n  \n    // For relative URIs, add back the '..' since it was removed above\n    return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 &&\n            combinedDetails.path.indexOf('../') === 0 ? '../' : '') + URI.serialize(combinedDetails);\n  }\n  \n  function findAncestors (obj, path) {\n    var ancestors = [];\n    var node;\n  \n    if (path.length > 0) {\n      node = obj;\n  \n      path.slice(0, path.length - 1).forEach(function (seg) {\n        if (seg in node) {\n          node = node[seg];\n  \n          ancestors.push(node);\n        }\n      });\n    }\n  \n    return ancestors;\n  }\n  \n  function processSubDocument (mode, doc, subDocPath, refDetails, options, parents, parentPtrs, allRefs, indirect) {\n    var refValue;\n    var rOptions;\n  \n    if (subDocPath.length > 0) {\n      try {\n        refValue = findValue(doc, subDocPath);\n      } catch (err) {\n        // We only mark missing remote references as missing because local references can have deferred values\n        if (mode === 'remote') {\n          refDetails.error = err.message;\n          refDetails.missing = true;\n        }\n      }\n    } else {\n      refValue = doc;\n    }\n  \n    if (!isType(refValue, 'Undefined')) {\n      refDetails.value = refValue;\n    }\n  \n    if (isType(refValue, 'Array') || isType(refValue, 'Object')) {\n      rOptions = clone(options);\n  \n      if (mode === 'local') {\n        delete rOptions.subDocPath;\n  \n        // Traverse the dereferenced value\n        doc = refValue;\n      } else {\n        rOptions.relativeBase = path.dirname(parents[parents.length - 1]);\n  \n        if (subDocPath.length === 0) {\n          delete rOptions.subDocPath;\n        } else {\n          rOptions.subDocPath = subDocPath;\n        }\n      }\n  \n      return findRefsRecursive(doc, rOptions, parents, parentPtrs, allRefs, indirect);\n    }\n  }\n  \n  // Should this be its own exported API?\n  function findRefsRecursive (obj, options, parents, parentPtrs, allRefs, indirect) {\n    var allTasks = Promise.resolve();\n    var parentPath = parentPtrs.length ? pathFromPtr(parentPtrs[parentPtrs.length - 1]) : [];\n    var refs = findRefs(obj, options);\n    var subDocPath = options.subDocPath || [];\n    var subDocPtr = pathToPtr(subDocPath);\n    var ancestorPtrs = ['#'];\n  \n    parents.forEach(function (parent, index) {\n      if (parent.charAt(0) !== '#') {\n        ancestorPtrs.push(parentPtrs[index]);\n      }\n    });\n  \n    // Reverse the order so we search them in the proper order\n    ancestorPtrs.reverse();\n  \n    if ((parents[parents.length - 1] || '').charAt(0) !== '#') {\n      allRefs.documents[pathToPtr(parentPath)] = obj;\n    }\n  \n    Object.keys(refs).forEach(function (refPtr) {\n      var refDetails = refs[refPtr];\n      var location;\n      var parentIndex;\n      var refFullPath;\n      var refFullPtr;\n  \n      // If there are no parents, treat the reference pointer as-is.  Otherwise, the reference is a reference within a\n      // remote document and its sub document path prefix must be removed.\n      if (parents.length === 0) {\n        refFullPath = parentPath.concat(pathFromPtr(refPtr));\n      } else {\n        refFullPath = parentPath.concat(pathFromPtr(refPtr).slice(parents.length === 0 ? 0 : subDocPath.length));\n      }\n  \n      refFullPtr = pathToPtr(refFullPath);\n  \n      // It is possible to process the same reference more than once in the event of hierarchical references so we avoid\n      // processing a reference if we've already done so.\n      if (!isType(allRefs[refFullPtr], 'Undefined')) {\n        return;\n      }\n  \n      // Record the reference metadata\n      allRefs.refs[refFullPtr] = refs[refPtr];\n  \n      // Do not process invalid references\n      if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n        if (remoteTypes.indexOf(refDetails.type) > -1) {\n          location = combineURIs(options.relativeBase, refDetails.uri);\n          parentIndex = parents.indexOf(location);\n        } else {\n          location = refDetails.uri;\n          parentIndex = parentPtrs.indexOf(location);\n        }\n  \n        // Record ancestor paths\n        refDetails.ancestorPtrs = ancestorPtrs;\n  \n        // Record if the reference is indirect based on its parent\n        refDetails.indirect = indirect;\n  \n        // Only process non-circular references further\n        if (parentIndex === -1) {\n          if (remoteTypes.indexOf(refDetails.type) > -1) {\n            allTasks = allTasks\n              .then(function () {\n                return getRemoteDocument(location, options)\n                  .then(function (doc) {\n                    return processSubDocument('remote',\n                                              doc,\n                                              isType(refDetails.uriDetails.fragment, 'Undefined') ?\n                                                [] :\n                                                pathFromPtr(decodeURI(refDetails.uriDetails.fragment)),\n                                              refDetails,\n                                              options,\n                                              parents.concat(location),\n                                              parentPtrs.concat(refFullPtr),\n                                              allRefs,\n                                              indirect);\n                  })\n                  .catch(function (err) {\n                    refDetails.error = err.message;\n                    refDetails.missing = true;\n                  });\n              });\n          } else {\n            if (refFullPtr.indexOf(location + '/') !== 0 && refFullPtr !== location &&\n                subDocPtr.indexOf(location + '/') !== 0 && subDocPtr !== location) {\n              if (location.indexOf(subDocPtr + '/') !== 0) {\n                allTasks = allTasks\n                  .then(function () {\n                    return processSubDocument('local',\n                                              obj,\n                                              pathFromPtr(location),\n                                              refDetails,\n                                              options,\n                                              parents.concat(location),\n                                              parentPtrs.concat(refFullPtr),\n                                              allRefs,\n                                              indirect || (location.indexOf(subDocPtr + '/') === -1 && location !== subDocPtr));\n                  });\n              }\n            } else {\n              refDetails.circular = true;\n            }\n          }\n        } else {\n          // Mark seen ancestors as circular\n          parentPtrs.slice(parentIndex).forEach(function (parentPtr) {\n            allRefs.refs[parentPtr].circular = true;\n          });\n  \n          refDetails.circular = true;\n        }\n      }\n    });\n  \n    allTasks = allTasks\n      .then(function () {\n        // Identify indirect, local circular references (Issue 82)\n        var circulars = [];\n        var processedRefPtrs = [];\n        var processedRefs = [];\n  \n        function walkRefs (parentPtrs, parentRefs, refPtr, ref) {\n          Object.keys(allRefs.refs).forEach(function (dRefPtr) {\n            var dRefDetails = allRefs.refs[dRefPtr];\n  \n            // Do not process already processed references or references that are not a nested references\n            if (processedRefs.indexOf(ref) === -1 && processedRefPtrs.indexOf(refPtr) === -1 &&\n                circulars.indexOf(ref) === -1 && dRefPtr !== refPtr && dRefPtr.indexOf(ref + '/') === 0) {\n              if (parentRefs.indexOf(ref) > -1) {\n                parentRefs.forEach(function (parentRef) {\n                  if (circulars.indexOf(ref) === -1) {\n                    circulars.push(parentRef);\n                  }\n                });\n              } else {\n                walkRefs(parentPtrs.concat(refPtr), parentRefs.concat(ref), dRefPtr, dRefDetails.uri);\n              }\n  \n              processedRefPtrs.push(refPtr);\n              processedRefs.push(ref);\n            }\n          });\n        }\n  \n        Object.keys(allRefs.refs).forEach(function (refPtr) {\n          var refDetails = allRefs.refs[refPtr];\n  \n          // Only process local, non-circular references\n          if (refDetails.type === 'local' && !refDetails.circular && circulars.indexOf(refDetails.uri) === -1) {\n            walkRefs([], [], refPtr, refDetails.uri);\n          }\n        });\n  \n        Object.keys(allRefs.refs).forEach(function (refPtr) {\n          var refDetails = allRefs.refs[refPtr];\n  \n          if (circulars.indexOf(refDetails.uri) > -1) {\n            refDetails.circular = true;\n          }\n        });\n      })\n      .then(function () {\n        return allRefs;\n      });\n  \n    return allTasks;\n  }\n  \n  function findValue (obj, path) {\n    var value = obj;\n  \n    path.forEach(function (seg) {\n      seg = decodeURI(seg);\n  \n      if (seg in value) {\n        value = value[seg];\n      } else {\n        throw Error('JSON Pointer points to missing location: ' + pathToPtr(path));\n      }\n    });\n  \n    return value;\n  }\n  \n  function getExtraRefKeys (ref) {\n    return Object.keys(ref).filter(function (key) {\n      return key !== '$ref';\n    });\n  }\n  \n  function getRefType (refDetails) {\n    var type;\n  \n    // Convert the URI reference to one of our types\n    switch (refDetails.uriDetails.reference) {\n    case 'absolute':\n    case 'uri':\n      type = 'remote';\n      break;\n    case 'same-document':\n      type = 'local';\n      break;\n    default:\n      type = refDetails.uriDetails.reference;\n    }\n  \n    return type;\n  }\n  \n  function getRemoteDocument (url, options) {\n    var cacheEntry = remoteCache[url];\n    var allTasks = Promise.resolve();\n    var loaderOptions = clone(options.loaderOptions || {});\n  \n    if (isType(cacheEntry, 'Undefined')) {\n      // If there is no content processor, default to processing the raw response as JSON\n      if (isType(loaderOptions.processContent, 'Undefined')) {\n        loaderOptions.processContent = function (res, callback) {\n          callback(undefined, JSON.parse(res.text));\n        };\n      }\n  \n      // Attempt to load the resource using path-loader\n      allTasks = PathLoader.load(decodeURI(url), loaderOptions);\n  \n      // Update the cache\n      allTasks = allTasks\n        .then(function (res) {\n          remoteCache[url] = {\n            value: res\n          };\n  \n          return res;\n        })\n        .catch(function (err) {\n          remoteCache[url] = {\n            error: err\n          };\n  \n          throw err;\n        });\n    } else {\n      // Return the cached version\n      allTasks = allTasks.then(function () {\n        return cacheEntry.value;\n      });\n    }\n  \n    // Return a cloned version to avoid updating the cache\n    allTasks = allTasks.then(function (res) {\n      return clone(res);\n    });\n  \n    return allTasks;\n  }\n  \n  function isRefLike (obj, throwWithDetails) {\n    var refLike = true;\n  \n    try {\n      if (!isType(obj, 'Object')) {\n        throw new Error('obj is not an Object');\n      } else if (!isType(obj.$ref, 'String')) {\n        throw new Error('obj.$ref is not a String');\n      }\n    } catch (err) {\n      if (throwWithDetails) {\n        throw err;\n      }\n  \n      refLike = false;\n    }\n  \n    return refLike;\n  }\n  \n  function isType (obj, type) {\n    // A PhantomJS bug (https://github.com/ariya/phantomjs/issues/11722) prohibits us from using the same approach for\n    // undefined checking that we use for other types.\n    if (type === 'Undefined') {\n      return typeof obj === 'undefined';\n    } else {\n      return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n    }\n  }\n  \n  function makeRefFilter (options) {\n    var refFilter;\n    var validTypes;\n  \n    if (isType(options.filter, 'Array') || isType(options.filter, 'String')) {\n      validTypes = isType(options.filter, 'String') ? [options.filter] : options.filter;\n      refFilter = function (refDetails) {\n        // Check the exact type or for invalid URIs, check its original type\n        return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;\n      };\n    } else if (isType(options.filter, 'Function')) {\n      refFilter = options.filter;\n    } else if (isType(options.filter, 'Undefined')) {\n      refFilter = function () {\n        return true;\n      };\n    }\n  \n    return function (refDetails, path) {\n      return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);\n    };\n  }\n  \n  function makeSubDocPath (options) {\n    var subDocPath;\n  \n    if (isType(options.subDocPath, 'Array')) {\n      subDocPath = options.subDocPath;\n    } else if (isType(options.subDocPath, 'String')) {\n      subDocPath = pathFromPtr(options.subDocPath);\n    } else if (isType(options.subDocPath, 'Undefined')) {\n      subDocPath = [];\n    }\n  \n    return subDocPath;\n  }\n  \n  function parseURI (uri) {\n    // We decode first to avoid doubly encoding\n    return URI.parse(encodeURI(decodeURI(uri)));\n  }\n  \n  function setValue (obj, refPath, value) {\n    findValue(obj, refPath.slice(0, refPath.length - 1))[decodeURI(refPath[refPath.length - 1])] = value;\n  }\n  \n  function walk (ancestors, node, path, fn) {\n    var processChildren = true;\n  \n    function walkItem (item, segment) {\n      path.push(segment);\n      walk(ancestors, item, path, fn);\n      path.pop();\n    }\n  \n    // Call the iteratee\n    if (isType(fn, 'Function')) {\n      processChildren = fn(ancestors, node, path);\n    }\n  \n    // We do not process circular objects again\n    if (ancestors.indexOf(node) === -1) {\n      ancestors.push(node);\n  \n      if (processChildren !== false) {\n        if (isType(node, 'Array')) {\n          node.forEach(function (member, index) {\n            walkItem(member, index.toString());\n          });\n        } else if (isType(node, 'Object')) {\n          Object.keys(node).forEach(function (key) {\n            walkItem(node[key], key);\n          });\n        }\n      }\n    }\n  \n    ancestors.pop();\n  }\n  \n  function validateOptions (options, obj) {\n    if (isType(options, 'Undefined')) {\n      // Default to an empty options object\n      options = {};\n    } else {\n      // Clone the options so we do not alter the ones passed in\n      options = clone(options);\n    }\n  \n    if (!isType(options, 'Object')) {\n      throw new TypeError('options must be an Object');\n    } else if (!isType(options.filter, 'Undefined') &&\n               !isType(options.filter, 'Array') &&\n               !isType(options.filter, 'Function') &&\n               !isType(options.filter, 'String')) {\n      throw new TypeError('options.filter must be an Array, a Function of a String');\n    } else if (!isType(options.includeInvalid, 'Undefined') &&\n               !isType(options.includeInvalid, 'Boolean')) {\n      throw new TypeError('options.includeInvalid must be a Boolean');\n    } else if (!isType(options.refPreProcessor, 'Undefined') &&\n               !isType(options.refPreProcessor, 'Function')) {\n      throw new TypeError('options.refPreProcessor must be a Function');\n    } else if (!isType(options.refPostProcessor, 'Undefined') &&\n               !isType(options.refPostProcessor, 'Function')) {\n      throw new TypeError('options.refPostProcessor must be a Function');\n    } else if (!isType(options.subDocPath, 'Undefined') &&\n               !isType(options.subDocPath, 'Array') &&\n               !isPtr(options.subDocPath)) {\n      // If a pointer is provided, throw an error if it's not the proper type\n      throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');\n    }\n  \n    options.filter = makeRefFilter(options);\n  \n    // Set the subDocPath to avoid everyone else having to compute it\n    options.subDocPath = makeSubDocPath(options);\n  \n    if (!isType(obj, 'Undefined')) {\n      try {\n        findValue(obj, options.subDocPath);\n      } catch (err) {\n        err.message = err.message.replace('JSON Pointer', 'options.subDocPath');\n  \n        throw err;\n      }\n    }\n  \n    return options;\n  }\n  \n  /* Module Members */\n  \n  /*\n   * Each of the functions below are defined as function statements and *then* exported in two steps instead of one due\n   * to a bug in jsdoc (https://github.com/jsdoc2md/jsdoc-parse/issues/18) that causes our documentation to be\n   * generated improperly.  The impact to the user is significant enough for us to warrant working around it until this\n   * is fixed.\n   */\n  \n  /**\n   * The options used for various JsonRefs APIs.\n   *\n   * @typedef {object} JsonRefsOptions\n   *\n   * @param {string|string[]|function} [filter=function () {return true;}] - The filter to use when gathering JSON\n   * References *(If this value is a single string or an array of strings, the value(s) are expected to be the `type(s)`\n   * you are interested in collecting as described in {@link module:JsonRefs.getRefDetails}.  If it is a function, it is\n   * expected that the function behaves like {@link module:JsonRefs~RefDetailsFilter}.)*\n   * @param {boolean} [includeInvalid=false] - Whether or not to include invalid JSON Reference details *(This will make\n   * it so that objects that are like JSON Reference objects, as in they are an `Object` and the have a `$ref` property,\n   * but fail validation will be included.  This is very useful for when you want to know if you have invalid JSON\n   * Reference definitions.  This will not mean that APIs will process invalid JSON References but the reasons as to why\n   * the JSON References are invalid will be included in the returned metadata.)*\n   * @param {object} [loaderOptions] - The options to pass to\n   * {@link https://github.com/whitlockjc/path-loader/blob/master/docs/API.md#module_PathLoader.load|PathLoader~load}\n   * @param {module:JsonRefs~RefPreProcessor} [refPreProcessor] - The callback used to pre-process a JSON Reference like\n   * object *(This is called prior to validating the JSON Reference like object and getting its details)*\n   * @param {module:JsonRefs~RefPostProcessor} [refPostProcessor] - The callback used to post-process the JSON Reference\n   * metadata *(This is called prior filtering the references)*\n   * @param {string} [options.relativeBase] - The base location to use when resolving relative references *(Only useful\n   * for APIs that do remote reference resolution.  If this value is not defined,\n   * {@link https://github.com/whitlockjc/path-loader|path-loader} will use `window.location.href` for the browser and\n   * `process.cwd()` for Node.js.)*\n   * @param {string|string[]} [options.subDocPath=[]] - The JSON Pointer or array of path segments to the sub document\n   * location to search from\n   */\n  \n  /**\n   * Simple function used to filter out JSON References.\n   *\n   * @typedef {function} RefDetailsFilter\n   *\n   * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n   * @param {string[]} path - The path to the JSON Reference\n   *\n   * @returns {boolean} whether the JSON Reference should be filtered *(out)* or not\n   */\n  \n  /**\n   * Simple function used to pre-process a JSON Reference like object.\n   *\n   * @typedef {function} RefPreProcessor\n   *\n   * @param {object} obj - The JSON Reference like object\n   * @param {string[]} path - The path to the JSON Reference like object\n   *\n   * @returns {object} the processed JSON Reference like object\n   */\n  \n  /**\n   * Simple function used to post-process a JSON Reference details.\n   *\n   * @typedef {function} RefPostProcessor\n   *\n   * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n   * @param {string[]} path - The path to the JSON Reference\n   *\n   * @returns {object} the processed JSON Reference details object\n   */\n  \n  /**\n   * Detailed information about resolved JSON References.\n   *\n   * @typedef {module:JsonRefs~UnresolvedRefDetails} ResolvedRefDetails\n   *\n   * @property {boolean} [circular] - Whether or not the JSON Reference is circular *(Will not be set if the JSON\n   * Reference is not circular)*\n   * @property {boolean} [missing] - Whether or not the referenced value was missing or not *(Will not be set if the\n   * referenced value is not missing)*\n   * @property {*} [value] - The referenced value *(Will not be set if the referenced value is missing)*\n   */\n  \n  /**\n   * The results of resolving the JSON References of an array/object.\n   *\n   * @typedef {object} ResolvedRefsResults\n   *\n   * @property {module:JsonRefs~ResolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n   * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n   * @property {object} resolved - The array/object with its JSON References fully resolved\n   */\n  \n  /**\n   * An object containing the retrieved document and detailed information about its JSON References.\n   *\n   * @typedef {module:JsonRefs~ResolvedRefsResults} RetrievedRefsResults\n   *\n   * @property {object} value - The retrieved document\n   */\n  \n  /**\n   * An object containing the retrieved document, the document with its references resolved and  detailed information\n   * about its JSON References.\n   *\n   * @typedef {object} RetrievedResolvedRefsResults\n   *\n   * @property {module:JsonRefs~UnresolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n   * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~UnresolvedRefDetails}\n   * @property {ResolvedRefsResults} - An object whose keys are JSON Pointers *(fragment version)*\n   * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n   * @property {object} value - The retrieved document\n   */\n  \n  /**\n   * Detailed information about unresolved JSON References.\n   *\n   * @typedef {object} UnresolvedRefDetails\n   *\n   * @property {object} def - The JSON Reference definition\n   * @property {string} [error] - The error information for invalid JSON Reference definition *(Only present when the\n   * JSON Reference definition is invalid or there was a problem retrieving a remote reference during resolution)*\n   * @property {string} uri - The URI portion of the JSON Reference\n   * @property {object} uriDetails - Detailed information about the URI as provided by\n   * {@link https://github.com/garycourt/uri-js|URI.parse}.\n   * @property {string} type - The JSON Reference type *(This value can be one of the following: `invalid`, `local`,\n   * `relative` or `remote`.)*\n   * @property {string} [warning] - The warning information *(Only present when the JSON Reference definition produces a\n   * warning)*\n   */\n  \n  /**\n   * Clears the internal cache of remote documents, reference details, etc.\n   *\n   * @alias module:JsonRefs.clearCache\n   */\n  function clearCache () {\n    remoteCache = {};\n  }\n  \n  /**\n   * Takes an array of path segments and decodes the JSON Pointer tokens in them.\n   *\n   * @param {string[]} path - The array of path segments\n   *\n   * @returns {string} the array of path segments with their JSON Pointer tokens decoded\n   *\n   * @throws {Error} if the path is not an `Array`\n   *\n   * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n   *\n   * @alias module:JsonRefs.decodePath\n   */\n  function decodePath (path) {\n    if (!isType(path, 'Array')) {\n      throw new TypeError('path must be an array');\n    }\n  \n    return path.map(function (seg) {\n      if (!isType(seg, 'String')) {\n        seg = JSON.stringify(seg);\n      }\n  \n      return decodeURI(seg.replace(/~1/g, '/').replace(/~0/g, '~'));\n    });\n  }\n  \n  /**\n   * Takes an array of path segments and encodes the special JSON Pointer characters in them.\n   *\n   * @param {string[]} path - The array of path segments\n   *\n   * @returns {string} the array of path segments with their JSON Pointer tokens encoded\n   *\n   * @throws {Error} if the path is not an `Array`\n   *\n   * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n   *\n   * @alias module:JsonRefs.encodePath\n   */\n  function encodePath (path) {\n    if (!isType(path, 'Array')) {\n      throw new TypeError('path must be an array');\n    }\n  \n    return path.map(function (seg) {\n      if (!isType(seg, 'String')) {\n        seg = JSON.stringify(seg);\n      }\n  \n      return seg.replace(/~/g, '~0').replace(/\\//g, '~1');\n    });\n  }\n  \n  /**\n   * Finds JSON References defined within the provided array/object.\n   *\n   * @param {array|object} obj - The structure to find JSON References within\n   * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n   *\n   * @returns {object} an object whose keys are JSON Pointers *(fragment version)* to where the JSON Reference is defined\n   * and whose values are {@link module:JsonRefs~UnresolvedRefDetails}.\n   *\n   * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location\n   *\n   * @alias module:JsonRefs.findRefs\n   *\n   * @example\n   * // Finding all valid references\n   * var allRefs = JsonRefs.findRefs(obj);\n   * // Finding all remote references\n   * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});\n   * // Finding all invalid references\n   * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});\n   */\n  function findRefs (obj, options) {\n    var refs = {};\n  \n    // Validate the provided document\n    if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n      throw new TypeError('obj must be an Array or an Object');\n    }\n  \n    // Validate options\n    options = validateOptions(options, obj);\n  \n    // Walk the document (or sub document) and find all JSON References\n    walk(findAncestors(obj, options.subDocPath),\n         findValue(obj, options.subDocPath),\n         clone(options.subDocPath),\n         function (ancestors, node, path) {\n           var processChildren = true;\n           var refDetails;\n  \n           if (isRefLike(node)) {\n             // Pre-process the node when necessary\n             if (!isType(options.refPreProcessor, 'Undefined')) {\n               node = options.refPreProcessor(clone(node), path);\n             }\n  \n             refDetails = getRefDetails(node);\n  \n             // Post-process the reference details\n             if (!isType(options.refPostProcessor, 'Undefined')) {\n               refDetails = options.refPostProcessor(refDetails, path);\n             }\n  \n             if (options.filter(refDetails, path)) {\n               refs[pathToPtr(path)] = refDetails;\n             }\n  \n             // Whenever a JSON Reference has extra children, its children should not be processed.\n             //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3\n             if (getExtraRefKeys(node).length > 0) {\n               processChildren = false;\n             }\n           }\n  \n           return processChildren;\n         });\n  \n    return refs;\n  }\n  \n  /**\n   * Finds JSON References defined within the document at the provided location.\n   *\n   * This API is identical to {@link module:JsonRefs.findRefs} except this API will retrieve a remote document and then\n   * return the result of {@link module:JsonRefs.findRefs} on the retrieved document.\n   *\n   * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n   * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n   * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n   *\n   * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedRefsResults} and rejects with an\n   * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n   *  the location argument points to an unloadable resource\n   *\n   * @alias module:JsonRefs.findRefsAt\n   *\n   * @example\n   * // Example that only resolves references within a sub document\n   * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {\n   *     subDocPath: '#/definitions'\n   *   })\n   *   .then(function (res) {\n   *      // Do something with the response\n   *      //\n   *      // res.refs: JSON Reference locations and details\n   *      // res.value: The retrieved document\n   *   }, function (err) {\n   *     console.log(err.stack);\n   *   });\n   */\n  function findRefsAt (location, options) {\n    var allTasks = Promise.resolve();\n  \n    allTasks = allTasks\n      .then(function () {\n        // Validate the provided location\n        if (!isType(location, 'String')) {\n          throw new TypeError('location must be a string');\n        }\n  \n        // Validate options\n        options = validateOptions(options);\n  \n        // Combine the location and the optional relative base\n        location = combineURIs(options.relativeBase, location);\n  \n        return getRemoteDocument(location, options);\n      })\n      .then(function (res) {\n        var cacheEntry = clone(remoteCache[location]);\n        var cOptions = clone(options);\n        var uriDetails = parseURI(location);\n  \n        if (isType(cacheEntry.refs, 'Undefined')) {\n          // Do not filter any references so the cache is complete\n          delete cOptions.filter;\n          delete cOptions.subDocPath;\n  \n          cOptions.includeInvalid = true;\n  \n          remoteCache[location].refs = findRefs(res, cOptions);\n        }\n  \n        // Add the filter options back\n        if (!isType(options.filter, 'Undefined')) {\n          cOptions.filter = options.filter;\n        }\n  \n        if (!isType(uriDetails.fragment, 'Undefined')) {\n          cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n        } else if (!isType(uriDetails.subDocPath, 'Undefined')) {\n          cOptions.subDocPath = options.subDocPath;\n        }\n  \n        // This will use the cache so don't worry about calling it twice\n        return {\n          refs: findRefs(res, cOptions),\n          value: res\n        };\n      });\n  \n    return allTasks;\n  }\n  \n  /**\n   * Returns detailed information about the JSON Reference.\n   *\n   * @param {object} obj - The JSON Reference definition\n   *\n   * @returns {module:JsonRefs~UnresolvedRefDetails} the detailed information\n   *\n   * @alias module:JsonRefs.getRefDetails\n   */\n  function getRefDetails (obj) {\n    var details = {\n      def: obj\n    };\n    var cacheKey;\n    var extraKeys;\n    var uriDetails;\n  \n    try {\n      if (isRefLike(obj, true)) {\n        cacheKey = obj.$ref;\n        uriDetails = uriDetailsCache[cacheKey];\n  \n        if (isType(uriDetails, 'Undefined')) {\n          uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);\n        }\n  \n        details.uri = cacheKey;\n        details.uriDetails = uriDetails;\n  \n        if (isType(uriDetails.error, 'Undefined')) {\n          details.type = getRefType(details);\n        } else {\n          details.error = details.uriDetails.error;\n          details.type = 'invalid';\n        }\n  \n        // Identify warning\n        extraKeys = getExtraRefKeys(obj);\n  \n        if (extraKeys.length > 0) {\n          details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');\n        }\n      } else {\n        details.type = 'invalid';\n      }\n    } catch (err) {\n      details.error = err.message;\n      details.type = 'invalid';\n    }\n  \n    return details;\n  }\n  \n  /**\n   * Returns whether the argument represents a JSON Pointer.\n   *\n   * A string is a JSON Pointer if the following are all true:\n   *\n   *   * The string is of type `String`\n   *   * The string must be empty, `#` or start with a `/` or `#/`\n   *\n   * @param {string} ptr - The string to check\n   * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n   * provided is invalid\n   *\n   * @returns {boolean} the result of the check\n   *\n   * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n   *\n   * @alias module:JsonRefs.isPtr\n   *\n   * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n   *\n   * @example\n   * // Separating the different ways to invoke isPtr for demonstration purposes\n   * if (isPtr(str)) {\n   *   // Handle a valid JSON Pointer\n   * } else {\n   *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it\n   *   try {\n   *     isPtr(str, true);\n   *   } catch (err) {\n   *     // The error message contains the details as to why the provided value is not a JSON Pointer\n   *   }\n   * }\n   */\n  function isPtr (ptr, throwWithDetails) {\n    var valid = true;\n    var firstChar;\n  \n    try {\n      if (isType(ptr, 'String')) {\n        if (ptr !== '') {\n          firstChar = ptr.charAt(0);\n  \n          if (['#', '/'].indexOf(firstChar) === -1) {\n            throw new Error('ptr must start with a / or #/');\n          } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {\n            throw new Error('ptr must start with a / or #/');\n          } else if (ptr.match(badPtrTokenRegex)) {\n            throw new Error('ptr has invalid token(s)');\n          }\n        }\n      } else {\n        throw new Error('ptr is not a String');\n      }\n    } catch (err) {\n      if (throwWithDetails === true) {\n        throw err;\n      }\n  \n      valid = false;\n    }\n  \n    return valid;\n  }\n  \n  /**\n   * Returns whether the argument represents a JSON Reference.\n   *\n   * An object is a JSON Reference only if the following are all true:\n   *\n   *   * The object is of type `Object`\n   *   * The object has a `$ref` property\n   *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special\n   *     characters.)*\n   *\n   * @param {object} obj - The object to check\n   * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n   * provided is invalid\n   *\n   * @returns {boolean} the result of the check\n   *\n   * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n   *\n   * @alias module:JsonRefs.isRef\n   *\n   * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}\n   *\n   * @example\n   * // Separating the different ways to invoke isRef for demonstration purposes\n   * if (isRef(obj)) {\n   *   // Handle a valid JSON Reference\n   * } else {\n   *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it\n   *   try {\n   *     isRef(str, true);\n   *   } catch (err) {\n   *     // The error message contains the details as to why the provided value is not a JSON Reference\n   *   }\n   * }\n   */\n  function isRef (obj, throwWithDetails) {\n    return isRefLike(obj, throwWithDetails) && getRefDetails(obj, throwWithDetails).type !== 'invalid';\n  }\n  \n  /**\n   * Returns an array of path segments for the provided JSON Pointer.\n   *\n   * @param {string} ptr - The JSON Pointer\n   *\n   * @returns {string[]} the path segments\n   *\n   * @throws {Error} if the provided `ptr` argument is not a JSON Pointer\n   *\n   * @alias module:JsonRefs.pathFromPtr\n   */\n  function pathFromPtr (ptr) {\n    if (!isPtr(ptr)) {\n      throw new Error('ptr must be a JSON Pointer');\n    }\n  \n    var segments = ptr.split('/');\n  \n    // Remove the first segment\n    segments.shift();\n  \n    return decodePath(segments);\n  }\n  \n  /**\n   * Returns a JSON Pointer for the provided array of path segments.\n   *\n   * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.\n   *\n   * @param {string[]} path - The array of path segments\n   * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer\n   *\n   * @returns {string} the corresponding JSON Pointer\n   *\n   * @throws {Error} if the `path` argument is not an array\n   *\n   * @alias module:JsonRefs.pathToPtr\n   */\n  function pathToPtr (path, hashPrefix) {\n    if (!isType(path, 'Array')) {\n      throw new Error('path must be an Array');\n    }\n  \n    // Encode each segment and return\n    return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + encodePath(path).join('/');\n  }\n  \n  /**\n   * Finds JSON References defined within the provided array/object and resolves them.\n   *\n   * @param {array|object} obj - The structure to find JSON References within\n   * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n   *\n   * @returns {Promise} a promise that resolves a {@link module:JsonRefs~ResolvedRefsResults} and rejects with an\n   * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n   *  the location argument points to an unloadable resource\n   *\n   * @alias module:JsonRefs.resolveRefs\n   *\n   * @example\n   * // Example that only resolves relative and remote references\n   * JsonRefs.resolveRefs(swaggerObj, {\n   *     filter: ['relative', 'remote']\n   *   })\n   *   .then(function (res) {\n   *      // Do something with the response\n   *      //\n   *      // res.refs: JSON Reference locations and details\n   *      // res.resolved: The document with the appropriate JSON References resolved\n   *   }, function (err) {\n   *     console.log(err.stack);\n   *   });\n   */\n  function resolveRefs (obj, options) {\n    var allTasks = Promise.resolve();\n  \n    allTasks = allTasks\n      .then(function () {\n        // Validate the provided document\n        if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n          throw new TypeError('obj must be an Array or an Object');\n        }\n  \n        // Validate options\n        options = validateOptions(options, obj);\n  \n        // Clone the input so we do not alter it\n        obj = clone(obj);\n      })\n      .then(function () {\n        return findRefsRecursive(obj, options, [], [], {\n          documents: {},\n          refs: {}\n        });\n      })\n      .then(function (allRefs) {\n        var deferredRefs = {};\n        var refs = {};\n  \n        function pathSorter (p1, p2) {\n          return pathFromPtr(p1).length - pathFromPtr(p2).length;\n        }\n  \n        // Resolve all references with a known value\n        Object.keys(allRefs.refs).sort(pathSorter).forEach(function (refPtr) {\n          var refDetails = allRefs.refs[refPtr];\n  \n          // Record all direct references\n          if (!refDetails.indirect) {\n            refs[refPtr] = refDetails;\n          }\n  \n          // Delete helper property\n          delete refDetails.indirect;\n  \n          if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n            if (isType(refDetails.value, 'Undefined') && refDetails.circular) {\n              refDetails.value = refDetails.def;\n            }\n  \n            // We defer processing all references without a value until later\n            if (isType(refDetails.value, 'Undefined')) {\n              deferredRefs[refPtr] = refDetails;\n            } else {\n              if (refPtr === '#') {\n                obj = refDetails.value;\n              } else {\n                setValue(obj, pathFromPtr(refPtr), refDetails.value);\n              }\n  \n              // Delete helper property\n              delete refDetails.ancestorPtrs;\n            }\n          } else {\n            // Delete helper property\n            delete refDetails.ancestorPtrs;\n          }\n        });\n  \n        // Resolve all deferred references\n        Object.keys(deferredRefs).forEach(function (refPtr) {\n          var refDetails = deferredRefs[refPtr];\n  \n          // Attempt to resolve the value against all if its ancestors in order\n          refDetails.ancestorPtrs.forEach(function (ancestorPtr, index) {\n            if (isType(refDetails.value, 'Undefined')) {\n              try {\n                refDetails.value = findValue(allRefs.documents[ancestorPtr], pathFromPtr(refDetails.uri));\n  \n                // Delete helper property\n                delete refDetails.ancestorPtrs;\n  \n                setValue(obj, pathFromPtr(refPtr), refDetails.value);\n              } catch (err) {\n                if (index === refDetails.ancestorPtrs.length - 1) {\n                  refDetails.error = err.message;\n                  refDetails.missing = true;\n  \n                  // Delete helper property\n                  delete refDetails.ancestorPtrs;\n                }\n              }\n            }\n          });\n        });\n  \n        return {\n          refs: refs,\n          resolved: obj\n        };\n      });\n  \n    return allTasks;\n  }\n  \n  /**\n   * Resolves JSON References defined within the document at the provided location.\n   *\n   * This API is identical to {@link module:JsonRefs.resolveRefs} except this API will retrieve a remote document and then\n   * return the result of {@link module:JsonRefs.resolveRefs} on the retrieved document.\n   *\n   * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n   * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n   * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n   *\n   * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedResolvedRefsResults} and rejects with an\n   * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n   *  the location argument points to an unloadable resource\n   *\n   * @alias module:JsonRefs.resolveRefsAt\n   *\n   * @example\n   * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references\n   * JsonRefs.resolveRefsAt('./swagger.json')\n   *   .then(function (res) {\n   *      // Do something with the response\n   *      //\n   *      // res.refs: JSON Reference locations and details\n   *      // res.resolved: The document with the appropriate JSON References resolved\n   *      // res.value: The retrieved document\n   *   }, function (err) {\n   *     console.log(err.stack);\n   *   });\n   */\n  function resolveRefsAt (location, options) {\n    var allTasks = Promise.resolve();\n  \n    allTasks = allTasks\n      .then(function () {\n        // Validate the provided location\n        if (!isType(location, 'String')) {\n          throw new TypeError('location must be a string');\n        }\n  \n        // Validate options\n        options = validateOptions(options);\n  \n        // Combine the location and the optional relative base\n        location = combineURIs(options.relativeBase, location);\n  \n        return getRemoteDocument(location, options);\n      })\n      .then(function (res) {\n        var cOptions = clone(options);\n        var uriDetails = parseURI(location);\n  \n        // Set the sub document path if necessary\n        if (!isType(uriDetails.fragment, 'Undefined')) {\n          cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n        }\n  \n        // Update the relative base based on the retrieved location\n        cOptions.relativeBase = path.dirname(location);\n  \n        return resolveRefs(res, cOptions)\n          .then(function (res2) {\n            return {\n              refs: res2.refs,\n              resolved: res2.resolved,\n              value: res\n            };\n          });\n      });\n  \n    return allTasks;\n  }\n  \n  /* Export the module members */\n  module.exports.clearCache = clearCache;\n  module.exports.decodePath = decodePath;\n  module.exports.encodePath = encodePath;\n  module.exports.findRefs = findRefs;\n  module.exports.findRefsAt = findRefsAt;\n  module.exports.getRefDetails = getRefDetails;\n  module.exports.isPtr = isPtr;\n  module.exports.isRef = isRef;\n  module.exports.pathFromPtr = pathFromPtr;\n  module.exports.pathToPtr = pathToPtr;\n  module.exports.resolveRefs = resolveRefs;\n  module.exports.resolveRefsAt = resolveRefsAt;\n  \n  },{\"native-promise-only\":3,\"path\":4,\"path-loader\":5,\"querystring\":11,\"slash\":13,\"uri-js\":23}],2:[function(require,module,exports){\n  \n  /**\n   * Expose `Emitter`.\n   */\n  \n  module.exports = Emitter;\n  \n  /**\n   * Initialize a new `Emitter`.\n   *\n   * @api public\n   */\n  \n  function Emitter(obj) {\n    if (obj) return mixin(obj);\n  };\n  \n  /**\n   * Mixin the emitter properties.\n   *\n   * @param {Object} obj\n   * @return {Object}\n   * @api private\n   */\n  \n  function mixin(obj) {\n    for (var key in Emitter.prototype) {\n      obj[key] = Emitter.prototype[key];\n    }\n    return obj;\n  }\n  \n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n  \n  Emitter.prototype.on =\n  Emitter.prototype.addEventListener = function(event, fn){\n    this._callbacks = this._callbacks || {};\n    (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n      .push(fn);\n    return this;\n  };\n  \n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n  \n  Emitter.prototype.once = function(event, fn){\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n  \n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n  \n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n  \n  Emitter.prototype.off =\n  Emitter.prototype.removeListener =\n  Emitter.prototype.removeAllListeners =\n  Emitter.prototype.removeEventListener = function(event, fn){\n    this._callbacks = this._callbacks || {};\n  \n    // all\n    if (0 == arguments.length) {\n      this._callbacks = {};\n      return this;\n    }\n  \n    // specific event\n    var callbacks = this._callbacks['$' + event];\n    if (!callbacks) return this;\n  \n    // remove all handlers\n    if (1 == arguments.length) {\n      delete this._callbacks['$' + event];\n      return this;\n    }\n  \n    // remove specific handler\n    var cb;\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    }\n    return this;\n  };\n  \n  /**\n   * Emit `event` with the given args.\n   *\n   * @param {String} event\n   * @param {Mixed} ...\n   * @return {Emitter}\n   */\n  \n  Emitter.prototype.emit = function(event){\n    this._callbacks = this._callbacks || {};\n    var args = [].slice.call(arguments, 1)\n      , callbacks = this._callbacks['$' + event];\n  \n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n  \n    return this;\n  };\n  \n  /**\n   * Return array of callbacks for `event`.\n   *\n   * @param {String} event\n   * @return {Array}\n   * @api public\n   */\n  \n  Emitter.prototype.listeners = function(event){\n    this._callbacks = this._callbacks || {};\n    return this._callbacks['$' + event] || [];\n  };\n  \n  /**\n   * Check if this emitter has `event` handlers.\n   *\n   * @param {String} event\n   * @return {Boolean}\n   * @api public\n   */\n  \n  Emitter.prototype.hasListeners = function(event){\n    return !! this.listeners(event).length;\n  };\n  \n  },{}],3:[function(require,module,exports){\n  (function (global){\n  /*! Native Promise Only\n      v0.8.1 (c) Kyle Simpson\n      MIT License: http://getify.mit-license.org\n  */\n  \n  (function UMD(name,context,definition){\n    // special form of UMD for polyfilling across evironments\n    context[name] = context[name] || definition();\n    if (typeof module != \"undefined\" && module.exports) { module.exports = context[name]; }\n    else if (typeof define == \"function\" && define.amd) { define(function $AMD$(){ return context[name]; }); }\n  })(\"Promise\",typeof global != \"undefined\" ? global : this,function DEF(){\n    /*jshint validthis:true */\n    \"use strict\";\n  \n    var builtInProp, cycle, scheduling_queue,\n      ToString = Object.prototype.toString,\n      timer = (typeof setImmediate != \"undefined\") ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout\n    ;\n  \n    // dammit, IE8.\n    try {\n      Object.defineProperty({},\"x\",{});\n      builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n          value: val,\n          writable: true,\n          configurable: config !== false\n        });\n      };\n    }\n    catch (err) {\n      builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n      };\n    }\n  \n    // Note: using a queue instead of array for efficiency\n    scheduling_queue = (function Queue() {\n      var first, last, item;\n  \n      function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n      }\n  \n      return {\n        add: function add(fn,self) {\n          item = new Item(fn,self);\n          if (last) {\n            last.next = item;\n          }\n          else {\n            first = item;\n          }\n          last = item;\n          item = void 0;\n        },\n        drain: function drain() {\n          var f = first;\n          first = last = cycle = void 0;\n  \n          while (f) {\n            f.fn.call(f.self);\n            f = f.next;\n          }\n        }\n      };\n    })();\n  \n    function schedule(fn,self) {\n      scheduling_queue.add(fn,self);\n      if (!cycle) {\n        cycle = timer(scheduling_queue.drain);\n      }\n    }\n  \n    // promise duck typing\n    function isThenable(o) {\n      var _then, o_type = typeof o;\n  \n      if (o != null &&\n        (\n          o_type == \"object\" || o_type == \"function\"\n        )\n      ) {\n        _then = o.then;\n      }\n      return typeof _then == \"function\" ? _then : false;\n    }\n  \n    function notify() {\n      for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n          this,\n          (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n          this.chain[i]\n        );\n      }\n      this.chain.length = 0;\n    }\n  \n    // NOTE: This is a separate function to isolate\n    // the `try..catch` so that other code can be\n    // optimized better\n    function notifyIsolated(self,cb,chain) {\n      var ret, _then;\n      try {\n        if (cb === false) {\n          chain.reject(self.msg);\n        }\n        else {\n          if (cb === true) {\n            ret = self.msg;\n          }\n          else {\n            ret = cb.call(void 0,self.msg);\n          }\n  \n          if (ret === chain.promise) {\n            chain.reject(TypeError(\"Promise-chain cycle\"));\n          }\n          else if (_then = isThenable(ret)) {\n            _then.call(ret,chain.resolve,chain.reject);\n          }\n          else {\n            chain.resolve(ret);\n          }\n        }\n      }\n      catch (err) {\n        chain.reject(err);\n      }\n    }\n  \n    function resolve(msg) {\n      var _then, self = this;\n  \n      // already triggered?\n      if (self.triggered) { return; }\n  \n      self.triggered = true;\n  \n      // unwrap\n      if (self.def) {\n        self = self.def;\n      }\n  \n      try {\n        if (_then = isThenable(msg)) {\n          schedule(function(){\n            var def_wrapper = new MakeDefWrapper(self);\n            try {\n              _then.call(msg,\n                function $resolve$(){ resolve.apply(def_wrapper,arguments); },\n                function $reject$(){ reject.apply(def_wrapper,arguments); }\n              );\n            }\n            catch (err) {\n              reject.call(def_wrapper,err);\n            }\n          })\n        }\n        else {\n          self.msg = msg;\n          self.state = 1;\n          if (self.chain.length > 0) {\n            schedule(notify,self);\n          }\n        }\n      }\n      catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n      }\n    }\n  \n    function reject(msg) {\n      var self = this;\n  \n      // already triggered?\n      if (self.triggered) { return; }\n  \n      self.triggered = true;\n  \n      // unwrap\n      if (self.def) {\n        self = self.def;\n      }\n  \n      self.msg = msg;\n      self.state = 2;\n      if (self.chain.length > 0) {\n        schedule(notify,self);\n      }\n    }\n  \n    function iteratePromises(Constructor,arr,resolver,rejecter) {\n      for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n          Constructor.resolve(arr[idx])\n          .then(\n            function $resolver$(msg){\n              resolver(idx,msg);\n            },\n            rejecter\n          );\n        })(idx);\n      }\n    }\n  \n    function MakeDefWrapper(self) {\n      this.def = self;\n      this.triggered = false;\n    }\n  \n    function MakeDef(self) {\n      this.promise = self;\n      this.state = 0;\n      this.triggered = false;\n      this.chain = [];\n      this.msg = void 0;\n    }\n  \n    function Promise(executor) {\n      if (typeof executor != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n  \n      if (this.__NPO__ !== 0) {\n        throw TypeError(\"Not a promise\");\n      }\n  \n      // instance shadowing the inherited \"brand\"\n      // to signal an already \"initialized\" promise\n      this.__NPO__ = 1;\n  \n      var def = new MakeDef(this);\n  \n      this[\"then\"] = function then(success,failure) {\n        var o = {\n          success: typeof success == \"function\" ? success : true,\n          failure: typeof failure == \"function\" ? failure : false\n        };\n        // Note: `then(..)` itself can be borrowed to be used against\n        // a different promise constructor for making the chained promise,\n        // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n          if (typeof resolve != \"function\" || typeof reject != \"function\") {\n            throw TypeError(\"Not a function\");\n          }\n  \n          o.resolve = resolve;\n          o.reject = reject;\n        });\n        def.chain.push(o);\n  \n        if (def.state !== 0) {\n          schedule(notify,def);\n        }\n  \n        return o.promise;\n      };\n      this[\"catch\"] = function $catch$(failure) {\n        return this.then(void 0,failure);\n      };\n  \n      try {\n        executor.call(\n          void 0,\n          function publicResolve(msg){\n            resolve.call(def,msg);\n          },\n          function publicReject(msg) {\n            reject.call(def,msg);\n          }\n        );\n      }\n      catch (err) {\n        reject.call(def,err);\n      }\n    }\n  \n    var PromisePrototype = builtInProp({},\"constructor\",Promise,\n      /*configurable=*/false\n    );\n  \n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\n    Promise.prototype = PromisePrototype;\n  \n    // built-in \"brand\" to signal an \"uninitialized\" promise\n    builtInProp(PromisePrototype,\"__NPO__\",0,\n      /*configurable=*/false\n    );\n  \n    builtInProp(Promise,\"resolve\",function Promise$resolve(msg) {\n      var Constructor = this;\n  \n      // spec mandated checks\n      // note: best \"isPromise\" check that's practical for now\n      if (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n        return msg;\n      }\n  \n      return new Constructor(function executor(resolve,reject){\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n  \n        resolve(msg);\n      });\n    });\n  \n    builtInProp(Promise,\"reject\",function Promise$reject(msg) {\n      return new this(function executor(resolve,reject){\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n  \n        reject(msg);\n      });\n    });\n  \n    builtInProp(Promise,\"all\",function Promise$all(arr) {\n      var Constructor = this;\n  \n      // spec mandated checks\n      if (ToString.call(arr) != \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n      }\n      if (arr.length === 0) {\n        return Constructor.resolve([]);\n      }\n  \n      return new Constructor(function executor(resolve,reject){\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n  \n        var len = arr.length, msgs = Array(len), count = 0;\n  \n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n          msgs[idx] = msg;\n          if (++count === len) {\n            resolve(msgs);\n          }\n        },reject);\n      });\n    });\n  \n    builtInProp(Promise,\"race\",function Promise$race(arr) {\n      var Constructor = this;\n  \n      // spec mandated checks\n      if (ToString.call(arr) != \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n      }\n  \n      return new Constructor(function executor(resolve,reject){\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n  \n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n          resolve(msg);\n        },reject);\n      });\n    });\n  \n    return Promise;\n  });\n  \n  }).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n  \n  },{}],4:[function(require,module,exports){\n  (function (process){\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  \n  // resolves . and .. elements in a path array with directory names there\n  // must be no slashes, empty elements, or device names (c:\\) in the array\n  // (so also no leading and trailing slashes - it does not distinguish\n  // relative and absolute paths)\n  function normalizeArray(parts, allowAboveRoot) {\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = parts.length - 1; i >= 0; i--) {\n      var last = parts[i];\n      if (last === '.') {\n        parts.splice(i, 1);\n      } else if (last === '..') {\n        parts.splice(i, 1);\n        up++;\n      } else if (up) {\n        parts.splice(i, 1);\n        up--;\n      }\n    }\n  \n    // if the path is allowed to go above the root, restore leading ..s\n    if (allowAboveRoot) {\n      for (; up--; up) {\n        parts.unshift('..');\n      }\n    }\n  \n    return parts;\n  }\n  \n  // Split a filename into [root, dir, basename, ext], unix version\n  // 'root' is just a slash, or nothing.\n  var splitPathRe =\n      /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  var splitPath = function(filename) {\n    return splitPathRe.exec(filename).slice(1);\n  };\n  \n  // path.resolve([from ...], to)\n  // posix version\n  exports.resolve = function() {\n    var resolvedPath = '',\n        resolvedAbsolute = false;\n  \n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = (i >= 0) ? arguments[i] : process.cwd();\n  \n      // Skip empty and invalid entries\n      if (typeof path !== 'string') {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      } else if (!path) {\n        continue;\n      }\n  \n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charAt(0) === '/';\n    }\n  \n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n  \n    // Normalize the path\n    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n      return !!p;\n    }), !resolvedAbsolute).join('/');\n  \n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n  };\n  \n  // path.normalize(path)\n  // posix version\n  exports.normalize = function(path) {\n    var isAbsolute = exports.isAbsolute(path),\n        trailingSlash = substr(path, -1) === '/';\n  \n    // Normalize the path\n    path = normalizeArray(filter(path.split('/'), function(p) {\n      return !!p;\n    }), !isAbsolute).join('/');\n  \n    if (!path && !isAbsolute) {\n      path = '.';\n    }\n    if (path && trailingSlash) {\n      path += '/';\n    }\n  \n    return (isAbsolute ? '/' : '') + path;\n  };\n  \n  // posix version\n  exports.isAbsolute = function(path) {\n    return path.charAt(0) === '/';\n  };\n  \n  // posix version\n  exports.join = function() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return exports.normalize(filter(paths, function(p, index) {\n      if (typeof p !== 'string') {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      return p;\n    }).join('/'));\n  };\n  \n  \n  // path.relative(from, to)\n  // posix version\n  exports.relative = function(from, to) {\n    from = exports.resolve(from).substr(1);\n    to = exports.resolve(to).substr(1);\n  \n    function trim(arr) {\n      var start = 0;\n      for (; start < arr.length; start++) {\n        if (arr[start] !== '') break;\n      }\n  \n      var end = arr.length - 1;\n      for (; end >= 0; end--) {\n        if (arr[end] !== '') break;\n      }\n  \n      if (start > end) return [];\n      return arr.slice(start, end - start + 1);\n    }\n  \n    var fromParts = trim(from.split('/'));\n    var toParts = trim(to.split('/'));\n  \n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n  \n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n      outputParts.push('..');\n    }\n  \n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  \n    return outputParts.join('/');\n  };\n  \n  exports.sep = '/';\n  exports.delimiter = ':';\n  \n  exports.dirname = function(path) {\n    var result = splitPath(path),\n        root = result[0],\n        dir = result[1];\n  \n    if (!root && !dir) {\n      // No dirname whatsoever\n      return '.';\n    }\n  \n    if (dir) {\n      // It has a dirname, strip trailing slash\n      dir = dir.substr(0, dir.length - 1);\n    }\n  \n    return root + dir;\n  };\n  \n  \n  exports.basename = function(path, ext) {\n    var f = splitPath(path)[2];\n    // TODO: make this comparison case-insensitive on windows?\n    if (ext && f.substr(-1 * ext.length) === ext) {\n      f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n  };\n  \n  \n  exports.extname = function(path) {\n    return splitPath(path)[3];\n  };\n  \n  function filter (xs, f) {\n      if (xs.filter) return xs.filter(f);\n      var res = [];\n      for (var i = 0; i < xs.length; i++) {\n          if (f(xs[i], i, xs)) res.push(xs[i]);\n      }\n      return res;\n  }\n  \n  // String.prototype.substr - negative index don't work in IE8\n  var substr = 'ab'.substr(-1) === 'b'\n      ? function (str, start, len) { return str.substr(start, len) }\n      : function (str, start, len) {\n          if (start < 0) start = str.length + start;\n          return str.substr(start, len);\n      }\n  ;\n  \n  }).call(this,require('_process'))\n  \n  },{\"_process\":8}],5:[function(require,module,exports){\n  /*\n   * The MIT License (MIT)\n   *\n   * Copyright (c) 2015 Jeremy Whitlock\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n  \n  'use strict';\n  \n  /**\n   * Utility that provides a single API for loading the content of a path/URL.\n   *\n   * @module PathLoader\n   */\n  \n  var supportedLoaders = {\n    file: require('./lib/loaders/file'),\n    http: require('./lib/loaders/http'),\n    https: require('./lib/loaders/http')\n  };\n  var defaultLoader = typeof window === 'object' || typeof importScripts === 'function' ?\n        supportedLoaders.http :\n        supportedLoaders.file;\n  \n  // Load promises polyfill if necessary\n  /* istanbul ignore if */\n  if (typeof Promise === 'undefined') {\n    require('native-promise-only');\n  }\n  \n  function getScheme (location) {\n    if (typeof location !== 'undefined') {\n      location = location.indexOf('://') === -1 ? '' : location.split('://')[0];\n    }\n  \n    return location;\n  }\n  \n  /**\n   * Callback used to provide access to altering a remote request prior to the request being made.\n   *\n   * @typedef {function} PrepareRequestCallback\n   *\n   * @param {object} req - The Superagent request object\n   * @param {string} location - The location being retrieved\n   * @param {function} callback - First callback\n   *\n   * @alias module:PathLoader~PrepareRequestCallback\n   */\n  \n   /**\n    * Callback used to provide access to processing the raw response of the request being made. *(HTTP loader only)*\n    *\n    * @typedef {function} ProcessResponseCallback\n    *\n    * @param {object} res - The Superagent response object *(For non-HTTP loaders, this object will be like the Superagent\n    * object in that it will have a `text` property whose value is the raw string value being processed.  This was done\n    * for consistency.)*\n    * @param {function} callback - Error-first callback\n    *\n    * @returns {*} the result of processing the responsexs\n    *\n    * @alias module:PathLoader~ProcessResponseCallback\n    */\n  \n  function getLoader (location) {\n    var scheme = getScheme(location);\n    var loader = supportedLoaders[scheme];\n  \n    if (typeof loader === 'undefined') {\n      if (scheme === '') {\n        loader = defaultLoader;\n      } else {\n        throw new Error('Unsupported scheme: ' + scheme);\n      }\n    }\n  \n    return loader;\n  }\n  \n  /**\n   * Loads a document at the provided location and returns a JavaScript object representation.\n   *\n   * @param {object} location - The location to the document\n   * @param {object} [options] - The options\n   * @param {string} [options.encoding='utf-8'] - The encoding to use when loading the file *(File loader only)*\n   * @param {string} [options.method=get] - The HTTP method to use for the request *(HTTP loader only)*\n   * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare the request\n   * *(HTTP loader only)*\n   * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n   * response\n   *\n   * @returns {Promise} Always returns a promise even if there is a callback provided\n   *\n   * @example\n   * // Example using Promises\n   *\n   * PathLoader\n   *   .load('./package.json')\n   *   .then(JSON.parse)\n   *   .then(function (document) {\n   *     console.log(document.name + ' (' + document.version + '): ' + document.description);\n   *   }, function (err) {\n   *     console.error(err.stack);\n   *   });\n   *\n   * @example\n   * // Example using options.prepareRequest to provide authentication details for a remotely secure URL\n   *\n   * PathLoader\n   *   .load('https://api.github.com/repos/whitlockjc/path-loader', {\n   *     prepareRequest: function (req, callback) {\n   *       req.auth('my-username', 'my-password');\n   *       callback(undefined, req);\n   *     }\n   *   })\n   *   .then(JSON.parse)\n   *   .then(function (document) {\n   *     console.log(document.full_name + ': ' + document.description);\n   *   }, function (err) {\n   *     console.error(err.stack);\n   *   });\n   *\n   * @example\n   * // Example loading a YAML file\n   *\n   * PathLoader\n   *   .load('/Users/not-you/projects/path-loader/.travis.yml')\n   *   .then(YAML.safeLoad)\n   *   .then(function (document) {\n   *     console.log('path-loader uses the', document.language, 'language.');\n   *   }, function (err) {\n   *     console.error(err.stack);\n   *   });\n   *\n   * @example\n   * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)\n   *\n   * PathLoader\n   *   .load('/Users/not-you/projects/path-loader/.travis.yml', {\n   *     processContent: function (res, callback) {\n   *       callback(YAML.safeLoad(res.text));\n   *     }\n   *   })\n   *   .then(function (document) {\n   *     console.log('path-loader uses the', document.language, 'language.');\n   *   }, function (err) {\n   *     console.error(err.stack);\n   *   });\n   */\n  module.exports.load = function (location, options) {\n    var allTasks = Promise.resolve();\n  \n    // Default options to empty object\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n  \n    // Validate arguments\n    allTasks = allTasks.then(function () {\n      if (typeof location === 'undefined') {\n        throw new TypeError('location is required');\n      } else if (typeof location !== 'string') {\n        throw new TypeError('location must be a string');\n      }\n  \n      if (typeof options !== 'undefined') {\n        if (typeof options !== 'object') {\n          throw new TypeError('options must be an object');\n        } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {\n          throw new TypeError('options.processContent must be a function');\n        }\n      }\n    });\n  \n    // Load the document from the provided location and process it\n    allTasks = allTasks\n      .then(function () {\n        return new Promise(function (resolve, reject) {\n          var loader = getLoader(location);\n  \n          loader.load(location, options || {}, function (err, document) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(document);\n            }\n          });\n        });\n      })\n      .then(function (res) {\n        if (options.processContent) {\n          return new Promise(function (resolve, reject) {\n            // For consistency between file and http, always send an object with a 'text' property containing the raw\n            // string value being processed.\n            options.processContent(typeof res === 'object' ? res : {text: res}, function (err, processed) {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(processed);\n              }\n            });\n          });\n        } else {\n          // If there was no content processor, we will assume that for all objects that it is a Superagent response\n          // and will return its `text` property value.  Otherwise, we will return the raw response.\n          return typeof res === 'object' ? res.text : res;\n        }\n      });\n  \n    return allTasks;\n  };\n  \n  },{\"./lib/loaders/file\":6,\"./lib/loaders/http\":7,\"native-promise-only\":3}],6:[function(require,module,exports){\n  /*\n   * The MIT License (MIT)\n   *\n   * Copyright (c) 2015 Jeremy Whitlock\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n  \n  'use strict';\n  \n  var unsupportedError = new TypeError('The \\'file\\' scheme is not supported in the browser');\n  \n  /**\n   * The file loader is not supported in the browser.\n   *\n   * @throws {error} the file loader is not supported in the browser\n   */\n  module.exports.getBase = function () {\n    throw unsupportedError;\n  };\n  \n  /**\n   * The file loader is not supported in the browser.\n   */\n  module.exports.load = function () {\n    var fn = arguments[arguments.length - 1];\n  \n    if (typeof fn === 'function') {\n      fn(unsupportedError);\n    } else {\n      throw unsupportedError;\n    }\n  };\n  \n  },{}],7:[function(require,module,exports){\n  /* eslint-env node, browser */\n  \n  /*\n   * The MIT License (MIT)\n   *\n   * Copyright (c) 2015 Jeremy Whitlock\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n  \n  'use strict';\n  \n  var request = require('superagent');\n  \n  var supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];\n  \n  /**\n   * Loads a file from an http or https URL.\n   *\n   * @param {string} location - The document URL (If relative, location is relative to window.location.origin).\n   * @param {object} options - The loader options\n   * @param {string} [options.method=get] - The HTTP method to use for the request\n   * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request\n   * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n   * response\n   * @param {function} callback - The error-first callback\n   */\n  module.exports.load = function (location, options, callback) {\n    var realMethod = options.method ? options.method.toLowerCase() : 'get';\n    var err;\n    var realRequest;\n  \n    function makeRequest (err, req) {\n      if (err) {\n        callback(err);\n      } else {\n        // buffer() is only available in Node.js\n        if (typeof req.buffer === 'function') {\n          req.buffer(true);\n        }\n  \n        req\n          .end(function (err2, res) {\n            if (err2) {\n              callback(err2);\n            } else {\n              callback(undefined, res);\n            }\n          });\n      }\n    }\n  \n    if (typeof options.method !== 'undefined') {\n      if (typeof options.method !== 'string') {\n        err = new TypeError('options.method must be a string');\n      } else if (supportedHttpMethods.indexOf(options.method) === -1) {\n        err = new TypeError('options.method must be one of the following: ' +\n          supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' +\n          supportedHttpMethods[supportedHttpMethods.length - 1]);\n      }\n    } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {\n      err = new TypeError('options.prepareRequest must be a function');\n    }\n  \n    if (!err) {\n      realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);\n  \n      if (options.prepareRequest) {\n        try {\n          options.prepareRequest(realRequest, makeRequest);\n        } catch (err2) {\n          callback(err2);\n        }\n      } else {\n        makeRequest(undefined, realRequest);\n      }\n    } else {\n      callback(err);\n    }\n  };\n  \n  },{\"superagent\":14}],8:[function(require,module,exports){\n  // shim for using process in browser\n  \n  var process = module.exports = {};\n  var queue = [];\n  var draining = false;\n  var currentQueue;\n  var queueIndex = -1;\n  \n  function cleanUpNextTick() {\n      draining = false;\n      if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n      } else {\n          queueIndex = -1;\n      }\n      if (queue.length) {\n          drainQueue();\n      }\n  }\n  \n  function drainQueue() {\n      if (draining) {\n          return;\n      }\n      var timeout = setTimeout(cleanUpNextTick);\n      draining = true;\n  \n      var len = queue.length;\n      while(len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n              if (currentQueue) {\n                  currentQueue[queueIndex].run();\n              }\n          }\n          queueIndex = -1;\n          len = queue.length;\n      }\n      currentQueue = null;\n      draining = false;\n      clearTimeout(timeout);\n  }\n  \n  process.nextTick = function (fun) {\n      var args = new Array(arguments.length - 1);\n      if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n              args[i - 1] = arguments[i];\n          }\n      }\n      queue.push(new Item(fun, args));\n      if (queue.length === 1 && !draining) {\n          setTimeout(drainQueue, 0);\n      }\n  };\n  \n  // v8 likes predictible objects\n  function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n  }\n  Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n  };\n  process.title = 'browser';\n  process.browser = true;\n  process.env = {};\n  process.argv = [];\n  process.version = ''; // empty string to avoid regexp issues\n  process.versions = {};\n  \n  function noop() {}\n  \n  process.on = noop;\n  process.addListener = noop;\n  process.once = noop;\n  process.off = noop;\n  process.removeListener = noop;\n  process.removeAllListeners = noop;\n  process.emit = noop;\n  \n  process.binding = function (name) {\n      throw new Error('process.binding is not supported');\n  };\n  \n  process.cwd = function () { return '/' };\n  process.chdir = function (dir) {\n      throw new Error('process.chdir is not supported');\n  };\n  process.umask = function() { return 0; };\n  \n  },{}],9:[function(require,module,exports){\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  \n  'use strict';\n  \n  // If obj.hasOwnProperty has been overridden, then calling\n  // obj.hasOwnProperty(prop) will break.\n  // See: https://github.com/joyent/node/issues/1707\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  \n  module.exports = function(qs, sep, eq, options) {\n    sep = sep || '&';\n    eq = eq || '=';\n    var obj = {};\n  \n    if (typeof qs !== 'string' || qs.length === 0) {\n      return obj;\n    }\n  \n    var regexp = /\\+/g;\n    qs = qs.split(sep);\n  \n    var maxKeys = 1000;\n    if (options && typeof options.maxKeys === 'number') {\n      maxKeys = options.maxKeys;\n    }\n  \n    var len = qs.length;\n    // maxKeys <= 0 means that we should not limit keys count\n    if (maxKeys > 0 && len > maxKeys) {\n      len = maxKeys;\n    }\n  \n    for (var i = 0; i < len; ++i) {\n      var x = qs[i].replace(regexp, '%20'),\n          idx = x.indexOf(eq),\n          kstr, vstr, k, v;\n  \n      if (idx >= 0) {\n        kstr = x.substr(0, idx);\n        vstr = x.substr(idx + 1);\n      } else {\n        kstr = x;\n        vstr = '';\n      }\n  \n      k = decodeURIComponent(kstr);\n      v = decodeURIComponent(vstr);\n  \n      if (!hasOwnProperty(obj, k)) {\n        obj[k] = v;\n      } else if (isArray(obj[k])) {\n        obj[k].push(v);\n      } else {\n        obj[k] = [obj[k], v];\n      }\n    }\n  \n    return obj;\n  };\n  \n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n  \n  },{}],10:[function(require,module,exports){\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  \n  'use strict';\n  \n  var stringifyPrimitive = function(v) {\n    switch (typeof v) {\n      case 'string':\n        return v;\n  \n      case 'boolean':\n        return v ? 'true' : 'false';\n  \n      case 'number':\n        return isFinite(v) ? v : '';\n  \n      default:\n        return '';\n    }\n  };\n  \n  module.exports = function(obj, sep, eq, name) {\n    sep = sep || '&';\n    eq = eq || '=';\n    if (obj === null) {\n      obj = undefined;\n    }\n  \n    if (typeof obj === 'object') {\n      return map(objectKeys(obj), function(k) {\n        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n        if (isArray(obj[k])) {\n          return map(obj[k], function(v) {\n            return ks + encodeURIComponent(stringifyPrimitive(v));\n          }).join(sep);\n        } else {\n          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n        }\n      }).join(sep);\n  \n    }\n  \n    if (!name) return '';\n    return encodeURIComponent(stringifyPrimitive(name)) + eq +\n           encodeURIComponent(stringifyPrimitive(obj));\n  };\n  \n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n  \n  function map (xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n      res.push(f(xs[i], i));\n    }\n    return res;\n  }\n  \n  var objectKeys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n  };\n  \n  },{}],11:[function(require,module,exports){\n  'use strict';\n  \n  exports.decode = exports.parse = require('./decode');\n  exports.encode = exports.stringify = require('./encode');\n  \n  },{\"./decode\":9,\"./encode\":10}],12:[function(require,module,exports){\n  \n  /**\n   * Reduce `arr` with `fn`.\n   *\n   * @param {Array} arr\n   * @param {Function} fn\n   * @param {Mixed} initial\n   *\n   * TODO: combatible error handling?\n   */\n  \n  module.exports = function(arr, fn, initial){  \n    var idx = 0;\n    var len = arr.length;\n    var curr = arguments.length == 3\n      ? initial\n      : arr[idx++];\n  \n    while (idx < len) {\n      curr = fn.call(null, curr, arr[idx], ++idx, arr);\n    }\n    \n    return curr;\n  };\n  },{}],13:[function(require,module,exports){\n  'use strict';\n  module.exports = function (str) {\n    var isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n    var hasNonAscii = /[^\\x00-\\x80]+/.test(str);\n  \n    if (isExtendedLengthPath || hasNonAscii) {\n      return str;\n    }\n  \n    return str.replace(/\\\\/g, '/');\n  };\n  \n  },{}],14:[function(require,module,exports){\n  /**\n   * Module dependencies.\n   */\n  \n  var Emitter = require('emitter');\n  var reduce = require('reduce');\n  var requestBase = require('./request-base');\n  var isObject = require('./is-object');\n  \n  /**\n   * Root reference for iframes.\n   */\n  \n  var root;\n  if (typeof window !== 'undefined') { // Browser window\n    root = window;\n  } else if (typeof self !== 'undefined') { // Web Worker\n    root = self;\n  } else { // Other environments\n    root = this;\n  }\n  \n  /**\n   * Noop.\n   */\n  \n  function noop(){};\n  \n  /**\n   * Check if `obj` is a host object,\n   * we don't want to serialize these :)\n   *\n   * TODO: future proof, move to compoent land\n   *\n   * @param {Object} obj\n   * @return {Boolean}\n   * @api private\n   */\n  \n  function isHost(obj) {\n    var str = {}.toString.call(obj);\n  \n    switch (str) {\n      case '[object File]':\n      case '[object Blob]':\n      case '[object FormData]':\n        return true;\n      default:\n        return false;\n    }\n  }\n  \n  /**\n   * Expose `request`.\n   */\n  \n  var request = module.exports = require('./request').bind(null, Request);\n  \n  /**\n   * Determine XHR.\n   */\n  \n  request.getXHR = function () {\n    if (root.XMLHttpRequest\n        && (!root.location || 'file:' != root.location.protocol\n            || !root.ActiveXObject)) {\n      return new XMLHttpRequest;\n    } else {\n      try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n      try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n      try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n      try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n    }\n    return false;\n  };\n  \n  /**\n   * Removes leading and trailing whitespace, added to support IE.\n   *\n   * @param {String} s\n   * @return {String}\n   * @api private\n   */\n  \n  var trim = ''.trim\n    ? function(s) { return s.trim(); }\n    : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n  \n  /**\n   * Serialize the given `obj`.\n   *\n   * @param {Object} obj\n   * @return {String}\n   * @api private\n   */\n  \n  function serialize(obj) {\n    if (!isObject(obj)) return obj;\n    var pairs = [];\n    for (var key in obj) {\n      if (null != obj[key]) {\n        pushEncodedKeyValuePair(pairs, key, obj[key]);\n          }\n        }\n    return pairs.join('&');\n  }\n  \n  /**\n   * Helps 'serialize' with serializing arrays.\n   * Mutates the pairs array.\n   *\n   * @param {Array} pairs\n   * @param {String} key\n   * @param {Mixed} val\n   */\n  \n  function pushEncodedKeyValuePair(pairs, key, val) {\n    if (Array.isArray(val)) {\n      return val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    }\n    pairs.push(encodeURIComponent(key)\n      + '=' + encodeURIComponent(val));\n  }\n  \n  /**\n   * Expose serialization method.\n   */\n  \n   request.serializeObject = serialize;\n  \n   /**\n    * Parse the given x-www-form-urlencoded `str`.\n    *\n    * @param {String} str\n    * @return {Object}\n    * @api private\n    */\n  \n  function parseString(str) {\n    var obj = {};\n    var pairs = str.split('&');\n    var parts;\n    var pair;\n  \n    for (var i = 0, len = pairs.length; i < len; ++i) {\n      pair = pairs[i];\n      parts = pair.split('=');\n      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n    }\n  \n    return obj;\n  }\n  \n  /**\n   * Expose parser.\n   */\n  \n  request.parseString = parseString;\n  \n  /**\n   * Default MIME type map.\n   *\n   *     superagent.types.xml = 'application/xml';\n   *\n   */\n  \n  request.types = {\n    html: 'text/html',\n    json: 'application/json',\n    xml: 'application/xml',\n    urlencoded: 'application/x-www-form-urlencoded',\n    'form': 'application/x-www-form-urlencoded',\n    'form-data': 'application/x-www-form-urlencoded'\n  };\n  \n  /**\n   * Default serialization map.\n   *\n   *     superagent.serialize['application/xml'] = function(obj){\n   *       return 'generated xml here';\n   *     };\n   *\n   */\n  \n   request.serialize = {\n     'application/x-www-form-urlencoded': serialize,\n     'application/json': JSON.stringify\n   };\n  \n   /**\n    * Default parsers.\n    *\n    *     superagent.parse['application/xml'] = function(str){\n    *       return { object parsed from str };\n    *     };\n    *\n    */\n  \n  request.parse = {\n    'application/x-www-form-urlencoded': parseString,\n    'application/json': JSON.parse\n  };\n  \n  /**\n   * Parse the given header `str` into\n   * an object containing the mapped fields.\n   *\n   * @param {String} str\n   * @return {Object}\n   * @api private\n   */\n  \n  function parseHeader(str) {\n    var lines = str.split(/\\r?\\n/);\n    var fields = {};\n    var index;\n    var line;\n    var field;\n    var val;\n  \n    lines.pop(); // trailing CRLF\n  \n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i];\n      index = line.indexOf(':');\n      field = line.slice(0, index).toLowerCase();\n      val = trim(line.slice(index + 1));\n      fields[field] = val;\n    }\n  \n    return fields;\n  }\n  \n  /**\n   * Check if `mime` is json or has +json structured syntax suffix.\n   *\n   * @param {String} mime\n   * @return {Boolean}\n   * @api private\n   */\n  \n  function isJSON(mime) {\n    return /[\\/+]json\\b/.test(mime);\n  }\n  \n  /**\n   * Return the mime type for the given `str`.\n   *\n   * @param {String} str\n   * @return {String}\n   * @api private\n   */\n  \n  function type(str){\n    return str.split(/ *; */).shift();\n  };\n  \n  /**\n   * Return header field parameters.\n   *\n   * @param {String} str\n   * @return {Object}\n   * @api private\n   */\n  \n  function params(str){\n    return reduce(str.split(/ *; */), function(obj, str){\n      var parts = str.split(/ *= */)\n        , key = parts.shift()\n        , val = parts.shift();\n  \n      if (key && val) obj[key] = val;\n      return obj;\n    }, {});\n  };\n  \n  /**\n   * Initialize a new `Response` with the given `xhr`.\n   *\n   *  - set flags (.ok, .error, etc)\n   *  - parse header\n   *\n   * Examples:\n   *\n   *  Aliasing `superagent` as `request` is nice:\n   *\n   *      request = superagent;\n   *\n   *  We can use the promise-like API, or pass callbacks:\n   *\n   *      request.get('/').end(function(res){});\n   *      request.get('/', function(res){});\n   *\n   *  Sending data can be chained:\n   *\n   *      request\n   *        .post('/user')\n   *        .send({ name: 'tj' })\n   *        .end(function(res){});\n   *\n   *  Or passed to `.send()`:\n   *\n   *      request\n   *        .post('/user')\n   *        .send({ name: 'tj' }, function(res){});\n   *\n   *  Or passed to `.post()`:\n   *\n   *      request\n   *        .post('/user', { name: 'tj' })\n   *        .end(function(res){});\n   *\n   * Or further reduced to a single call for simple cases:\n   *\n   *      request\n   *        .post('/user', { name: 'tj' }, function(res){});\n   *\n   * @param {XMLHTTPRequest} xhr\n   * @param {Object} options\n   * @api private\n   */\n  \n  function Response(req, options) {\n    options = options || {};\n    this.req = req;\n    this.xhr = this.req.xhr;\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n    this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n       ? this.xhr.responseText\n       : null;\n    this.statusText = this.req.xhr.statusText;\n    this.setStatusProperties(this.xhr.status);\n    this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n    // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n    // getResponseHeader still works. so we get content-type even if getting\n    // other headers fails.\n    this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n    this.setHeaderProperties(this.header);\n    this.body = this.req.method != 'HEAD'\n      ? this.parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n  \n  /**\n   * Get case-insensitive `field` value.\n   *\n   * @param {String} field\n   * @return {String}\n   * @api public\n   */\n  \n  Response.prototype.get = function(field){\n    return this.header[field.toLowerCase()];\n  };\n  \n  /**\n   * Set header related properties:\n   *\n   *   - `.type` the content type without params\n   *\n   * A response of \"Content-Type: text/plain; charset=utf-8\"\n   * will provide you with a `.type` of \"text/plain\".\n   *\n   * @param {Object} header\n   * @api private\n   */\n  \n  Response.prototype.setHeaderProperties = function(header){\n    // content-type\n    var ct = this.header['content-type'] || '';\n    this.type = type(ct);\n  \n    // params\n    var obj = params(ct);\n    for (var key in obj) this[key] = obj[key];\n  };\n  \n  /**\n   * Parse the given body `str`.\n   *\n   * Used for auto-parsing of bodies. Parsers\n   * are defined on the `superagent.parse` object.\n   *\n   * @param {String} str\n   * @return {Mixed}\n   * @api private\n   */\n  \n  Response.prototype.parseBody = function(str){\n    var parse = request.parse[this.type];\n    if (!parse && isJSON(this.type)) {\n      parse = request.parse['application/json'];\n    }\n    return parse && str && (str.length || str instanceof Object)\n      ? parse(str)\n      : null;\n  };\n  \n  /**\n   * Set flags such as `.ok` based on `status`.\n   *\n   * For example a 2xx response will give you a `.ok` of __true__\n   * whereas 5xx will be __false__ and `.error` will be __true__. The\n   * `.clientError` and `.serverError` are also available to be more\n   * specific, and `.statusType` is the class of error ranging from 1..5\n   * sometimes useful for mapping respond colors etc.\n   *\n   * \"sugar\" properties are also defined for common cases. Currently providing:\n   *\n   *   - .noContent\n   *   - .badRequest\n   *   - .unauthorized\n   *   - .notAcceptable\n   *   - .notFound\n   *\n   * @param {Number} status\n   * @api private\n   */\n  \n  Response.prototype.setStatusProperties = function(status){\n    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    if (status === 1223) {\n      status = 204;\n    }\n  \n    var type = status / 100 | 0;\n  \n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n  \n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n      ? this.toError()\n      : false;\n  \n    // sugar\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.notFound = 404 == status;\n    this.forbidden = 403 == status;\n  };\n  \n  /**\n   * Return an `Error` representative of this response.\n   *\n   * @return {Error}\n   * @api public\n   */\n  \n  Response.prototype.toError = function(){\n    var req = this.req;\n    var method = req.method;\n    var url = req.url;\n  \n    var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n    var err = new Error(msg);\n    err.status = this.status;\n    err.method = method;\n    err.url = url;\n  \n    return err;\n  };\n  \n  /**\n   * Expose `Response`.\n   */\n  \n  request.Response = Response;\n  \n  /**\n   * Initialize a new `Request` with the given `method` and `url`.\n   *\n   * @param {String} method\n   * @param {String} url\n   * @api public\n   */\n  \n  function Request(method, url) {\n    var self = this;\n    this._query = this._query || [];\n    this.method = method;\n    this.url = url;\n    this.header = {}; // preserves header name case\n    this._header = {}; // coerces header names to lowercase\n    this.on('end', function(){\n      var err = null;\n      var res = null;\n  \n      try {\n        res = new Response(self);\n      } catch(e) {\n        err = new Error('Parser is unable to parse the response');\n        err.parse = true;\n        err.original = e;\n        // issue #675: return the raw response if the response parsing fails\n        err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n        // issue #876: return the http status code if the response parsing fails\n        err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n        return self.callback(err);\n      }\n  \n      self.emit('response', res);\n  \n      if (err) {\n        return self.callback(err, res);\n      }\n  \n      if (res.status >= 200 && res.status < 300) {\n        return self.callback(err, res);\n      }\n  \n      var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n      new_err.original = err;\n      new_err.response = res;\n      new_err.status = res.status;\n  \n      self.callback(new_err, res);\n    });\n  }\n  \n  /**\n   * Mixin `Emitter` and `requestBase`.\n   */\n  \n  Emitter(Request.prototype);\n  for (var key in requestBase) {\n    Request.prototype[key] = requestBase[key];\n  }\n  \n  /**\n   * Abort the request, and clear potential timeout.\n   *\n   * @return {Request}\n   * @api public\n   */\n  \n  Request.prototype.abort = function(){\n    if (this.aborted) return;\n    this.aborted = true;\n    this.xhr.abort();\n    this.clearTimeout();\n    this.emit('abort');\n    return this;\n  };\n  \n  /**\n   * Set Content-Type to `type`, mapping values from `request.types`.\n   *\n   * Examples:\n   *\n   *      superagent.types.xml = 'application/xml';\n   *\n   *      request.post('/')\n   *        .type('xml')\n   *        .send(xmlstring)\n   *        .end(callback);\n   *\n   *      request.post('/')\n   *        .type('application/xml')\n   *        .send(xmlstring)\n   *        .end(callback);\n   *\n   * @param {String} type\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.type = function(type){\n    this.set('Content-Type', request.types[type] || type);\n    return this;\n  };\n  \n  /**\n   * Set responseType to `val`. Presently valid responseTypes are 'blob' and \n   * 'arraybuffer'.\n   *\n   * Examples:\n   *\n   *      req.get('/')\n   *        .responseType('blob')\n   *        .end(callback);\n   *\n   * @param {String} val\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.responseType = function(val){\n    this._responseType = val;\n    return this;\n  };\n  \n  /**\n   * Set Accept to `type`, mapping values from `request.types`.\n   *\n   * Examples:\n   *\n   *      superagent.types.json = 'application/json';\n   *\n   *      request.get('/agent')\n   *        .accept('json')\n   *        .end(callback);\n   *\n   *      request.get('/agent')\n   *        .accept('application/json')\n   *        .end(callback);\n   *\n   * @param {String} accept\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.accept = function(type){\n    this.set('Accept', request.types[type] || type);\n    return this;\n  };\n  \n  /**\n   * Set Authorization field value with `user` and `pass`.\n   *\n   * @param {String} user\n   * @param {String} pass\n   * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.auth = function(user, pass, options){\n    if (!options) {\n      options = {\n        type: 'basic'\n      }\n    }\n  \n    switch (options.type) {\n      case 'basic':\n        var str = btoa(user + ':' + pass);\n        this.set('Authorization', 'Basic ' + str);\n      break;\n  \n      case 'auto':\n        this.username = user;\n        this.password = pass;\n      break;\n    }\n    return this;\n  };\n  \n  /**\n  * Add query-string `val`.\n  *\n  * Examples:\n  *\n  *   request.get('/shoes')\n  *     .query('size=10')\n  *     .query({ color: 'blue' })\n  *\n  * @param {Object|String} val\n  * @return {Request} for chaining\n  * @api public\n  */\n  \n  Request.prototype.query = function(val){\n    if ('string' != typeof val) val = serialize(val);\n    if (val) this._query.push(val);\n    return this;\n  };\n  \n  /**\n   * Queue the given `file` as an attachment to the specified `field`,\n   * with optional `filename`.\n   *\n   * ``` js\n   * request.post('/upload')\n   *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n   *   .end(callback);\n   * ```\n   *\n   * @param {String} field\n   * @param {Blob|File} file\n   * @param {String} filename\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.attach = function(field, file, filename){\n    this._getFormData().append(field, file, filename || file.name);\n    return this;\n  };\n  \n  Request.prototype._getFormData = function(){\n    if (!this._formData) {\n      this._formData = new root.FormData();\n    }\n    return this._formData;\n  };\n  \n  /**\n   * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n   * an object is given.\n   *\n   * Examples:\n   *\n   *       // manual json\n   *       request.post('/user')\n   *         .type('json')\n   *         .send('{\"name\":\"tj\"}')\n   *         .end(callback)\n   *\n   *       // auto json\n   *       request.post('/user')\n   *         .send({ name: 'tj' })\n   *         .end(callback)\n   *\n   *       // manual x-www-form-urlencoded\n   *       request.post('/user')\n   *         .type('form')\n   *         .send('name=tj')\n   *         .end(callback)\n   *\n   *       // auto x-www-form-urlencoded\n   *       request.post('/user')\n   *         .type('form')\n   *         .send({ name: 'tj' })\n   *         .end(callback)\n   *\n   *       // defaults to x-www-form-urlencoded\n    *      request.post('/user')\n    *        .send('name=tobi')\n    *        .send('species=ferret')\n    *        .end(callback)\n   *\n   * @param {String|Object} data\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.send = function(data){\n    var obj = isObject(data);\n    var type = this._header['content-type'];\n  \n    // merge\n    if (obj && isObject(this._data)) {\n      for (var key in data) {\n        this._data[key] = data[key];\n      }\n    } else if ('string' == typeof data) {\n      if (!type) this.type('form');\n      type = this._header['content-type'];\n      if ('application/x-www-form-urlencoded' == type) {\n        this._data = this._data\n          ? this._data + '&' + data\n          : data;\n      } else {\n        this._data = (this._data || '') + data;\n      }\n    } else {\n      this._data = data;\n    }\n  \n    if (!obj || isHost(data)) return this;\n    if (!type) this.type('json');\n    return this;\n  };\n  \n  /**\n   * @deprecated\n   */\n  Response.prototype.parse = function serialize(fn){\n    if (root.console) {\n      console.warn(\"Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0\");\n    }\n    this.serialize(fn);\n    return this;\n  };\n  \n  Response.prototype.serialize = function serialize(fn){\n    this._parser = fn;\n    return this;\n  };\n  \n  /**\n   * Invoke the callback with `err` and `res`\n   * and handle arity check.\n   *\n   * @param {Error} err\n   * @param {Response} res\n   * @api private\n   */\n  \n  Request.prototype.callback = function(err, res){\n    var fn = this._callback;\n    this.clearTimeout();\n    fn(err, res);\n  };\n  \n  /**\n   * Invoke callback with x-domain error.\n   *\n   * @api private\n   */\n  \n  Request.prototype.crossDomainError = function(){\n    var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n    err.crossDomain = true;\n  \n    err.status = this.status;\n    err.method = this.method;\n    err.url = this.url;\n  \n    this.callback(err);\n  };\n  \n  /**\n   * Invoke callback with timeout error.\n   *\n   * @api private\n   */\n  \n  Request.prototype.timeoutError = function(){\n    var timeout = this._timeout;\n    var err = new Error('timeout of ' + timeout + 'ms exceeded');\n    err.timeout = timeout;\n    this.callback(err);\n  };\n  \n  /**\n   * Enable transmission of cookies with x-domain requests.\n   *\n   * Note that for this to work the origin must not be\n   * using \"Access-Control-Allow-Origin\" with a wildcard,\n   * and also must set \"Access-Control-Allow-Credentials\"\n   * to \"true\".\n   *\n   * @api public\n   */\n  \n  Request.prototype.withCredentials = function(){\n    this._withCredentials = true;\n    return this;\n  };\n  \n  /**\n   * Initiate request, invoking callback `fn(res)`\n   * with an instanceof `Response`.\n   *\n   * @param {Function} fn\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  Request.prototype.end = function(fn){\n    var self = this;\n    var xhr = this.xhr = request.getXHR();\n    var query = this._query.join('&');\n    var timeout = this._timeout;\n    var data = this._formData || this._data;\n  \n    // store callback\n    this._callback = fn || noop;\n  \n    // state change\n    xhr.onreadystatechange = function(){\n      if (4 != xhr.readyState) return;\n  \n      // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n      // result in the error \"Could not complete the operation due to error c00c023f\"\n      var status;\n      try { status = xhr.status } catch(e) { status = 0; }\n  \n      if (0 == status) {\n        if (self.timedout) return self.timeoutError();\n        if (self.aborted) return;\n        return self.crossDomainError();\n      }\n      self.emit('end');\n    };\n  \n    // progress\n    var handleProgress = function(e){\n      if (e.total > 0) {\n        e.percent = e.loaded / e.total * 100;\n      }\n      e.direction = 'download';\n      self.emit('progress', e);\n    };\n    if (this.hasListeners('progress')) {\n      xhr.onprogress = handleProgress;\n    }\n    try {\n      if (xhr.upload && this.hasListeners('progress')) {\n        xhr.upload.onprogress = handleProgress;\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  \n    // timeout\n    if (timeout && !this._timer) {\n      this._timer = setTimeout(function(){\n        self.timedout = true;\n        self.abort();\n      }, timeout);\n    }\n  \n    // querystring\n    if (query) {\n      query = request.serializeObject(query);\n      this.url += ~this.url.indexOf('?')\n        ? '&' + query\n        : '?' + query;\n    }\n  \n    // initiate request\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  \n    // CORS\n    if (this._withCredentials) xhr.withCredentials = true;\n  \n    // body\n    if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n      // serialize stuff\n      var contentType = this._header['content-type'];\n      var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];\n      if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n      if (serialize) data = serialize(data);\n    }\n  \n    // set header fields\n    for (var field in this.header) {\n      if (null == this.header[field]) continue;\n      xhr.setRequestHeader(field, this.header[field]);\n    }\n  \n    if (this._responseType) {\n      xhr.responseType = this._responseType;\n    }\n  \n    // send stuff\n    this.emit('request', this);\n  \n    // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n    // We need null here if data is undefined\n    xhr.send(typeof data !== 'undefined' ? data : null);\n    return this;\n  };\n  \n  \n  /**\n   * Expose `Request`.\n   */\n  \n  request.Request = Request;\n  \n  /**\n   * GET `url` with optional callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Mixed|Function} data or fn\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  request.get = function(url, data, fn){\n    var req = request('GET', url);\n    if ('function' == typeof data) fn = data, data = null;\n    if (data) req.query(data);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  /**\n   * HEAD `url` with optional callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Mixed|Function} data or fn\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  request.head = function(url, data, fn){\n    var req = request('HEAD', url);\n    if ('function' == typeof data) fn = data, data = null;\n    if (data) req.send(data);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  /**\n   * DELETE `url` with optional callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  function del(url, fn){\n    var req = request('DELETE', url);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  request['del'] = del;\n  request['delete'] = del;\n  \n  /**\n   * PATCH `url` with optional `data` and callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Mixed} data\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  request.patch = function(url, data, fn){\n    var req = request('PATCH', url);\n    if ('function' == typeof data) fn = data, data = null;\n    if (data) req.send(data);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  /**\n   * POST `url` with optional `data` and callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Mixed} data\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  request.post = function(url, data, fn){\n    var req = request('POST', url);\n    if ('function' == typeof data) fn = data, data = null;\n    if (data) req.send(data);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  /**\n   * PUT `url` with optional `data` and callback `fn(res)`.\n   *\n   * @param {String} url\n   * @param {Mixed|Function} data or fn\n   * @param {Function} fn\n   * @return {Request}\n   * @api public\n   */\n  \n  request.put = function(url, data, fn){\n    var req = request('PUT', url);\n    if ('function' == typeof data) fn = data, data = null;\n    if (data) req.send(data);\n    if (fn) req.end(fn);\n    return req;\n  };\n  \n  },{\"./is-object\":15,\"./request\":17,\"./request-base\":16,\"emitter\":2,\"reduce\":12}],15:[function(require,module,exports){\n  /**\n   * Check if `obj` is an object.\n   *\n   * @param {Object} obj\n   * @return {Boolean}\n   * @api private\n   */\n  \n  function isObject(obj) {\n    return null != obj && 'object' == typeof obj;\n  }\n  \n  module.exports = isObject;\n  \n  },{}],16:[function(require,module,exports){\n  /**\n   * Module of mixed-in functions shared between node and client code\n   */\n  var isObject = require('./is-object');\n  \n  /**\n   * Clear previous timeout.\n   *\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  exports.clearTimeout = function _clearTimeout(){\n    this._timeout = 0;\n    clearTimeout(this._timer);\n    return this;\n  };\n  \n  /**\n   * Force given parser\n   *\n   * Sets the body parser no matter type.\n   *\n   * @param {Function}\n   * @api public\n   */\n  \n  exports.parse = function parse(fn){\n    this._parser = fn;\n    return this;\n  };\n  \n  /**\n   * Set timeout to `ms`.\n   *\n   * @param {Number} ms\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  exports.timeout = function timeout(ms){\n    this._timeout = ms;\n    return this;\n  };\n  \n  /**\n   * Faux promise support\n   *\n   * @param {Function} fulfill\n   * @param {Function} reject\n   * @return {Request}\n   */\n  \n  exports.then = function then(fulfill, reject) {\n    return this.end(function(err, res) {\n      err ? reject(err) : fulfill(res);\n    });\n  }\n  \n  /**\n   * Allow for extension\n   */\n  \n  exports.use = function use(fn) {\n    fn(this);\n    return this;\n  }\n  \n  \n  /**\n   * Get request header `field`.\n   * Case-insensitive.\n   *\n   * @param {String} field\n   * @return {String}\n   * @api public\n   */\n  \n  exports.get = function(field){\n    return this._header[field.toLowerCase()];\n  };\n  \n  /**\n   * Get case-insensitive header `field` value.\n   * This is a deprecated internal API. Use `.get(field)` instead.\n   *\n   * (getHeader is no longer used internally by the superagent code base)\n   *\n   * @param {String} field\n   * @return {String}\n   * @api private\n   * @deprecated\n   */\n  \n  exports.getHeader = exports.get;\n  \n  /**\n   * Set header `field` to `val`, or multiple fields with one object.\n   * Case-insensitive.\n   *\n   * Examples:\n   *\n   *      req.get('/')\n   *        .set('Accept', 'application/json')\n   *        .set('X-API-Key', 'foobar')\n   *        .end(callback);\n   *\n   *      req.get('/')\n   *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n   *        .end(callback);\n   *\n   * @param {String|Object} field\n   * @param {String} val\n   * @return {Request} for chaining\n   * @api public\n   */\n  \n  exports.set = function(field, val){\n    if (isObject(field)) {\n      for (var key in field) {\n        this.set(key, field[key]);\n      }\n      return this;\n    }\n    this._header[field.toLowerCase()] = val;\n    this.header[field] = val;\n    return this;\n  };\n  \n  /**\n   * Remove header `field`.\n   * Case-insensitive.\n   *\n   * Example:\n   *\n   *      req.get('/')\n   *        .unset('User-Agent')\n   *        .end(callback);\n   *\n   * @param {String} field\n   */\n  exports.unset = function(field){\n    delete this._header[field.toLowerCase()];\n    delete this.header[field];\n    return this;\n  };\n  \n  /**\n   * Write the field `name` and `val` for \"multipart/form-data\"\n   * request bodies.\n   *\n   * ``` js\n   * request.post('/upload')\n   *   .field('foo', 'bar')\n   *   .end(callback);\n   * ```\n   *\n   * @param {String} name\n   * @param {String|Blob|File|Buffer|fs.ReadStream} val\n   * @return {Request} for chaining\n   * @api public\n   */\n  exports.field = function(name, val) {\n    this._getFormData().append(name, val);\n    return this;\n  };\n  \n  },{\"./is-object\":15}],17:[function(require,module,exports){\n  // The node and browser modules expose versions of this with the\n  // appropriate constructor function bound as first argument\n  /**\n   * Issue a request:\n   *\n   * Examples:\n   *\n   *    request('GET', '/users').end(callback)\n   *    request('/users').end(callback)\n   *    request('/users', callback)\n   *\n   * @param {String} method\n   * @param {String|Function} url or callback\n   * @return {Request}\n   * @api public\n   */\n  \n  function request(RequestConstructor, method, url) {\n    // callback\n    if ('function' == typeof url) {\n      return new RequestConstructor('GET', method).end(url);\n    }\n  \n    // url first\n    if (2 == arguments.length) {\n      return new RequestConstructor('GET', method);\n    }\n  \n    return new RequestConstructor(method, url);\n  }\n  \n  module.exports = request;\n  \n  },{}],18:[function(require,module,exports){\n  /*! https://mths.be/punycode v1.3.2 by @mathias, modified for URI.js */\n  \n  var punycode = (function () {\n  \n    /**\n     * The `punycode` object.\n     * @name punycode\n     * @type Object\n     */\n    var punycode,\n  \n    /** Highest positive signed 32-bit float value */\n    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n  \n    /** Bootstring parameters */\n    base = 36,\n    tMin = 1,\n    tMax = 26,\n    skew = 38,\n    damp = 700,\n    initialBias = 72,\n    initialN = 128, // 0x80\n    delimiter = '-', // '\\x2D'\n  \n    /** Regular expressions */\n    regexPunycode = /^xn--/,\n    regexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n  \n    /** Error messages */\n    errors = {\n      'overflow': 'Overflow: input needs wider integers to process',\n      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n      'invalid-input': 'Invalid input'\n    },\n  \n    /** Convenience shortcuts */\n    baseMinusTMin = base - tMin,\n    floor = Math.floor,\n    stringFromCharCode = String.fromCharCode,\n  \n    /** Temporary variable */\n    key;\n  \n    /*--------------------------------------------------------------------------*/\n  \n    /**\n     * A generic error utility function.\n     * @private\n     * @param {String} type The error type.\n     * @returns {Error} Throws a `RangeError` with the applicable error message.\n     */\n    function error(type) {\n      throw new RangeError(errors[type]);\n    }\n  \n    /**\n     * A generic `Array#map` utility function.\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} callback The function that gets called for every array\n     * item.\n     * @returns {Array} A new array of values returned by the callback function.\n     */\n    function map(array, fn) {\n      var length = array.length;\n      var result = [];\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n      return result;\n    }\n  \n    /**\n     * A simple `Array#map`-like wrapper to work with domain name strings or email\n     * addresses.\n     * @private\n     * @param {String} domain The domain name or email address.\n     * @param {Function} callback The function that gets called for every\n     * character.\n     * @returns {Array} A new string of characters returned by the callback\n     * function.\n     */\n    function mapDomain(string, fn) {\n      var parts = string.split('@');\n      var result = '';\n      if (parts.length > 1) {\n        // In email addresses, only the domain name should be punycoded. Leave\n        // the local part (i.e. everything up to `@`) intact.\n        result = parts[0] + '@';\n        string = parts[1];\n      }\n      // Avoid `split(regex)` for IE8 compatibility. See #17.\n      string = string.replace(regexSeparators, '\\x2E');\n      var labels = string.split('.');\n      var encoded = map(labels, fn).join('.');\n      return result + encoded;\n    }\n  \n    /**\n     * Creates an array containing the numeric code points of each Unicode\n     * character in the string. While JavaScript uses UCS-2 internally,\n     * this function will convert a pair of surrogate halves (each of which\n     * UCS-2 exposes as separate characters) into a single code point,\n     * matching UTF-16.\n     * @see `punycode.ucs2.encode`\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode.ucs2\n     * @name decode\n     * @param {String} string The Unicode input string (UCS-2).\n     * @returns {Array} The new array of code points.\n     */\n    function ucs2decode(string) {\n      var output = [],\n          counter = 0,\n          length = string.length,\n          value,\n          extra;\n      while (counter < length) {\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n          // high surrogate, and there is a next character\n          extra = string.charCodeAt(counter++);\n          if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n          } else {\n            // unmatched surrogate; only append this code unit, in case the next\n            // code unit is the high surrogate of a surrogate pair\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n      return output;\n    }\n  \n    /**\n     * Creates a string based on an array of numeric code points.\n     * @see `punycode.ucs2.decode`\n     * @memberOf punycode.ucs2\n     * @name encode\n     * @param {Array} codePoints The array of numeric code points.\n     * @returns {String} The new Unicode string (UCS-2).\n     */\n    function ucs2encode(array) {\n      return map(array, function(value) {\n        var output = '';\n        if (value > 0xFFFF) {\n          value -= 0x10000;\n          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n          value = 0xDC00 | value & 0x3FF;\n        }\n        output += stringFromCharCode(value);\n        return output;\n      }).join('');\n    }\n  \n    /**\n     * Converts a basic code point into a digit/integer.\n     * @see `digitToBasic()`\n     * @private\n     * @param {Number} codePoint The basic numeric code point value.\n     * @returns {Number} The numeric value of a basic code point (for use in\n     * representing integers) in the range `0` to `base - 1`, or `base` if\n     * the code point does not represent a value.\n     */\n    function basicToDigit(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n      return base;\n    }\n  \n    /**\n     * Converts a digit/integer into a basic code point.\n     * @see `basicToDigit()`\n     * @private\n     * @param {Number} digit The numeric value of a basic code point.\n     * @returns {Number} The basic code point whose value (when used for\n     * representing integers) is `digit`, which needs to be in the range\n     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n     * used; else, the lowercase form is used. The behavior is undefined\n     * if `flag` is non-zero and `digit` has no uppercase form.\n     */\n    function digitToBasic(digit, flag) {\n      //  0..25 map to ASCII a..z or A..Z\n      // 26..35 map to ASCII 0..9\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n  \n    /**\n     * Bias adaptation function as per section 3.4 of RFC 3492.\n     * https://tools.ietf.org/html/rfc3492#section-3.4\n     * @private\n     */\n    function adapt(delta, numPoints, firstTime) {\n      var k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n      for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n  \n    /**\n     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n     * symbols.\n     * @memberOf punycode\n     * @param {String} input The Punycode string of ASCII-only symbols.\n     * @returns {String} The resulting string of Unicode symbols.\n     */\n    function decode(input) {\n      // Don't use UCS-2\n      var output = [],\n          inputLength = input.length,\n          out,\n          i = 0,\n          n = initialN,\n          bias = initialBias,\n          basic,\n          j,\n          index,\n          oldi,\n          w,\n          k,\n          digit,\n          t,\n          /** Cached calculation results */\n          baseMinusT;\n  \n      // Handle the basic code points: let `basic` be the number of input code\n      // points before the last delimiter, or `0` if there is none, then copy\n      // the first basic code points to the output.\n  \n      basic = input.lastIndexOf(delimiter);\n      if (basic < 0) {\n        basic = 0;\n      }\n  \n      for (j = 0; j < basic; ++j) {\n        // if it's not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n          error('not-basic');\n        }\n        output.push(input.charCodeAt(j));\n      }\n  \n      // Main decoding loop: start just after the last delimiter if any basic code\n      // points were copied; start at the beginning otherwise.\n  \n      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n  \n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        for (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n  \n          if (index >= inputLength) {\n            error('invalid-input');\n          }\n  \n          digit = basicToDigit(input.charCodeAt(index++));\n  \n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error('overflow');\n          }\n  \n          i += digit * w;\n          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n  \n          if (digit < t) {\n            break;\n          }\n  \n          baseMinusT = base - t;\n          if (w > floor(maxInt / baseMinusT)) {\n            error('overflow');\n          }\n  \n          w *= baseMinusT;\n  \n        }\n  \n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n  \n        // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we'll fix that now:\n        if (floor(i / out) > maxInt - n) {\n          error('overflow');\n        }\n  \n        n += floor(i / out);\n        i %= out;\n  \n        // Insert `n` at position `i` of the output\n        output.splice(i++, 0, n);\n  \n      }\n  \n      return ucs2encode(output);\n    }\n  \n    /**\n     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n     * Punycode string of ASCII-only symbols.\n     * @memberOf punycode\n     * @param {String} input The string of Unicode symbols.\n     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n     */\n    function encode(input) {\n      var n,\n          delta,\n          handledCPCount,\n          basicLength,\n          bias,\n          j,\n          m,\n          q,\n          k,\n          t,\n          currentValue,\n          output = [],\n          /** `inputLength` will hold the number of code points in `input`. */\n          inputLength,\n          /** Cached calculation results */\n          handledCPCountPlusOne,\n          baseMinusT,\n          qMinusT;\n  \n      // Convert the input in UCS-2 to Unicode\n      input = ucs2decode(input);\n  \n      // Cache the length\n      inputLength = input.length;\n  \n      // Initialize the state\n      n = initialN;\n      delta = 0;\n      bias = initialBias;\n  \n      // Handle the basic code points\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < 0x80) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n  \n      handledCPCount = basicLength = output.length;\n  \n      // `handledCPCount` is the number of code points that have been handled;\n      // `basicLength` is the number of basic code points.\n  \n      // Finish the basic string - if it is not empty - with a delimiter\n      if (basicLength) {\n        output.push(delimiter);\n      }\n  \n      // Main encoding loop:\n      while (handledCPCount < inputLength) {\n  \n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        }\n  \n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow\n        handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error('overflow');\n        }\n  \n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n  \n        for (j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n  \n          if (currentValue < n && ++delta > maxInt) {\n            error('overflow');\n          }\n  \n          if (currentValue == n) {\n            // Represent delta as a generalized variable-length integer\n            for (q = delta, k = base; /* no condition */; k += base) {\n              t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n              if (q < t) {\n                break;\n              }\n              qMinusT = q - t;\n              baseMinusT = base - t;\n              output.push(\n                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n              );\n              q = floor(qMinusT / baseMinusT);\n            }\n  \n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n  \n        ++delta;\n        ++n;\n  \n      }\n      return output.join('');\n    }\n  \n    /**\n     * Converts a Punycode string representing a domain name or an email address\n     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n     * it doesn't matter if you call it on a string that has already been\n     * converted to Unicode.\n     * @memberOf punycode\n     * @param {String} input The Punycoded domain name or email address to\n     * convert to Unicode.\n     * @returns {String} The Unicode representation of the given Punycode\n     * string.\n     */\n    function toUnicode(input) {\n      return mapDomain(input, function(string) {\n        return regexPunycode.test(string)\n          ? decode(string.slice(4).toLowerCase())\n          : string;\n      });\n    }\n  \n    /**\n     * Converts a Unicode string representing a domain name or an email address to\n     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n     * i.e. it doesn't matter if you call it with a domain that's already in\n     * ASCII.\n     * @memberOf punycode\n     * @param {String} input The domain name or email address to convert, as a\n     * Unicode string.\n     * @returns {String} The Punycode representation of the given domain name or\n     * email address.\n     */\n    function toASCII(input) {\n      return mapDomain(input, function(string) {\n        return regexNonASCII.test(string)\n          ? 'xn--' + encode(string)\n          : string;\n      });\n    }\n  \n    /*--------------------------------------------------------------------------*/\n  \n    /** Define the public API */\n    punycode = {\n      /**\n       * A string representing the current Punycode.js version number.\n       * @memberOf punycode\n       * @type String\n       */\n      version: '1.3.2',\n      /**\n       * An object of methods to convert from JavaScript's internal character\n       * representation (UCS-2) to Unicode code points, and back.\n       * @see <https://mathiasbynens.be/notes/javascript-encoding>\n       * @memberOf punycode\n       * @type Object\n       */\n      ucs2: {\n        decode: ucs2decode,\n        encode: ucs2encode\n      },\n      decode: decode,\n      encode: encode,\n      toASCII: toASCII,\n      toUnicode: toUnicode\n    };\n  \n    return punycode;\n  }());\n  \n  if (typeof COMPILED === \"undefined\" && typeof module !== \"undefined\") module.exports = punycode;\n  },{}],19:[function(require,module,exports){\n  ///<reference path=\"commonjs.d.ts\"/>\n  require(\"./schemes/http\");\n  require(\"./schemes/urn\");\n  require(\"./schemes/mailto\");\n  \n  },{\"./schemes/http\":20,\"./schemes/mailto\":21,\"./schemes/urn\":22}],20:[function(require,module,exports){\n  ///<reference path=\"../uri.ts\"/>\n  if (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\n      var URI = require(\"../uri\");\n  URI.SCHEMES[\"http\"] = URI.SCHEMES[\"https\"] = {\n      domainHost: true,\n      parse: function (components, options) {\n          //report missing host\n          if (!components.host) {\n              components.error = components.error || \"HTTP URIs must have a host.\";\n          }\n          return components;\n      },\n      serialize: function (components, options) {\n          //normalize the default port\n          if (components.port === (String(components.scheme).toLowerCase() !== \"https\" ? 80 : 443) || components.port === \"\") {\n              components.port = undefined;\n          }\n          //normalize the empty path\n          if (!components.path) {\n              components.path = \"/\";\n          }\n          //NOTE: We do not parse query strings for HTTP URIs\n          //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n          //and not the HTTP spec. \n          return components;\n      }\n  };\n  \n  },{\"../uri\":23}],21:[function(require,module,exports){\n  ///<reference path=\"../uri.ts\"/>\n  if (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\") {\n      var URI = require(\"../uri\"), punycode = require(\"../punycode\");\n  }\n  (function () {\n      function merge() {\n          var sets = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              sets[_i - 0] = arguments[_i];\n          }\n          if (sets.length > 1) {\n              sets[0] = sets[0].slice(0, -1);\n              var xl = sets.length - 1;\n              for (var x = 1; x < xl; ++x) {\n                  sets[x] = sets[x].slice(1, -1);\n              }\n              sets[xl] = sets[xl].slice(1);\n              return sets.join('');\n          }\n          else {\n              return sets[0];\n          }\n      }\n      function subexp(str) {\n          return \"(?:\" + str + \")\";\n      }\n      var O = {}, isIRI = URI.IRI_SUPPORT, \n      //RFC 3986\n      UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\", HEXDIG$$ = \"[0-9A-Fa-f]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), \n      //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; = \n      //ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\",\n      //WSP$$ = \"[\\\\x20\\\\x09]\",\n      //OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\",  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n      //QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$),  //%d33 / %d35-91 / %d93-126 / obs-qtext\n      //VCHAR$$ = \"[\\\\x21-\\\\x7E]\",\n      //WSP$$ = \"[\\\\x20\\\\x09]\",\n      //OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$)),  //%d0 / CR / LF / obs-qtext\n      //FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\"),\n      //QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$),\n      //QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"'),\n      ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\", QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\", VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\"), DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\"), QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$), QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$), QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"'), \n      //RFC 6068\n      DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\", SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\", QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$), DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\"), LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$), ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$), TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\"), HFNAME$ = subexp(QCHAR$ + \"*\"), HFVALUE$ = HFNAME$, HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$), HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\"), HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$), MAILTO_URI = URI.VALIDATE_SUPPORT && new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\"), UNRESERVED = new RegExp(UNRESERVED$$, \"g\"), PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\"), NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\"), NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\"), NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\"), NOT_HFVALUE = NOT_HFNAME, TO = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + TO$ + \"$\"), HFIELDS = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + HFIELDS2$ + \"$\");\n      function toUpperCase(str) {\n          return str.toUpperCase();\n      }\n      function decodeUnreserved(str) {\n          var decStr = URI.pctDecChars(str);\n          return (!decStr.match(UNRESERVED) ? str : decStr);\n      }\n      function toArray(obj) {\n          return obj !== undefined && obj !== null ? (obj instanceof Array && !obj.callee ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n      }\n      URI.SCHEMES[\"mailto\"] = {\n          parse: function (components, options) {\n              if (URI.VALIDATE_SUPPORT && !components.error) {\n                  if (components.path && !TO.test(components.path)) {\n                      components.error = \"Email address is not valid\";\n                  }\n                  else if (components.query && !HFIELDS.test(components.query)) {\n                      components.error = \"Header fields are invalid\";\n                  }\n              }\n              var to = components.to = (components.path ? components.path.split(\",\") : []);\n              components.path = undefined;\n              if (components.query) {\n                  var unknownHeaders = false, headers = {};\n                  var hfields = components.query.split(\"&\");\n                  for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                      var hfield = hfields[x].split(\"=\");\n                      switch (hfield[0]) {\n                          case \"to\":\n                              var toAddrs = hfield[1].split(\",\");\n                              for (var x_1 = 0, xl_1 = toAddrs.length; x_1 < xl_1; ++x_1) {\n                                  to.push(toAddrs[x_1]);\n                              }\n                              break;\n                          case \"subject\":\n                              components.subject = URI.unescapeComponent(hfield[1], options);\n                              break;\n                          case \"body\":\n                              components.body = URI.unescapeComponent(hfield[1], options);\n                              break;\n                          default:\n                              unknownHeaders = true;\n                              headers[URI.unescapeComponent(hfield[0], options)] = URI.unescapeComponent(hfield[1], options);\n                              break;\n                      }\n                  }\n                  if (unknownHeaders)\n                      components.headers = headers;\n              }\n              components.query = undefined;\n              for (var x = 0, xl = to.length; x < xl; ++x) {\n                  var addr = to[x].split(\"@\");\n                  addr[0] = URI.unescapeComponent(addr[0]);\n                  if (typeof punycode !== \"undefined\" && !options.unicodeSupport) {\n                      //convert Unicode IDN -> ASCII IDN\n                      try {\n                          addr[1] = punycode.toASCII(URI.unescapeComponent(addr[1], options).toLowerCase());\n                      }\n                      catch (e) {\n                          components.error = components.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                      }\n                  }\n                  else {\n                      addr[1] = URI.unescapeComponent(addr[1], options).toLowerCase();\n                  }\n                  to[x] = addr.join(\"@\");\n              }\n              return components;\n          },\n          serialize: function (components, options) {\n              var to = toArray(components.to);\n              if (to) {\n                  for (var x = 0, xl = to.length; x < xl; ++x) {\n                      var toAddr = String(to[x]);\n                      var atIdx = toAddr.lastIndexOf(\"@\");\n                      var localPart = toAddr.slice(0, atIdx);\n                      var domain = toAddr.slice(atIdx + 1);\n                      localPart = localPart.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, URI.pctEncChar);\n                      if (typeof punycode !== \"undefined\") {\n                          //convert IDN via punycode\n                          try {\n                              domain = (!options.iri ? punycode.toASCII(URI.unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n                          }\n                          catch (e) {\n                              components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                          }\n                      }\n                      else {\n                          domain = domain.replace(PCT_ENCODED, decodeUnreserved).toLowerCase().replace(PCT_ENCODED, toUpperCase).replace(NOT_DOMAIN, URI.pctEncChar);\n                      }\n                      to[x] = localPart + \"@\" + domain;\n                  }\n                  components.path = to.join(\",\");\n              }\n              var headers = components.headers = components.headers || {};\n              if (components.subject)\n                  headers[\"subject\"] = components.subject;\n              if (components.body)\n                  headers[\"body\"] = components.body;\n              var fields = [];\n              for (var name_1 in headers) {\n                  if (headers[name_1] !== O[name_1]) {\n                      fields.push(name_1.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, URI.pctEncChar) +\n                          \"=\" +\n                          headers[name_1].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, URI.pctEncChar));\n                  }\n              }\n              if (fields.length) {\n                  components.query = fields.join(\"&\");\n              }\n              return components;\n          }\n      };\n  })();\n  \n  },{\"../punycode\":18,\"../uri\":23}],22:[function(require,module,exports){\n  ///<reference path=\"../uri.ts\"/>\n  if (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\n      var URI = require(\"../uri\");\n  (function () {\n      var pctEncChar = URI.pctEncChar, NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\", PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\", TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\", NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\", URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\"), URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\"), URN_PARSE = /^([^\\:]+)\\:(.*)/, URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g, UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n      //RFC 2141\n      URI.SCHEMES[\"urn\"] = {\n          parse: function (components, options) {\n              var matches = components.path.match(URN_PATH), scheme, schemeHandler;\n              if (!matches) {\n                  if (!options.tolerant) {\n                      components.error = components.error || \"URN is not strictly valid.\";\n                  }\n                  matches = components.path.match(URN_PARSE);\n              }\n              if (matches) {\n                  scheme = \"urn:\" + matches[1].toLowerCase();\n                  schemeHandler = URI.SCHEMES[scheme];\n                  //in order to serialize properly, \n                  //every URN must have a serializer that calls the URN serializer \n                  if (!schemeHandler) {\n                      //create fake scheme handler\n                      schemeHandler = URI.SCHEMES[scheme] = {\n                          parse: function (components, options) {\n                              return components;\n                          },\n                          serialize: URI.SCHEMES[\"urn\"].serialize\n                      };\n                  }\n                  components.scheme = scheme;\n                  components.path = matches[2];\n                  components = schemeHandler.parse(components, options);\n              }\n              else {\n                  components.error = components.error || \"URN can not be parsed.\";\n              }\n              return components;\n          },\n          serialize: function (components, options) {\n              var scheme = components.scheme || options.scheme, matches;\n              if (scheme && scheme !== \"urn\") {\n                  var matches = scheme.match(URN_SCHEME);\n                  if (!matches) {\n                      matches = [\"urn:\" + scheme, scheme];\n                  }\n                  components.scheme = \"urn\";\n                  components.path = matches[1] + \":\" + (components.path ? components.path.replace(URN_EXCLUDED, pctEncChar) : \"\");\n              }\n              return components;\n          }\n      };\n      //RFC 4122\n      URI.SCHEMES[\"urn:uuid\"] = {\n          parse: function (components, options) {\n              if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\n                  components.error = components.error || \"UUID is not valid.\";\n              }\n              return components;\n          },\n          serialize: function (components, options) {\n              //ensure UUID is valid\n              if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\n                  //invalid UUIDs can not have this scheme\n                  components.scheme = undefined;\n              }\n              else {\n                  //normalize UUID\n                  components.path = (components.path || \"\").toLowerCase();\n              }\n              return URI.SCHEMES[\"urn\"].serialize(components, options);\n          }\n      };\n  }());\n  \n  },{\"../uri\":23}],23:[function(require,module,exports){\n  /**\n   * URI.js\n   *\n   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @version 2.0.0\n   * @see http://github.com/garycourt/uri-js\n   * @license URI.js v2.0.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js\n   */\n  /**\n   * Copyright 2011 Gary Court. All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification, are\n   * permitted provided that the following conditions are met:\n   *\n   *    1. Redistributions of source code must retain the above copyright notice, this list of\n   *       conditions and the following disclaimer.\n   *\n   *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n   *       of conditions and the following disclaimer in the documentation and/or other materials\n   *       provided with the distribution.\n   *\n   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   *\n   * The views and conclusions contained in the software and documentation are those of the\n   * authors and should not be interpreted as representing official policies, either expressed\n   * or implied, of Gary Court.\n   */\n  ///<reference path=\"punycode.d.ts\"/>\n  ///<reference path=\"commonjs.d.ts\"/>\n  /**\n   * Compiler switch for indicating code is compiled\n   * @define {boolean}\n   */\n  var COMPILED = false;\n  /**\n   * Compiler switch for supporting IRI URIs\n   * @define {boolean}\n   */\n  var URI__IRI_SUPPORT = true;\n  /**\n   * Compiler switch for supporting URI validation\n   * @define {boolean}\n   */\n  var URI__VALIDATE_SUPPORT = true;\n  var URI = (function () {\n      function merge() {\n          var sets = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              sets[_i - 0] = arguments[_i];\n          }\n          if (sets.length > 1) {\n              sets[0] = sets[0].slice(0, -1);\n              var xl = sets.length - 1;\n              for (var x = 1; x < xl; ++x) {\n                  sets[x] = sets[x].slice(1, -1);\n              }\n              sets[xl] = sets[xl].slice(1);\n              return sets.join('');\n          }\n          else {\n              return sets[0];\n          }\n      }\n      function subexp(str) {\n          return \"(?:\" + str + \")\";\n      }\n      function buildExps(isIRI) {\n          var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS$ = subexp(merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IPVFUTURE$ = subexp(\"v\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n          return {\n              URI_REF: URI__VALIDATE_SUPPORT && new RegExp(\"(\" + GENERIC_REF$ + \")|(\" + RELATIVE_REF$ + \")\"),\n              NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n              NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n              NOT_HOST: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n              NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n              NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n              NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n              NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n              ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n              UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n              OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n              PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\")\n          };\n      }\n      var URI_PROTOCOL = buildExps(false), IRI_PROTOCOL = URI__IRI_SUPPORT ? buildExps(true) : undefined, URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?([^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n)*))?/i, RDS1 = /^\\.\\.?\\//, RDS2 = /^\\/\\.(\\/|$)/, RDS3 = /^\\/\\.\\.(\\/|$)/, RDS4 = /^\\.\\.?$/, RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/, NO_MATCH_IS_UNDEFINED = (\"\").match(/(){0}/)[1] === undefined;\n      function pctEncChar(chr) {\n          var c = chr.charCodeAt(0), e;\n          if (c < 16)\n              e = \"%0\" + c.toString(16).toUpperCase();\n          else if (c < 128)\n              e = \"%\" + c.toString(16).toUpperCase();\n          else if (c < 2048)\n              e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n          else\n              e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n          return e;\n      }\n      function pctDecChars(str) {\n          var newStr = \"\", i = 0, il = str.length, c, c2, c3;\n          while (i < il) {\n              c = parseInt(str.substr(i + 1, 2), 16);\n              if (c < 128) {\n                  newStr += String.fromCharCode(c);\n                  i += 3;\n              }\n              else if (c >= 194 && c < 224) {\n                  if ((il - i) >= 6) {\n                      c2 = parseInt(str.substr(i + 4, 2), 16);\n                      newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                  }\n                  else {\n                      newStr += str.substr(i, 6);\n                  }\n                  i += 6;\n              }\n              else if (c >= 224) {\n                  if ((il - i) >= 9) {\n                      c2 = parseInt(str.substr(i + 4, 2), 16);\n                      c3 = parseInt(str.substr(i + 7, 2), 16);\n                      newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n                  }\n                  else {\n                      newStr += str.substr(i, 9);\n                  }\n                  i += 9;\n              }\n              else {\n                  newStr += str.substr(i, 3);\n                  i += 3;\n              }\n          }\n          return newStr;\n      }\n      function typeOf(o) {\n          return o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n      }\n      function toUpperCase(str) {\n          return str.toUpperCase();\n      }\n      var SCHEMES = {};\n      function _normalizeComponentEncoding(components, protocol) {\n          function decodeUnreserved(str) {\n              var decStr = pctDecChars(str);\n              return (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n          }\n          if (components.scheme)\n              components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n          if (components.userinfo !== undefined)\n              components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n          if (components.host !== undefined)\n              components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n          if (components.path !== undefined)\n              components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n          if (components.query !== undefined)\n              components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n          if (components.fragment !== undefined)\n              components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n          return components;\n      }\n      ;\n      function parse(uriString, options) {\n          if (options === void 0) { options = {}; }\n          var protocol = (URI__IRI_SUPPORT && options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL), matches, parseError = false, components = {}, schemeHandler;\n          if (options.reference === \"suffix\")\n              uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n          if (URI__VALIDATE_SUPPORT) {\n              matches = uriString.match(protocol.URI_REF);\n              if (matches) {\n                  if (matches[1]) {\n                      //generic URI\n                      matches = matches.slice(1, 10);\n                  }\n                  else {\n                      //relative URI\n                      matches = matches.slice(10, 19);\n                  }\n              }\n              if (!matches) {\n                  parseError = true;\n                  if (!options.tolerant)\n                      components.error = components.error || \"URI is not strictly valid.\";\n                  matches = uriString.match(URI_PARSE);\n              }\n          }\n          else {\n              matches = uriString.match(URI_PARSE);\n          }\n          if (matches) {\n              if (NO_MATCH_IS_UNDEFINED) {\n                  //store each component\n                  components.scheme = matches[1];\n                  //components.authority = matches[2];\n                  components.userinfo = matches[3];\n                  components.host = matches[4];\n                  components.port = parseInt(matches[5], 10);\n                  components.path = matches[6] || \"\";\n                  components.query = matches[7];\n                  components.fragment = matches[8];\n                  //fix port number\n                  if (isNaN(components.port)) {\n                      components.port = matches[5];\n                  }\n              }\n              else {\n                  //store each component\n                  components.scheme = matches[1] || undefined;\n                  //components.authority = (uriString.indexOf(\"//\") !== -1 ? matches[2] : undefined);\n                  components.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n                  components.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n                  components.port = parseInt(matches[5], 10);\n                  components.path = matches[6] || \"\";\n                  components.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n                  components.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n                  //fix port number\n                  if (isNaN(components.port)) {\n                      components.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n                  }\n              }\n              //determine reference type\n              if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                  components.reference = \"same-document\";\n              }\n              else if (components.scheme === undefined) {\n                  components.reference = \"relative\";\n              }\n              else if (components.fragment === undefined) {\n                  components.reference = \"absolute\";\n              }\n              else {\n                  components.reference = \"uri\";\n              }\n              //check for reference errors\n              if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                  components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n              }\n              //find scheme handler\n              schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n              //check if scheme can't handle IRIs\n              if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && !options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                  //if host component is a domain name\n                  if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n                      //convert Unicode IDN -> ASCII IDN\n                      try {\n                          components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                      }\n                      catch (e) {\n                          components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                      }\n                  }\n                  //convert IRI -> URI\n                  _normalizeComponentEncoding(components, URI_PROTOCOL);\n              }\n              else {\n                  //normalize encodings\n                  _normalizeComponentEncoding(components, protocol);\n              }\n              //perform scheme specific parsing\n              if (schemeHandler && schemeHandler.parse) {\n                  schemeHandler.parse(components, options);\n              }\n          }\n          else {\n              parseError = true;\n              components.error = components.error || \"URI can not be parsed.\";\n          }\n          return components;\n      }\n      ;\n      function _recomposeAuthority(components, options) {\n          var uriTokens = [];\n          if (components.userinfo !== undefined) {\n              uriTokens.push(components.userinfo);\n              uriTokens.push(\"@\");\n          }\n          if (components.host !== undefined) {\n              uriTokens.push(components.host);\n          }\n          if (typeof components.port === \"number\") {\n              uriTokens.push(\":\");\n              uriTokens.push(components.port.toString(10));\n          }\n          return uriTokens.length ? uriTokens.join(\"\") : undefined;\n      }\n      ;\n      function removeDotSegments(input) {\n          var output = [], s;\n          while (input.length) {\n              if (input.match(RDS1)) {\n                  input = input.replace(RDS1, \"\");\n              }\n              else if (input.match(RDS2)) {\n                  input = input.replace(RDS2, \"/\");\n              }\n              else if (input.match(RDS3)) {\n                  input = input.replace(RDS3, \"/\");\n                  output.pop();\n              }\n              else if (input === \".\" || input === \"..\") {\n                  input = \"\";\n              }\n              else {\n                  s = input.match(RDS5)[0];\n                  input = input.slice(s.length);\n                  output.push(s);\n              }\n          }\n          return output.join(\"\");\n      }\n      ;\n      function serialize(components, options) {\n          if (options === void 0) { options = {}; }\n          var protocol = (URI__IRI_SUPPORT && options.iri ? IRI_PROTOCOL : URI_PROTOCOL), uriTokens = [], schemeHandler, authority, s;\n          //find scheme handler\n          schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n          //perform scheme specific serialization\n          if (schemeHandler && schemeHandler.serialize)\n              schemeHandler.serialize(components, options);\n          //if host component is a domain name\n          if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n              //convert IDN via punycode\n              try {\n                  components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n              }\n              catch (e) {\n                  components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n              }\n          }\n          //normalize encoding\n          _normalizeComponentEncoding(components, protocol);\n          if (options.reference !== \"suffix\" && components.scheme) {\n              uriTokens.push(components.scheme);\n              uriTokens.push(\":\");\n          }\n          authority = _recomposeAuthority(components, options);\n          if (authority !== undefined) {\n              if (options.reference !== \"suffix\") {\n                  uriTokens.push(\"//\");\n              }\n              uriTokens.push(authority);\n              if (components.path && components.path.charAt(0) !== \"/\") {\n                  uriTokens.push(\"/\");\n              }\n          }\n          if (components.path !== undefined) {\n              s = components.path;\n              if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                  s = removeDotSegments(s);\n              }\n              if (authority === undefined) {\n                  s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n              }\n              uriTokens.push(s);\n          }\n          if (components.query !== undefined) {\n              uriTokens.push(\"?\");\n              uriTokens.push(components.query);\n          }\n          if (components.fragment !== undefined) {\n              uriTokens.push(\"#\");\n              uriTokens.push(components.fragment);\n          }\n          return uriTokens.join(''); //merge tokens into a string\n      }\n      ;\n      function resolveComponents(base, relative, options, skipNormalization) {\n          if (options === void 0) { options = {}; }\n          var target = {};\n          if (!skipNormalization) {\n              base = parse(serialize(base, options), options); //normalize base components\n              relative = parse(serialize(relative, options), options); //normalize relative components\n          }\n          options = options || {};\n          if (!options.tolerant && relative.scheme) {\n              target.scheme = relative.scheme;\n              //target.authority = relative.authority;\n              target.userinfo = relative.userinfo;\n              target.host = relative.host;\n              target.port = relative.port;\n              target.path = removeDotSegments(relative.path);\n              target.query = relative.query;\n          }\n          else {\n              if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                  //target.authority = relative.authority;\n                  target.userinfo = relative.userinfo;\n                  target.host = relative.host;\n                  target.port = relative.port;\n                  target.path = removeDotSegments(relative.path);\n                  target.query = relative.query;\n              }\n              else {\n                  if (!relative.path) {\n                      target.path = base.path;\n                      if (relative.query !== undefined) {\n                          target.query = relative.query;\n                      }\n                      else {\n                          target.query = base.query;\n                      }\n                  }\n                  else {\n                      if (relative.path.charAt(0) === \"/\") {\n                          target.path = removeDotSegments(relative.path);\n                      }\n                      else {\n                          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                              target.path = \"/\" + relative.path;\n                          }\n                          else if (!base.path) {\n                              target.path = relative.path;\n                          }\n                          else {\n                              target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                          }\n                          target.path = removeDotSegments(target.path);\n                      }\n                      target.query = relative.query;\n                  }\n                  //target.authority = base.authority;\n                  target.userinfo = base.userinfo;\n                  target.host = base.host;\n                  target.port = base.port;\n              }\n              target.scheme = base.scheme;\n          }\n          target.fragment = relative.fragment;\n          return target;\n      }\n      ;\n      function resolve(baseURI, relativeURI, options) {\n          return serialize(resolveComponents(parse(baseURI, options), parse(relativeURI, options), options, true), options);\n      }\n      ;\n      function normalize(uri, options) {\n          if (typeof uri === \"string\") {\n              uri = serialize(parse(uri, options), options);\n          }\n          else if (typeOf(uri) === \"object\") {\n              uri = parse(serialize(uri, options), options);\n          }\n          return uri;\n      }\n      ;\n      function equal(uriA, uriB, options) {\n          if (typeof uriA === \"string\") {\n              uriA = serialize(parse(uriA, options), options);\n          }\n          else if (typeOf(uriA) === \"object\") {\n              uriA = serialize(uriA, options);\n          }\n          if (typeof uriB === \"string\") {\n              uriB = serialize(parse(uriB, options), options);\n          }\n          else if (typeOf(uriB) === \"object\") {\n              uriB = serialize(uriB, options);\n          }\n          return uriA === uriB;\n      }\n      ;\n      function escapeComponent(str, options) {\n          return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n      }\n      ;\n      function unescapeComponent(str, options) {\n          return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n      }\n      ;\n      return {\n          IRI_SUPPORT: URI__IRI_SUPPORT,\n          VALIDATE_SUPPORT: URI__VALIDATE_SUPPORT,\n          pctEncChar: pctEncChar,\n          pctDecChars: pctDecChars,\n          SCHEMES: SCHEMES,\n          parse: parse,\n          _recomposeAuthority: _recomposeAuthority,\n          removeDotSegments: removeDotSegments,\n          serialize: serialize,\n          resolveComponents: resolveComponents,\n          resolve: resolve,\n          normalize: normalize,\n          equal: equal,\n          escapeComponent: escapeComponent,\n          unescapeComponent: unescapeComponent\n      };\n  })();\n  if (!COMPILED && typeof module !== \"undefined\" && typeof require === \"function\") {\n      var punycode = require(\"./punycode\");\n      module.exports = URI;\n      require(\"./schemes\");\n  }\n  \n  },{\"./punycode\":18,\"./schemes\":19}]},{},[1])(1)\n  });\n  //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYXRpdmUtcHJvbWlzZS1vbmx5L2xpYi9ucG8uc3JjLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWxvYWRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWxvYWRlci9saWIvbG9hZGVycy9maWxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aC1sb2FkZXIvbGliL2xvYWRlcnMvaHR0cC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1Y2UtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NsYXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvdXJpLWpzL2J1aWxkL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL3VyaS1qcy9idWlsZC9zY2hlbWVzLmpzIiwibm9kZV9tb2R1bGVzL3VyaS1qcy9idWlsZC9zY2hlbWVzL2h0dHAuanMiLCJub2RlX21vZHVsZXMvdXJpLWpzL2J1aWxkL3NjaGVtZXMvbWFpbHRvLmpzIiwibm9kZV9tb2R1bGVzL3VyaS1qcy9idWlsZC9zY2hlbWVzL3Vybi5qcyIsIm5vZGVfbW9kdWxlcy91cmktanMvYnVpbGQvdXJpLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyBmb3IgSlNPTiBSZWZlcmVuY2VzICooaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMykqIGFuZFxuICogSlNPTiBQb2ludGVycyAqKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxKSouXG4gKlxuICogQG1vZHVsZSBKc29uUmVmc1xuICovXG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIFBhdGhMb2FkZXIgPSByZXF1aXJlKCdwYXRoLWxvYWRlcicpO1xudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciBzbGFzaCA9IHJlcXVpcmUoJ3NsYXNoJyk7XG52YXIgVVJJID0gcmVxdWlyZSgndXJpLWpzJyk7XG5cbnZhciBiYWRQdHJUb2tlblJlZ2V4ID0gL34oPzpbXjAxXXwkKS9nO1xudmFyIHJlbW90ZUNhY2hlID0ge307XG52YXIgcmVtb3RlVHlwZXMgPSBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddO1xudmFyIHJlbW90ZVVyaVR5cGVzID0gWydhYnNvbHV0ZScsICd1cmknXTtcbnZhciB1cmlEZXRhaWxzQ2FjaGUgPSB7fTtcblxuLy8gTG9hZCBwcm9taXNlcyBwb2x5ZmlsbCBpZiBuZWNlc3Nhcnlcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICByZXF1aXJlKCduYXRpdmUtcHJvbWlzZS1vbmx5Jyk7XG59XG5cbi8qIEludGVybmFsIEZ1bmN0aW9ucyAqL1xuXG4vLyBUaGlzIGlzIGEgdmVyeSBzaW1wbGlzdGljIGNsb25lIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgbm9uLUpTT04gdHlwZXMuICBGb3IgdGhlc2UgdHlwZXMgdGhlXG4vLyBvcmlnaW5hbCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBjbG9uZS4gIFNvIHdoaWxlIGl0J3Mgbm90IGEgY29tcGxldGUgZGVlcCBjbG9uZSwgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHByb2plY3Rcbi8vIHRoaXMgc2hvdWxkIGJlIHN1ZmZpY2llbnQuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBjbG9uZWQ7XG5cbiAgaWYgKGlzVHlwZShvYmosICdBcnJheScpKSB7XG4gICAgY2xvbmVkID0gW107XG5cbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICBjbG9uZWRbaW5kZXhdID0gY2xvbmUodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzVHlwZShvYmosICdPYmplY3QnKSkge1xuICAgIGNsb25lZCA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNsb25lZFtrZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNsb25lZCA9IG9iajtcbiAgfVxuXG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVRdWVyeVBhcmFtcyAocXMxLCBxczIpIHtcbiAgdmFyIGNvbWJpbmVkID0ge307XG5cbiAgZnVuY3Rpb24gbWVyZ2VRdWVyeVBhcmFtcyAob2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNvbWJpbmVkW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmdlUXVlcnlQYXJhbXMocXMucGFyc2UocXMxIHx8ICcnKSk7XG4gIG1lcmdlUXVlcnlQYXJhbXMocXMucGFyc2UocXMyIHx8ICcnKSk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbWJpbmVkKS5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBxcy5zdHJpbmdpZnkoY29tYmluZWQpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lVVJJcyAodTEsIHUyKSB7XG4gIC8vIENvbnZlcnQgV2luZG93cyBwYXRoc1xuICBpZiAoaXNUeXBlKHUxLCAnU3RyaW5nJykpIHtcbiAgICB1MSA9IHNsYXNoKHUxKTtcbiAgfVxuXG4gIGlmIChpc1R5cGUodTIsICdTdHJpbmcnKSkge1xuICAgIHUyID0gc2xhc2godTIpO1xuICB9XG5cbiAgdmFyIHUyRGV0YWlscyA9IHBhcnNlVVJJKGlzVHlwZSh1MiwgJ1VuZGVmaW5lZCcpID8gJycgOiB1Mik7XG4gIHZhciB1MURldGFpbHM7XG4gIHZhciBjb21iaW5lZERldGFpbHM7XG5cbiAgaWYgKHJlbW90ZVVyaVR5cGVzLmluZGV4T2YodTJEZXRhaWxzLnJlZmVyZW5jZSkgPiAtMSkge1xuICAgIGNvbWJpbmVkRGV0YWlscyA9IHUyRGV0YWlscztcbiAgfSBlbHNlIHtcbiAgICB1MURldGFpbHMgPSBpc1R5cGUodTEsICdVbmRlZmluZWQnKSA/IHVuZGVmaW5lZCA6IHBhcnNlVVJJKHUxKTtcblxuICAgIGlmICghaXNUeXBlKHUxRGV0YWlscywgJ1VuZGVmaW5lZCcpKSB7XG4gICAgICBjb21iaW5lZERldGFpbHMgPSB1MURldGFpbHM7XG5cbiAgICAgIC8vIEpvaW4gdGhlIHBhdGhzXG4gICAgICBjb21iaW5lZERldGFpbHMucGF0aCA9IHNsYXNoKHBhdGguam9pbih1MURldGFpbHMucGF0aCwgdTJEZXRhaWxzLnBhdGgpKTtcblxuICAgICAgLy8gSm9pbiBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICBjb21iaW5lZERldGFpbHMucXVlcnkgPSBjb21iaW5lUXVlcnlQYXJhbXModTFEZXRhaWxzLnF1ZXJ5LCB1MkRldGFpbHMucXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iaW5lZERldGFpbHMgPSB1MkRldGFpbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBmcmFnbWVudFxuICBjb21iaW5lZERldGFpbHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gRm9yIHJlbGF0aXZlIFVSSXMsIGFkZCBiYWNrIHRoZSAnLi4nIHNpbmNlIGl0IHdhcyByZW1vdmVkIGFib3ZlXG4gIHJldHVybiAocmVtb3RlVXJpVHlwZXMuaW5kZXhPZihjb21iaW5lZERldGFpbHMucmVmZXJlbmNlKSA9PT0gLTEgJiZcbiAgICAgICAgICBjb21iaW5lZERldGFpbHMucGF0aC5pbmRleE9mKCcuLi8nKSA9PT0gMCA/ICcuLi8nIDogJycpICsgVVJJLnNlcmlhbGl6ZShjb21iaW5lZERldGFpbHMpO1xufVxuXG5mdW5jdGlvbiBmaW5kQW5jZXN0b3JzIChvYmosIHBhdGgpIHtcbiAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICB2YXIgbm9kZTtcblxuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgbm9kZSA9IG9iajtcblxuICAgIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgIGlmIChzZWcgaW4gbm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZVtzZWddO1xuXG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1N1YkRvY3VtZW50IChtb2RlLCBkb2MsIHN1YkRvY1BhdGgsIHJlZkRldGFpbHMsIG9wdGlvbnMsIHBhcmVudHMsIHBhcmVudFB0cnMsIGFsbFJlZnMsIGluZGlyZWN0KSB7XG4gIHZhciByZWZWYWx1ZTtcbiAgdmFyIHJPcHRpb25zO1xuXG4gIGlmIChzdWJEb2NQYXRoLmxlbmd0aCA+IDApIHtcbiAgICB0cnkge1xuICAgICAgcmVmVmFsdWUgPSBmaW5kVmFsdWUoZG9jLCBzdWJEb2NQYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFdlIG9ubHkgbWFyayBtaXNzaW5nIHJlbW90ZSByZWZlcmVuY2VzIGFzIG1pc3NpbmcgYmVjYXVzZSBsb2NhbCByZWZlcmVuY2VzIGNhbiBoYXZlIGRlZmVycmVkIHZhbHVlc1xuICAgICAgaWYgKG1vZGUgPT09ICdyZW1vdGUnKSB7XG4gICAgICAgIHJlZkRldGFpbHMuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgcmVmRGV0YWlscy5taXNzaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVmVmFsdWUgPSBkb2M7XG4gIH1cblxuICBpZiAoIWlzVHlwZShyZWZWYWx1ZSwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgcmVmRGV0YWlscy52YWx1ZSA9IHJlZlZhbHVlO1xuICB9XG5cbiAgaWYgKGlzVHlwZShyZWZWYWx1ZSwgJ0FycmF5JykgfHwgaXNUeXBlKHJlZlZhbHVlLCAnT2JqZWN0JykpIHtcbiAgICByT3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xuXG4gICAgaWYgKG1vZGUgPT09ICdsb2NhbCcpIHtcbiAgICAgIGRlbGV0ZSByT3B0aW9ucy5zdWJEb2NQYXRoO1xuXG4gICAgICAvLyBUcmF2ZXJzZSB0aGUgZGVyZWZlcmVuY2VkIHZhbHVlXG4gICAgICBkb2MgPSByZWZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgck9wdGlvbnMucmVsYXRpdmVCYXNlID0gcGF0aC5kaXJuYW1lKHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChzdWJEb2NQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgck9wdGlvbnMuc3ViRG9jUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJPcHRpb25zLnN1YkRvY1BhdGggPSBzdWJEb2NQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaW5kUmVmc1JlY3Vyc2l2ZShkb2MsIHJPcHRpb25zLCBwYXJlbnRzLCBwYXJlbnRQdHJzLCBhbGxSZWZzLCBpbmRpcmVjdCk7XG4gIH1cbn1cblxuLy8gU2hvdWxkIHRoaXMgYmUgaXRzIG93biBleHBvcnRlZCBBUEk/XG5mdW5jdGlvbiBmaW5kUmVmc1JlY3Vyc2l2ZSAob2JqLCBvcHRpb25zLCBwYXJlbnRzLCBwYXJlbnRQdHJzLCBhbGxSZWZzLCBpbmRpcmVjdCkge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIHBhcmVudFBhdGggPSBwYXJlbnRQdHJzLmxlbmd0aCA/IHBhdGhGcm9tUHRyKHBhcmVudFB0cnNbcGFyZW50UHRycy5sZW5ndGggLSAxXSkgOiBbXTtcbiAgdmFyIHJlZnMgPSBmaW5kUmVmcyhvYmosIG9wdGlvbnMpO1xuICB2YXIgc3ViRG9jUGF0aCA9IG9wdGlvbnMuc3ViRG9jUGF0aCB8fCBbXTtcbiAgdmFyIHN1YkRvY1B0ciA9IHBhdGhUb1B0cihzdWJEb2NQYXRoKTtcbiAgdmFyIGFuY2VzdG9yUHRycyA9IFsnIyddO1xuXG4gIHBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50LCBpbmRleCkge1xuICAgIGlmIChwYXJlbnQuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgIGFuY2VzdG9yUHRycy5wdXNoKHBhcmVudFB0cnNbaW5kZXhdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJldmVyc2UgdGhlIG9yZGVyIHNvIHdlIHNlYXJjaCB0aGVtIGluIHRoZSBwcm9wZXIgb3JkZXJcbiAgYW5jZXN0b3JQdHJzLnJldmVyc2UoKTtcblxuICBpZiAoKHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSB8fCAnJykuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBhbGxSZWZzLmRvY3VtZW50c1twYXRoVG9QdHIocGFyZW50UGF0aCldID0gb2JqO1xuICB9XG5cbiAgT2JqZWN0LmtleXMocmVmcykuZm9yRWFjaChmdW5jdGlvbiAocmVmUHRyKSB7XG4gICAgdmFyIHJlZkRldGFpbHMgPSByZWZzW3JlZlB0cl07XG4gICAgdmFyIGxvY2F0aW9uO1xuICAgIHZhciBwYXJlbnRJbmRleDtcbiAgICB2YXIgcmVmRnVsbFBhdGg7XG4gICAgdmFyIHJlZkZ1bGxQdHI7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGFyZW50cywgdHJlYXQgdGhlIHJlZmVyZW5jZSBwb2ludGVyIGFzLWlzLiAgT3RoZXJ3aXNlLCB0aGUgcmVmZXJlbmNlIGlzIGEgcmVmZXJlbmNlIHdpdGhpbiBhXG4gICAgLy8gcmVtb3RlIGRvY3VtZW50IGFuZCBpdHMgc3ViIGRvY3VtZW50IHBhdGggcHJlZml4IG11c3QgYmUgcmVtb3ZlZC5cbiAgICBpZiAocGFyZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlZkZ1bGxQYXRoID0gcGFyZW50UGF0aC5jb25jYXQocGF0aEZyb21QdHIocmVmUHRyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkZ1bGxQYXRoID0gcGFyZW50UGF0aC5jb25jYXQocGF0aEZyb21QdHIocmVmUHRyKS5zbGljZShwYXJlbnRzLmxlbmd0aCA9PT0gMCA/IDAgOiBzdWJEb2NQYXRoLmxlbmd0aCkpO1xuICAgIH1cblxuICAgIHJlZkZ1bGxQdHIgPSBwYXRoVG9QdHIocmVmRnVsbFBhdGgpO1xuXG4gICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcHJvY2VzcyB0aGUgc2FtZSByZWZlcmVuY2UgbW9yZSB0aGFuIG9uY2UgaW4gdGhlIGV2ZW50IG9mIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIHNvIHdlIGF2b2lkXG4gICAgLy8gcHJvY2Vzc2luZyBhIHJlZmVyZW5jZSBpZiB3ZSd2ZSBhbHJlYWR5IGRvbmUgc28uXG4gICAgaWYgKCFpc1R5cGUoYWxsUmVmc1tyZWZGdWxsUHRyXSwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIHRoZSByZWZlcmVuY2UgbWV0YWRhdGFcbiAgICBhbGxSZWZzLnJlZnNbcmVmRnVsbFB0cl0gPSByZWZzW3JlZlB0cl07XG5cbiAgICAvLyBEbyBub3QgcHJvY2VzcyBpbnZhbGlkIHJlZmVyZW5jZXNcbiAgICBpZiAoaXNUeXBlKHJlZkRldGFpbHMuZXJyb3IsICdVbmRlZmluZWQnKSAmJiByZWZEZXRhaWxzLnR5cGUgIT09ICdpbnZhbGlkJykge1xuICAgICAgaWYgKHJlbW90ZVR5cGVzLmluZGV4T2YocmVmRGV0YWlscy50eXBlKSA+IC0xKSB7XG4gICAgICAgIGxvY2F0aW9uID0gY29tYmluZVVSSXMob3B0aW9ucy5yZWxhdGl2ZUJhc2UsIHJlZkRldGFpbHMudXJpKTtcbiAgICAgICAgcGFyZW50SW5kZXggPSBwYXJlbnRzLmluZGV4T2YobG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24gPSByZWZEZXRhaWxzLnVyaTtcbiAgICAgICAgcGFyZW50SW5kZXggPSBwYXJlbnRQdHJzLmluZGV4T2YobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWNvcmQgYW5jZXN0b3IgcGF0aHNcbiAgICAgIHJlZkRldGFpbHMuYW5jZXN0b3JQdHJzID0gYW5jZXN0b3JQdHJzO1xuXG4gICAgICAvLyBSZWNvcmQgaWYgdGhlIHJlZmVyZW5jZSBpcyBpbmRpcmVjdCBiYXNlZCBvbiBpdHMgcGFyZW50XG4gICAgICByZWZEZXRhaWxzLmluZGlyZWN0ID0gaW5kaXJlY3Q7XG5cbiAgICAgIC8vIE9ubHkgcHJvY2VzcyBub24tY2lyY3VsYXIgcmVmZXJlbmNlcyBmdXJ0aGVyXG4gICAgICBpZiAocGFyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGlmIChyZW1vdGVUeXBlcy5pbmRleE9mKHJlZkRldGFpbHMudHlwZSkgPiAtMSkge1xuICAgICAgICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KGxvY2F0aW9uLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzU3ViRG9jdW1lbnQoJ3JlbW90ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUeXBlKHJlZkRldGFpbHMudXJpRGV0YWlscy5mcmFnbWVudCwgJ1VuZGVmaW5lZCcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEZyb21QdHIoZGVjb2RlVVJJKHJlZkRldGFpbHMudXJpRGV0YWlscy5mcmFnbWVudCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLmNvbmNhdChsb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFB0cnMuY29uY2F0KHJlZkZ1bGxQdHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxSZWZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpcmVjdCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgcmVmRGV0YWlscy5lcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgcmVmRGV0YWlscy5taXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWZGdWxsUHRyLmluZGV4T2YobG9jYXRpb24gKyAnLycpICE9PSAwICYmIHJlZkZ1bGxQdHIgIT09IGxvY2F0aW9uICYmXG4gICAgICAgICAgICAgIHN1YkRvY1B0ci5pbmRleE9mKGxvY2F0aW9uICsgJy8nKSAhPT0gMCAmJiBzdWJEb2NQdHIgIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24uaW5kZXhPZihzdWJEb2NQdHIgKyAnLycpICE9PSAwKSB7XG4gICAgICAgICAgICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1N1YkRvY3VtZW50KCdsb2NhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEZyb21QdHIobG9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLmNvbmNhdChsb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFB0cnMuY29uY2F0KHJlZkZ1bGxQdHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxSZWZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpcmVjdCB8fCAobG9jYXRpb24uaW5kZXhPZihzdWJEb2NQdHIgKyAnLycpID09PSAtMSAmJiBsb2NhdGlvbiAhPT0gc3ViRG9jUHRyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWFyayBzZWVuIGFuY2VzdG9ycyBhcyBjaXJjdWxhclxuICAgICAgICBwYXJlbnRQdHJzLnNsaWNlKHBhcmVudEluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRQdHIpIHtcbiAgICAgICAgICBhbGxSZWZzLnJlZnNbcGFyZW50UHRyXS5jaXJjdWxhciA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElkZW50aWZ5IGluZGlyZWN0LCBsb2NhbCBjaXJjdWxhciByZWZlcmVuY2VzIChJc3N1ZSA4MilcbiAgICAgIHZhciBjaXJjdWxhcnMgPSBbXTtcbiAgICAgIHZhciBwcm9jZXNzZWRSZWZQdHJzID0gW107XG4gICAgICB2YXIgcHJvY2Vzc2VkUmVmcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiB3YWxrUmVmcyAocGFyZW50UHRycywgcGFyZW50UmVmcywgcmVmUHRyLCByZWYpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYWxsUmVmcy5yZWZzKS5mb3JFYWNoKGZ1bmN0aW9uIChkUmVmUHRyKSB7XG4gICAgICAgICAgdmFyIGRSZWZEZXRhaWxzID0gYWxsUmVmcy5yZWZzW2RSZWZQdHJdO1xuXG4gICAgICAgICAgLy8gRG8gbm90IHByb2Nlc3MgYWxyZWFkeSBwcm9jZXNzZWQgcmVmZXJlbmNlcyBvciByZWZlcmVuY2VzIHRoYXQgYXJlIG5vdCBhIG5lc3RlZCByZWZlcmVuY2VzXG4gICAgICAgICAgaWYgKHByb2Nlc3NlZFJlZnMuaW5kZXhPZihyZWYpID09PSAtMSAmJiBwcm9jZXNzZWRSZWZQdHJzLmluZGV4T2YocmVmUHRyKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgY2lyY3VsYXJzLmluZGV4T2YocmVmKSA9PT0gLTEgJiYgZFJlZlB0ciAhPT0gcmVmUHRyICYmIGRSZWZQdHIuaW5kZXhPZihyZWYgKyAnLycpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50UmVmcy5pbmRleE9mKHJlZikgPiAtMSkge1xuICAgICAgICAgICAgICBwYXJlbnRSZWZzLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFJlZikge1xuICAgICAgICAgICAgICAgIGlmIChjaXJjdWxhcnMuaW5kZXhPZihyZWYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY2lyY3VsYXJzLnB1c2gocGFyZW50UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2Fsa1JlZnMocGFyZW50UHRycy5jb25jYXQocmVmUHRyKSwgcGFyZW50UmVmcy5jb25jYXQocmVmKSwgZFJlZlB0ciwgZFJlZkRldGFpbHMudXJpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvY2Vzc2VkUmVmUHRycy5wdXNoKHJlZlB0cik7XG4gICAgICAgICAgICBwcm9jZXNzZWRSZWZzLnB1c2gocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyhhbGxSZWZzLnJlZnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZlB0cikge1xuICAgICAgICB2YXIgcmVmRGV0YWlscyA9IGFsbFJlZnMucmVmc1tyZWZQdHJdO1xuXG4gICAgICAgIC8vIE9ubHkgcHJvY2VzcyBsb2NhbCwgbm9uLWNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKHJlZkRldGFpbHMudHlwZSA9PT0gJ2xvY2FsJyAmJiAhcmVmRGV0YWlscy5jaXJjdWxhciAmJiBjaXJjdWxhcnMuaW5kZXhPZihyZWZEZXRhaWxzLnVyaSkgPT09IC0xKSB7XG4gICAgICAgICAgd2Fsa1JlZnMoW10sIFtdLCByZWZQdHIsIHJlZkRldGFpbHMudXJpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5rZXlzKGFsbFJlZnMucmVmcykuZm9yRWFjaChmdW5jdGlvbiAocmVmUHRyKSB7XG4gICAgICAgIHZhciByZWZEZXRhaWxzID0gYWxsUmVmcy5yZWZzW3JlZlB0cl07XG5cbiAgICAgICAgaWYgKGNpcmN1bGFycy5pbmRleE9mKHJlZkRldGFpbHMudXJpKSA+IC0xKSB7XG4gICAgICAgICAgcmVmRGV0YWlscy5jaXJjdWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFsbFJlZnM7XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG5mdW5jdGlvbiBmaW5kVmFsdWUgKG9iaiwgcGF0aCkge1xuICB2YXIgdmFsdWUgPSBvYmo7XG5cbiAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICBzZWcgPSBkZWNvZGVVUkkoc2VnKTtcblxuICAgIGlmIChzZWcgaW4gdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbc2VnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0pTT04gUG9pbnRlciBwb2ludHMgdG8gbWlzc2luZyBsb2NhdGlvbjogJyArIHBhdGhUb1B0cihwYXRoKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldEV4dHJhUmVmS2V5cyAocmVmKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZWYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSAhPT0gJyRyZWYnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmVHlwZSAocmVmRGV0YWlscykge1xuICB2YXIgdHlwZTtcblxuICAvLyBDb252ZXJ0IHRoZSBVUkkgcmVmZXJlbmNlIHRvIG9uZSBvZiBvdXIgdHlwZXNcbiAgc3dpdGNoIChyZWZEZXRhaWxzLnVyaURldGFpbHMucmVmZXJlbmNlKSB7XG4gIGNhc2UgJ2Fic29sdXRlJzpcbiAgY2FzZSAndXJpJzpcbiAgICB0eXBlID0gJ3JlbW90ZSc7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3NhbWUtZG9jdW1lbnQnOlxuICAgIHR5cGUgPSAnbG9jYWwnO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHR5cGUgPSByZWZEZXRhaWxzLnVyaURldGFpbHMucmVmZXJlbmNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZURvY3VtZW50ICh1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlRW50cnkgPSByZW1vdGVDYWNoZVt1cmxdO1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIGxvYWRlck9wdGlvbnMgPSBjbG9uZShvcHRpb25zLmxvYWRlck9wdGlvbnMgfHwge30pO1xuXG4gIGlmIChpc1R5cGUoY2FjaGVFbnRyeSwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY29udGVudCBwcm9jZXNzb3IsIGRlZmF1bHQgdG8gcHJvY2Vzc2luZyB0aGUgcmF3IHJlc3BvbnNlIGFzIEpTT05cbiAgICBpZiAoaXNUeXBlKGxvYWRlck9wdGlvbnMucHJvY2Vzc0NvbnRlbnQsICdVbmRlZmluZWQnKSkge1xuICAgICAgbG9hZGVyT3B0aW9ucy5wcm9jZXNzQ29udGVudCA9IGZ1bmN0aW9uIChyZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgSlNPTi5wYXJzZShyZXMudGV4dCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIHJlc291cmNlIHVzaW5nIHBhdGgtbG9hZGVyXG4gICAgYWxsVGFza3MgPSBQYXRoTG9hZGVyLmxvYWQoZGVjb2RlVVJJKHVybCksIGxvYWRlck9wdGlvbnMpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjYWNoZVxuICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmVtb3RlQ2FjaGVbdXJsXSA9IHtcbiAgICAgICAgICB2YWx1ZTogcmVzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZW1vdGVDYWNoZVt1cmxdID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCB2ZXJzaW9uXG4gICAgYWxsVGFza3MgPSBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LnZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgY2xvbmVkIHZlcnNpb24gdG8gYXZvaWQgdXBkYXRpbmcgdGhlIGNhY2hlXG4gIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIGNsb25lKHJlcyk7XG4gIH0pO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuZnVuY3Rpb24gaXNSZWZMaWtlIChvYmosIHRocm93V2l0aERldGFpbHMpIHtcbiAgdmFyIHJlZkxpa2UgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgaWYgKCFpc1R5cGUob2JqLCAnT2JqZWN0JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb2JqIGlzIG5vdCBhbiBPYmplY3QnKTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUob2JqLiRyZWYsICdTdHJpbmcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmouJHJlZiBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0aHJvd1dpdGhEZXRhaWxzKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmVmTGlrZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJlZkxpa2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAob2JqLCB0eXBlKSB7XG4gIC8vIEEgUGhhbnRvbUpTIGJ1ZyAoaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE3MjIpIHByb2hpYml0cyB1cyBmcm9tIHVzaW5nIHRoZSBzYW1lIGFwcHJvYWNoIGZvclxuICAvLyB1bmRlZmluZWQgY2hlY2tpbmcgdGhhdCB3ZSB1c2UgZm9yIG90aGVyIHR5cGVzLlxuICBpZiAodHlwZSA9PT0gJ1VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUmVmRmlsdGVyIChvcHRpb25zKSB7XG4gIHZhciByZWZGaWx0ZXI7XG4gIHZhciB2YWxpZFR5cGVzO1xuXG4gIGlmIChpc1R5cGUob3B0aW9ucy5maWx0ZXIsICdBcnJheScpIHx8IGlzVHlwZShvcHRpb25zLmZpbHRlciwgJ1N0cmluZycpKSB7XG4gICAgdmFsaWRUeXBlcyA9IGlzVHlwZShvcHRpb25zLmZpbHRlciwgJ1N0cmluZycpID8gW29wdGlvbnMuZmlsdGVyXSA6IG9wdGlvbnMuZmlsdGVyO1xuICAgIHJlZkZpbHRlciA9IGZ1bmN0aW9uIChyZWZEZXRhaWxzKSB7XG4gICAgICAvLyBDaGVjayB0aGUgZXhhY3QgdHlwZSBvciBmb3IgaW52YWxpZCBVUklzLCBjaGVjayBpdHMgb3JpZ2luYWwgdHlwZVxuICAgICAgcmV0dXJuIHZhbGlkVHlwZXMuaW5kZXhPZihyZWZEZXRhaWxzLnR5cGUpID4gLTEgfHwgdmFsaWRUeXBlcy5pbmRleE9mKGdldFJlZlR5cGUocmVmRGV0YWlscykpID4gLTE7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1R5cGUob3B0aW9ucy5maWx0ZXIsICdGdW5jdGlvbicpKSB7XG4gICAgcmVmRmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gIH0gZWxzZSBpZiAoaXNUeXBlKG9wdGlvbnMuZmlsdGVyLCAnVW5kZWZpbmVkJykpIHtcbiAgICByZWZGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWZEZXRhaWxzLCBwYXRoKSB7XG4gICAgcmV0dXJuIChyZWZEZXRhaWxzLnR5cGUgIT09ICdpbnZhbGlkJyB8fCBvcHRpb25zLmluY2x1ZGVJbnZhbGlkID09PSB0cnVlKSAmJiByZWZGaWx0ZXIocmVmRGV0YWlscywgcGF0aCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VTdWJEb2NQYXRoIChvcHRpb25zKSB7XG4gIHZhciBzdWJEb2NQYXRoO1xuXG4gIGlmIChpc1R5cGUob3B0aW9ucy5zdWJEb2NQYXRoLCAnQXJyYXknKSkge1xuICAgIHN1YkRvY1BhdGggPSBvcHRpb25zLnN1YkRvY1BhdGg7XG4gIH0gZWxzZSBpZiAoaXNUeXBlKG9wdGlvbnMuc3ViRG9jUGF0aCwgJ1N0cmluZycpKSB7XG4gICAgc3ViRG9jUGF0aCA9IHBhdGhGcm9tUHRyKG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gIH0gZWxzZSBpZiAoaXNUeXBlKG9wdGlvbnMuc3ViRG9jUGF0aCwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgc3ViRG9jUGF0aCA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHN1YkRvY1BhdGg7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVVJJICh1cmkpIHtcbiAgLy8gV2UgZGVjb2RlIGZpcnN0IHRvIGF2b2lkIGRvdWJseSBlbmNvZGluZ1xuICByZXR1cm4gVVJJLnBhcnNlKGVuY29kZVVSSShkZWNvZGVVUkkodXJpKSkpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSAob2JqLCByZWZQYXRoLCB2YWx1ZSkge1xuICBmaW5kVmFsdWUob2JqLCByZWZQYXRoLnNsaWNlKDAsIHJlZlBhdGgubGVuZ3RoIC0gMSkpW2RlY29kZVVSSShyZWZQYXRoW3JlZlBhdGgubGVuZ3RoIC0gMV0pXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB3YWxrIChhbmNlc3RvcnMsIG5vZGUsIHBhdGgsIGZuKSB7XG4gIHZhciBwcm9jZXNzQ2hpbGRyZW4gPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHdhbGtJdGVtIChpdGVtLCBzZWdtZW50KSB7XG4gICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgIHdhbGsoYW5jZXN0b3JzLCBpdGVtLCBwYXRoLCBmbik7XG4gICAgcGF0aC5wb3AoKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGl0ZXJhdGVlXG4gIGlmIChpc1R5cGUoZm4sICdGdW5jdGlvbicpKSB7XG4gICAgcHJvY2Vzc0NoaWxkcmVuID0gZm4oYW5jZXN0b3JzLCBub2RlLCBwYXRoKTtcbiAgfVxuXG4gIC8vIFdlIGRvIG5vdCBwcm9jZXNzIGNpcmN1bGFyIG9iamVjdHMgYWdhaW5cbiAgaWYgKGFuY2VzdG9ycy5pbmRleE9mKG5vZGUpID09PSAtMSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKHByb2Nlc3NDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChpc1R5cGUobm9kZSwgJ0FycmF5JykpIHtcbiAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXIsIGluZGV4KSB7XG4gICAgICAgICAgd2Fsa0l0ZW0obWVtYmVyLCBpbmRleC50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVHlwZShub2RlLCAnT2JqZWN0JykpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgd2Fsa0l0ZW0obm9kZVtrZXldLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhbmNlc3RvcnMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyAob3B0aW9ucywgb2JqKSB7XG4gIGlmIChpc1R5cGUob3B0aW9ucywgJ1VuZGVmaW5lZCcpKSB7XG4gICAgLy8gRGVmYXVsdCB0byBhbiBlbXB0eSBvcHRpb25zIG9iamVjdFxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9uZSB0aGUgb3B0aW9ucyBzbyB3ZSBkbyBub3QgYWx0ZXIgdGhlIG9uZXMgcGFzc2VkIGluXG4gICAgb3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFpc1R5cGUob3B0aW9ucywgJ09iamVjdCcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIE9iamVjdCcpO1xuICB9IGVsc2UgaWYgKCFpc1R5cGUob3B0aW9ucy5maWx0ZXIsICdVbmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICFpc1R5cGUob3B0aW9ucy5maWx0ZXIsICdBcnJheScpICYmXG4gICAgICAgICAgICAgIWlzVHlwZShvcHRpb25zLmZpbHRlciwgJ0Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgICAhaXNUeXBlKG9wdGlvbnMuZmlsdGVyLCAnU3RyaW5nJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmZpbHRlciBtdXN0IGJlIGFuIEFycmF5LCBhIEZ1bmN0aW9uIG9mIGEgU3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoIWlzVHlwZShvcHRpb25zLmluY2x1ZGVJbnZhbGlkLCAnVW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAhaXNUeXBlKG9wdGlvbnMuaW5jbHVkZUludmFsaWQsICdCb29sZWFuJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmluY2x1ZGVJbnZhbGlkIG11c3QgYmUgYSBCb29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoIWlzVHlwZShvcHRpb25zLnJlZlByZVByb2Nlc3NvciwgJ1VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgIWlzVHlwZShvcHRpb25zLnJlZlByZVByb2Nlc3NvciwgJ0Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnJlZlByZVByb2Nlc3NvciBtdXN0IGJlIGEgRnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmICghaXNUeXBlKG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvciwgJ1VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgIWlzVHlwZShvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IsICdGdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5yZWZQb3N0UHJvY2Vzc29yIG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKCFpc1R5cGUob3B0aW9ucy5zdWJEb2NQYXRoLCAnVW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAhaXNUeXBlKG9wdGlvbnMuc3ViRG9jUGF0aCwgJ0FycmF5JykgJiZcbiAgICAgICAgICAgICAhaXNQdHIob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIC8vIElmIGEgcG9pbnRlciBpcyBwcm92aWRlZCwgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QgdGhlIHByb3BlciB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5zdWJEb2NQYXRoIG11c3QgYmUgYW4gQXJyYXkgb2YgcGF0aCBzZWdtZW50cyBvciBhIHZhbGlkIEpTT04gUG9pbnRlcicpO1xuICB9XG5cbiAgb3B0aW9ucy5maWx0ZXIgPSBtYWtlUmVmRmlsdGVyKG9wdGlvbnMpO1xuXG4gIC8vIFNldCB0aGUgc3ViRG9jUGF0aCB0byBhdm9pZCBldmVyeW9uZSBlbHNlIGhhdmluZyB0byBjb21wdXRlIGl0XG4gIG9wdGlvbnMuc3ViRG9jUGF0aCA9IG1ha2VTdWJEb2NQYXRoKG9wdGlvbnMpO1xuXG4gIGlmICghaXNUeXBlKG9iaiwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZpbmRWYWx1ZShvYmosIG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ0pTT04gUG9pbnRlcicsICdvcHRpb25zLnN1YkRvY1BhdGgnKTtcblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKiBNb2R1bGUgTWVtYmVycyAqL1xuXG4vKlxuICogRWFjaCBvZiB0aGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZWZpbmVkIGFzIGZ1bmN0aW9uIHN0YXRlbWVudHMgYW5kICp0aGVuKiBleHBvcnRlZCBpbiB0d28gc3RlcHMgaW5zdGVhZCBvZiBvbmUgZHVlXG4gKiB0byBhIGJ1ZyBpbiBqc2RvYyAoaHR0cHM6Ly9naXRodWIuY29tL2pzZG9jMm1kL2pzZG9jLXBhcnNlL2lzc3Vlcy8xOCkgdGhhdCBjYXVzZXMgb3VyIGRvY3VtZW50YXRpb24gdG8gYmVcbiAqIGdlbmVyYXRlZCBpbXByb3Blcmx5LiAgVGhlIGltcGFjdCB0byB0aGUgdXNlciBpcyBzaWduaWZpY2FudCBlbm91Z2ggZm9yIHVzIHRvIHdhcnJhbnQgd29ya2luZyBhcm91bmQgaXQgdW50aWwgdGhpc1xuICogaXMgZml4ZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB1c2VkIGZvciB2YXJpb3VzIEpzb25SZWZzIEFQSXMuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gSnNvblJlZnNPcHRpb25zXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118ZnVuY3Rpb259IFtmaWx0ZXI9ZnVuY3Rpb24gKCkge3JldHVybiB0cnVlO31dIC0gVGhlIGZpbHRlciB0byB1c2Ugd2hlbiBnYXRoZXJpbmcgSlNPTlxuICogUmVmZXJlbmNlcyAqKElmIHRoaXMgdmFsdWUgaXMgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZSB2YWx1ZShzKSBhcmUgZXhwZWN0ZWQgdG8gYmUgdGhlIGB0eXBlKHMpYFxuICogeW91IGFyZSBpbnRlcmVzdGVkIGluIGNvbGxlY3RpbmcgYXMgZGVzY3JpYmVkIGluIHtAbGluayBtb2R1bGU6SnNvblJlZnMuZ2V0UmVmRGV0YWlsc30uICBJZiBpdCBpcyBhIGZ1bmN0aW9uLCBpdCBpc1xuICogZXhwZWN0ZWQgdGhhdCB0aGUgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIHtAbGluayBtb2R1bGU6SnNvblJlZnN+UmVmRGV0YWlsc0ZpbHRlcn0uKSpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZhbGlkPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgaW52YWxpZCBKU09OIFJlZmVyZW5jZSBkZXRhaWxzICooVGhpcyB3aWxsIG1ha2VcbiAqIGl0IHNvIHRoYXQgb2JqZWN0cyB0aGF0IGFyZSBsaWtlIEpTT04gUmVmZXJlbmNlIG9iamVjdHMsIGFzIGluIHRoZXkgYXJlIGFuIGBPYmplY3RgIGFuZCB0aGUgaGF2ZSBhIGAkcmVmYCBwcm9wZXJ0eSxcbiAqIGJ1dCBmYWlsIHZhbGlkYXRpb24gd2lsbCBiZSBpbmNsdWRlZC4gIFRoaXMgaXMgdmVyeSB1c2VmdWwgZm9yIHdoZW4geW91IHdhbnQgdG8ga25vdyBpZiB5b3UgaGF2ZSBpbnZhbGlkIEpTT05cbiAqIFJlZmVyZW5jZSBkZWZpbml0aW9ucy4gIFRoaXMgd2lsbCBub3QgbWVhbiB0aGF0IEFQSXMgd2lsbCBwcm9jZXNzIGludmFsaWQgSlNPTiBSZWZlcmVuY2VzIGJ1dCB0aGUgcmVhc29ucyBhcyB0byB3aHlcbiAqIHRoZSBKU09OIFJlZmVyZW5jZXMgYXJlIGludmFsaWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuZWQgbWV0YWRhdGEuKSpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbbG9hZGVyT3B0aW9uc10gLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3doaXRsb2NramMvcGF0aC1sb2FkZXIvYmxvYi9tYXN0ZXIvZG9jcy9BUEkubWQjbW9kdWxlX1BhdGhMb2FkZXIubG9hZHxQYXRoTG9hZGVyfmxvYWR9XG4gKiBAcGFyYW0ge21vZHVsZTpKc29uUmVmc35SZWZQcmVQcm9jZXNzb3J9IFtyZWZQcmVQcm9jZXNzb3JdIC0gVGhlIGNhbGxiYWNrIHVzZWQgdG8gcHJlLXByb2Nlc3MgYSBKU09OIFJlZmVyZW5jZSBsaWtlXG4gKiBvYmplY3QgKihUaGlzIGlzIGNhbGxlZCBwcmlvciB0byB2YWxpZGF0aW5nIHRoZSBKU09OIFJlZmVyZW5jZSBsaWtlIG9iamVjdCBhbmQgZ2V0dGluZyBpdHMgZGV0YWlscykqXG4gKiBAcGFyYW0ge21vZHVsZTpKc29uUmVmc35SZWZQb3N0UHJvY2Vzc29yfSBbcmVmUG9zdFByb2Nlc3Nvcl0gLSBUaGUgY2FsbGJhY2sgdXNlZCB0byBwb3N0LXByb2Nlc3MgdGhlIEpTT04gUmVmZXJlbmNlXG4gKiBtZXRhZGF0YSAqKFRoaXMgaXMgY2FsbGVkIHByaW9yIGZpbHRlcmluZyB0aGUgcmVmZXJlbmNlcykqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVsYXRpdmVCYXNlXSAtIFRoZSBiYXNlIGxvY2F0aW9uIHRvIHVzZSB3aGVuIHJlc29sdmluZyByZWxhdGl2ZSByZWZlcmVuY2VzICooT25seSB1c2VmdWxcbiAqIGZvciBBUElzIHRoYXQgZG8gcmVtb3RlIHJlZmVyZW5jZSByZXNvbHV0aW9uLiAgSWYgdGhpcyB2YWx1ZSBpcyBub3QgZGVmaW5lZCxcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vd2hpdGxvY2tqYy9wYXRoLWxvYWRlcnxwYXRoLWxvYWRlcn0gd2lsbCB1c2UgYHdpbmRvdy5sb2NhdGlvbi5ocmVmYCBmb3IgdGhlIGJyb3dzZXIgYW5kXG4gKiBgcHJvY2Vzcy5jd2QoKWAgZm9yIE5vZGUuanMuKSpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbb3B0aW9ucy5zdWJEb2NQYXRoPVtdXSAtIFRoZSBKU09OIFBvaW50ZXIgb3IgYXJyYXkgb2YgcGF0aCBzZWdtZW50cyB0byB0aGUgc3ViIGRvY3VtZW50XG4gKiBsb2NhdGlvbiB0byBzZWFyY2ggZnJvbVxuICovXG5cbi8qKlxuICogU2ltcGxlIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIG91dCBKU09OIFJlZmVyZW5jZXMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBSZWZEZXRhaWxzRmlsdGVyXG4gKlxuICogQHBhcmFtIHttb2R1bGU6SnNvblJlZnN+VW5yZXNvbHZlZFJlZkRldGFpbHN9IHJlZkRldGFpbHMgLSBUaGUgSlNPTiBSZWZlcmVuY2UgZGV0YWlscyB0byB0ZXN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIEpTT04gUmVmZXJlbmNlXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIEpTT04gUmVmZXJlbmNlIHNob3VsZCBiZSBmaWx0ZXJlZCAqKG91dCkqIG9yIG5vdFxuICovXG5cbi8qKlxuICogU2ltcGxlIGZ1bmN0aW9uIHVzZWQgdG8gcHJlLXByb2Nlc3MgYSBKU09OIFJlZmVyZW5jZSBsaWtlIG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFJlZlByZVByb2Nlc3NvclxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgSlNPTiBSZWZlcmVuY2UgbGlrZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgSlNPTiBSZWZlcmVuY2UgbGlrZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgcHJvY2Vzc2VkIEpTT04gUmVmZXJlbmNlIGxpa2Ugb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBTaW1wbGUgZnVuY3Rpb24gdXNlZCB0byBwb3N0LXByb2Nlc3MgYSBKU09OIFJlZmVyZW5jZSBkZXRhaWxzLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gUmVmUG9zdFByb2Nlc3NvclxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOkpzb25SZWZzflVucmVzb2x2ZWRSZWZEZXRhaWxzfSByZWZEZXRhaWxzIC0gVGhlIEpTT04gUmVmZXJlbmNlIGRldGFpbHMgdG8gdGVzdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBKU09OIFJlZmVyZW5jZVxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBwcm9jZXNzZWQgSlNPTiBSZWZlcmVuY2UgZGV0YWlscyBvYmplY3RcbiAqL1xuXG4vKipcbiAqIERldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdmVkIEpTT04gUmVmZXJlbmNlcy5cbiAqXG4gKiBAdHlwZWRlZiB7bW9kdWxlOkpzb25SZWZzflVucmVzb2x2ZWRSZWZEZXRhaWxzfSBSZXNvbHZlZFJlZkRldGFpbHNcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaXJjdWxhcl0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgSlNPTiBSZWZlcmVuY2UgaXMgY2lyY3VsYXIgKihXaWxsIG5vdCBiZSBzZXQgaWYgdGhlIEpTT05cbiAqIFJlZmVyZW5jZSBpcyBub3QgY2lyY3VsYXIpKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWlzc2luZ10gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVmZXJlbmNlZCB2YWx1ZSB3YXMgbWlzc2luZyBvciBub3QgKihXaWxsIG5vdCBiZSBzZXQgaWYgdGhlXG4gKiByZWZlcmVuY2VkIHZhbHVlIGlzIG5vdCBtaXNzaW5nKSpcbiAqIEBwcm9wZXJ0eSB7Kn0gW3ZhbHVlXSAtIFRoZSByZWZlcmVuY2VkIHZhbHVlICooV2lsbCBub3QgYmUgc2V0IGlmIHRoZSByZWZlcmVuY2VkIHZhbHVlIGlzIG1pc3NpbmcpKlxuICovXG5cbi8qKlxuICogVGhlIHJlc3VsdHMgb2YgcmVzb2x2aW5nIHRoZSBKU09OIFJlZmVyZW5jZXMgb2YgYW4gYXJyYXkvb2JqZWN0LlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlc29sdmVkUmVmc1Jlc3VsdHNcbiAqXG4gKiBAcHJvcGVydHkge21vZHVsZTpKc29uUmVmc35SZXNvbHZlZFJlZkRldGFpbHN9IHJlZnMgLSBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgSlNPTiBQb2ludGVycyAqKGZyYWdtZW50IHZlcnNpb24pKlxuICogdG8gd2hlcmUgdGhlIEpTT04gUmVmZXJlbmNlIGlzIGRlZmluZWQgYW5kIHdob3NlIHZhbHVlcyBhcmUge0BsaW5rIG1vZHVsZTpKc29uUmVmc35SZXNvbHZlZFJlZkRldGFpbHN9XG4gKiBAcHJvcGVydHkge29iamVjdH0gcmVzb2x2ZWQgLSBUaGUgYXJyYXkvb2JqZWN0IHdpdGggaXRzIEpTT04gUmVmZXJlbmNlcyBmdWxseSByZXNvbHZlZFxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJldHJpZXZlZCBkb2N1bWVudCBhbmQgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgaXRzIEpTT04gUmVmZXJlbmNlcy5cbiAqXG4gKiBAdHlwZWRlZiB7bW9kdWxlOkpzb25SZWZzflJlc29sdmVkUmVmc1Jlc3VsdHN9IFJldHJpZXZlZFJlZnNSZXN1bHRzXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IHZhbHVlIC0gVGhlIHJldHJpZXZlZCBkb2N1bWVudFxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJldHJpZXZlZCBkb2N1bWVudCwgdGhlIGRvY3VtZW50IHdpdGggaXRzIHJlZmVyZW5jZXMgcmVzb2x2ZWQgYW5kICBkZXRhaWxlZCBpbmZvcm1hdGlvblxuICogYWJvdXQgaXRzIEpTT04gUmVmZXJlbmNlcy5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZXRyaWV2ZWRSZXNvbHZlZFJlZnNSZXN1bHRzXG4gKlxuICogQHByb3BlcnR5IHttb2R1bGU6SnNvblJlZnN+VW5yZXNvbHZlZFJlZkRldGFpbHN9IHJlZnMgLSBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgSlNPTiBQb2ludGVycyAqKGZyYWdtZW50IHZlcnNpb24pKlxuICogdG8gd2hlcmUgdGhlIEpTT04gUmVmZXJlbmNlIGlzIGRlZmluZWQgYW5kIHdob3NlIHZhbHVlcyBhcmUge0BsaW5rIG1vZHVsZTpKc29uUmVmc35VbnJlc29sdmVkUmVmRGV0YWlsc31cbiAqIEBwcm9wZXJ0eSB7UmVzb2x2ZWRSZWZzUmVzdWx0c30gLSBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgSlNPTiBQb2ludGVycyAqKGZyYWdtZW50IHZlcnNpb24pKlxuICogdG8gd2hlcmUgdGhlIEpTT04gUmVmZXJlbmNlIGlzIGRlZmluZWQgYW5kIHdob3NlIHZhbHVlcyBhcmUge0BsaW5rIG1vZHVsZTpKc29uUmVmc35SZXNvbHZlZFJlZkRldGFpbHN9XG4gKiBAcHJvcGVydHkge29iamVjdH0gdmFsdWUgLSBUaGUgcmV0cmlldmVkIGRvY3VtZW50XG4gKi9cblxuLyoqXG4gKiBEZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB1bnJlc29sdmVkIEpTT04gUmVmZXJlbmNlcy5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBVbnJlc29sdmVkUmVmRGV0YWlsc1xuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkZWYgLSBUaGUgSlNPTiBSZWZlcmVuY2UgZGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvcl0gLSBUaGUgZXJyb3IgaW5mb3JtYXRpb24gZm9yIGludmFsaWQgSlNPTiBSZWZlcmVuY2UgZGVmaW5pdGlvbiAqKE9ubHkgcHJlc2VudCB3aGVuIHRoZVxuICogSlNPTiBSZWZlcmVuY2UgZGVmaW5pdGlvbiBpcyBpbnZhbGlkIG9yIHRoZXJlIHdhcyBhIHByb2JsZW0gcmV0cmlldmluZyBhIHJlbW90ZSByZWZlcmVuY2UgZHVyaW5nIHJlc29sdXRpb24pKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVyaSAtIFRoZSBVUkkgcG9ydGlvbiBvZiB0aGUgSlNPTiBSZWZlcmVuY2VcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB1cmlEZXRhaWxzIC0gRGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFVSSSBhcyBwcm92aWRlZCBieVxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzfFVSSS5wYXJzZX0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSBKU09OIFJlZmVyZW5jZSB0eXBlICooVGhpcyB2YWx1ZSBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6IGBpbnZhbGlkYCwgYGxvY2FsYCxcbiAqIGByZWxhdGl2ZWAgb3IgYHJlbW90ZWAuKSpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbd2FybmluZ10gLSBUaGUgd2FybmluZyBpbmZvcm1hdGlvbiAqKE9ubHkgcHJlc2VudCB3aGVuIHRoZSBKU09OIFJlZmVyZW5jZSBkZWZpbml0aW9uIHByb2R1Y2VzIGFcbiAqIHdhcm5pbmcpKlxuICovXG5cbi8qKlxuICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBjYWNoZSBvZiByZW1vdGUgZG9jdW1lbnRzLCByZWZlcmVuY2UgZGV0YWlscywgZXRjLlxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMuY2xlYXJDYWNoZVxuICovXG5mdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgcmVtb3RlQ2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIGFuZCBkZWNvZGVzIHRoZSBKU09OIFBvaW50ZXIgdG9rZW5zIGluIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHMgd2l0aCB0aGVpciBKU09OIFBvaW50ZXIgdG9rZW5zIGRlY29kZWRcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHBhdGggaXMgbm90IGFuIGBBcnJheWBcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMSNzZWN0aW9uLTN9XG4gKlxuICogQGFsaWFzIG1vZHVsZTpKc29uUmVmcy5kZWNvZGVQYXRoXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhdGggKHBhdGgpIHtcbiAgaWYgKCFpc1R5cGUocGF0aCwgJ0FycmF5JykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgaWYgKCFpc1R5cGUoc2VnLCAnU3RyaW5nJykpIHtcbiAgICAgIHNlZyA9IEpTT04uc3RyaW5naWZ5KHNlZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZVVSSShzZWcucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cyBhbmQgZW5jb2RlcyB0aGUgc3BlY2lhbCBKU09OIFBvaW50ZXIgY2hhcmFjdGVycyBpbiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggLSBUaGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50c1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBlbmNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMuZW5jb2RlUGF0aFxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXRoIChwYXRoKSB7XG4gIGlmICghaXNUeXBlKHBhdGgsICdBcnJheScpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgIGlmICghaXNUeXBlKHNlZywgJ1N0cmluZycpKSB7XG4gICAgICBzZWcgPSBKU09OLnN0cmluZ2lmeShzZWcpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWcucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgYXJyYXkvb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvYmogLSBUaGUgc3RydWN0dXJlIHRvIGZpbmQgSlNPTiBSZWZlcmVuY2VzIHdpdGhpblxuICogQHBhcmFtIHttb2R1bGU6SnNvblJlZnN+SnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBKU09OIFBvaW50ZXJzICooZnJhZ21lbnQgdmVyc2lvbikqIHRvIHdoZXJlIHRoZSBKU09OIFJlZmVyZW5jZSBpcyBkZWZpbmVkXG4gKiBhbmQgd2hvc2UgdmFsdWVzIGFyZSB7QGxpbmsgbW9kdWxlOkpzb25SZWZzflVucmVzb2x2ZWRSZWZEZXRhaWxzfS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiB0aGUgaW5wdXQgYXJndW1lbnRzIGZhaWwgdmFsaWRhdGlvbiBvciBpZiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvblxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMuZmluZFJlZnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRmluZGluZyBhbGwgdmFsaWQgcmVmZXJlbmNlc1xuICogdmFyIGFsbFJlZnMgPSBKc29uUmVmcy5maW5kUmVmcyhvYmopO1xuICogLy8gRmluZGluZyBhbGwgcmVtb3RlIHJlZmVyZW5jZXNcbiAqIHZhciByZW1vdGVSZWZzID0gSnNvblJlZnMuZmluZFJlZnMob2JqLCB7ZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddfSk7XG4gKiAvLyBGaW5kaW5nIGFsbCBpbnZhbGlkIHJlZmVyZW5jZXNcbiAqIHZhciBpbnZhbGlkUmVmcyA9IEpzb25SZWZzLmZpbmRSZWZzKG9iaiwge2ZpbHRlcjogJ2ludmFsaWQnLCBpbmNsdWRlSW52YWxpZDogdHJ1ZX0pO1xuICovXG5mdW5jdGlvbiBmaW5kUmVmcyAob2JqLCBvcHRpb25zKSB7XG4gIHZhciByZWZzID0ge307XG5cbiAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gIGlmICghaXNUeXBlKG9iaiwgJ0FycmF5JykgJiYgIWlzVHlwZShvYmosICdPYmplY3QnKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iaiBtdXN0IGJlIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIG9iaik7XG5cbiAgLy8gV2FsayB0aGUgZG9jdW1lbnQgKG9yIHN1YiBkb2N1bWVudCkgYW5kIGZpbmQgYWxsIEpTT04gUmVmZXJlbmNlc1xuICB3YWxrKGZpbmRBbmNlc3RvcnMob2JqLCBvcHRpb25zLnN1YkRvY1BhdGgpLFxuICAgICAgIGZpbmRWYWx1ZShvYmosIG9wdGlvbnMuc3ViRG9jUGF0aCksXG4gICAgICAgY2xvbmUob3B0aW9ucy5zdWJEb2NQYXRoKSxcbiAgICAgICBmdW5jdGlvbiAoYW5jZXN0b3JzLCBub2RlLCBwYXRoKSB7XG4gICAgICAgICB2YXIgcHJvY2Vzc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgIHZhciByZWZEZXRhaWxzO1xuXG4gICAgICAgICBpZiAoaXNSZWZMaWtlKG5vZGUpKSB7XG4gICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBub2RlIHdoZW4gbmVjZXNzYXJ5XG4gICAgICAgICAgIGlmICghaXNUeXBlKG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yLCAnVW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICBub2RlID0gb3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IoY2xvbmUobm9kZSksIHBhdGgpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcmVmRGV0YWlscyA9IGdldFJlZkRldGFpbHMobm9kZSk7XG5cbiAgICAgICAgICAgLy8gUG9zdC1wcm9jZXNzIHRoZSByZWZlcmVuY2UgZGV0YWlsc1xuICAgICAgICAgICBpZiAoIWlzVHlwZShvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IsICdVbmRlZmluZWQnKSkge1xuICAgICAgICAgICAgIHJlZkRldGFpbHMgPSBvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IocmVmRGV0YWlscywgcGF0aCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIocmVmRGV0YWlscywgcGF0aCkpIHtcbiAgICAgICAgICAgICByZWZzW3BhdGhUb1B0cihwYXRoKV0gPSByZWZEZXRhaWxzO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gV2hlbmV2ZXIgYSBKU09OIFJlZmVyZW5jZSBoYXMgZXh0cmEgY2hpbGRyZW4sIGl0cyBjaGlsZHJlbiBzaG91bGQgbm90IGJlIHByb2Nlc3NlZC5cbiAgICAgICAgICAgLy8gICBTZWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBicnlhbi16eXAtanNvbi1yZWYtMDMjc2VjdGlvbi0zXG4gICAgICAgICAgIGlmIChnZXRFeHRyYVJlZktleXMobm9kZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgIHByb2Nlc3NDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRyZW47XG4gICAgICAgfSk7XG5cbiAgcmV0dXJuIHJlZnM7XG59XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBkb2N1bWVudCBhdCB0aGUgcHJvdmlkZWQgbG9jYXRpb24uXG4gKlxuICogVGhpcyBBUEkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBtb2R1bGU6SnNvblJlZnMuZmluZFJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZCB0aGVuXG4gKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgbW9kdWxlOkpzb25SZWZzLmZpbmRSZWZzfSBvbiB0aGUgcmV0cmlldmVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byByZXRyaWV2ZSAqKENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSwganVzdCBtYWtlIHN1cmUgeW91IGxvb2sgYXQgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOkpzb25SZWZzfkpzb25SZWZzT3B0aW9uc3xvcHRpb25zIGRvY3VtZW50YXRpb259IHRvIHNlZSBob3cgcmVsYXRpdmUgcmVmZXJlbmNlcyBhcmUgaGFuZGxlZC4pKlxuICogQHBhcmFtIHttb2R1bGU6SnNvblJlZnN+SnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhIHtAbGluayBtb2R1bGU6SnNvblJlZnN+UmV0cmlldmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW5cbiAqIGBFcnJvcmAgd2hlbiB0aGUgaW5wdXQgYXJndW1lbnRzIGZhaWwgdmFsaWRhdGlvbiwgd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuXG4gKiAgdGhlIGxvY2F0aW9uIGFyZ3VtZW50IHBvaW50cyB0byBhbiB1bmxvYWRhYmxlIHJlc291cmNlXG4gKlxuICogQGFsaWFzIG1vZHVsZTpKc29uUmVmcy5maW5kUmVmc0F0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgdGhhdCBvbmx5IHJlc29sdmVzIHJlZmVyZW5jZXMgd2l0aGluIGEgc3ViIGRvY3VtZW50XG4gKiBKc29uUmVmcy5maW5kUmVmc0F0KCdodHRwOi8vcGV0c3RvcmUuc3dhZ2dlci5pby92Mi9zd2FnZ2VyLmpzb24nLCB7XG4gKiAgICAgc3ViRG9jUGF0aDogJyMvZGVmaW5pdGlvbnMnXG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnZhbHVlOiBUaGUgcmV0cmlldmVkIGRvY3VtZW50XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xuZnVuY3Rpb24gZmluZFJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgICAgaWYgKCFpc1R5cGUobG9jYXRpb24sICdTdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIC8vIENvbWJpbmUgdGhlIGxvY2F0aW9uIGFuZCB0aGUgb3B0aW9uYWwgcmVsYXRpdmUgYmFzZVxuICAgICAgbG9jYXRpb24gPSBjb21iaW5lVVJJcyhvcHRpb25zLnJlbGF0aXZlQmFzZSwgbG9jYXRpb24pO1xuXG4gICAgICByZXR1cm4gZ2V0UmVtb3RlRG9jdW1lbnQobG9jYXRpb24sIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGNhY2hlRW50cnkgPSBjbG9uZShyZW1vdGVDYWNoZVtsb2NhdGlvbl0pO1xuICAgICAgdmFyIGNPcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgICB2YXIgdXJpRGV0YWlscyA9IHBhcnNlVVJJKGxvY2F0aW9uKTtcblxuICAgICAgaWYgKGlzVHlwZShjYWNoZUVudHJ5LnJlZnMsICdVbmRlZmluZWQnKSkge1xuICAgICAgICAvLyBEbyBub3QgZmlsdGVyIGFueSByZWZlcmVuY2VzIHNvIHRoZSBjYWNoZSBpcyBjb21wbGV0ZVxuICAgICAgICBkZWxldGUgY09wdGlvbnMuZmlsdGVyO1xuICAgICAgICBkZWxldGUgY09wdGlvbnMuc3ViRG9jUGF0aDtcblxuICAgICAgICBjT3B0aW9ucy5pbmNsdWRlSW52YWxpZCA9IHRydWU7XG5cbiAgICAgICAgcmVtb3RlQ2FjaGVbbG9jYXRpb25dLnJlZnMgPSBmaW5kUmVmcyhyZXMsIGNPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBmaWx0ZXIgb3B0aW9ucyBiYWNrXG4gICAgICBpZiAoIWlzVHlwZShvcHRpb25zLmZpbHRlciwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGNPcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVHlwZSh1cmlEZXRhaWxzLmZyYWdtZW50LCAnVW5kZWZpbmVkJykpIHtcbiAgICAgICAgY09wdGlvbnMuc3ViRG9jUGF0aCA9IHBhdGhGcm9tUHRyKGRlY29kZVVSSSh1cmlEZXRhaWxzLmZyYWdtZW50KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1R5cGUodXJpRGV0YWlscy5zdWJEb2NQYXRoLCAnVW5kZWZpbmVkJykpIHtcbiAgICAgICAgY09wdGlvbnMuc3ViRG9jUGF0aCA9IG9wdGlvbnMuc3ViRG9jUGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyB3aWxsIHVzZSB0aGUgY2FjaGUgc28gZG9uJ3Qgd29ycnkgYWJvdXQgY2FsbGluZyBpdCB0d2ljZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmczogZmluZFJlZnMocmVzLCBjT3B0aW9ucyksXG4gICAgICAgIHZhbHVlOiByZXNcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgSlNPTiBSZWZlcmVuY2UgZGVmaW5pdGlvblxuICpcbiAqIEByZXR1cm5zIHttb2R1bGU6SnNvblJlZnN+VW5yZXNvbHZlZFJlZkRldGFpbHN9IHRoZSBkZXRhaWxlZCBpbmZvcm1hdGlvblxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMuZ2V0UmVmRGV0YWlsc1xuICovXG5mdW5jdGlvbiBnZXRSZWZEZXRhaWxzIChvYmopIHtcbiAgdmFyIGRldGFpbHMgPSB7XG4gICAgZGVmOiBvYmpcbiAgfTtcbiAgdmFyIGNhY2hlS2V5O1xuICB2YXIgZXh0cmFLZXlzO1xuICB2YXIgdXJpRGV0YWlscztcblxuICB0cnkge1xuICAgIGlmIChpc1JlZkxpa2Uob2JqLCB0cnVlKSkge1xuICAgICAgY2FjaGVLZXkgPSBvYmouJHJlZjtcbiAgICAgIHVyaURldGFpbHMgPSB1cmlEZXRhaWxzQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgICBpZiAoaXNUeXBlKHVyaURldGFpbHMsICdVbmRlZmluZWQnKSkge1xuICAgICAgICB1cmlEZXRhaWxzID0gdXJpRGV0YWlsc0NhY2hlW2NhY2hlS2V5XSA9IHBhcnNlVVJJKGNhY2hlS2V5KTtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscy51cmkgPSBjYWNoZUtleTtcbiAgICAgIGRldGFpbHMudXJpRGV0YWlscyA9IHVyaURldGFpbHM7XG5cbiAgICAgIGlmIChpc1R5cGUodXJpRGV0YWlscy5lcnJvciwgJ1VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGRldGFpbHMudHlwZSA9IGdldFJlZlR5cGUoZGV0YWlscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXRhaWxzLmVycm9yID0gZGV0YWlscy51cmlEZXRhaWxzLmVycm9yO1xuICAgICAgICBkZXRhaWxzLnR5cGUgPSAnaW52YWxpZCc7XG4gICAgICB9XG5cbiAgICAgIC8vIElkZW50aWZ5IHdhcm5pbmdcbiAgICAgIGV4dHJhS2V5cyA9IGdldEV4dHJhUmVmS2V5cyhvYmopO1xuXG4gICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGV0YWlscy53YXJuaW5nID0gJ0V4dHJhIEpTT04gUmVmZXJlbmNlIHByb3BlcnRpZXMgd2lsbCBiZSBpZ25vcmVkOiAnICsgZXh0cmFLZXlzLmpvaW4oJywgJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFpbHMudHlwZSA9ICdpbnZhbGlkJztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRldGFpbHMuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICBkZXRhaWxzLnR5cGUgPSAnaW52YWxpZCc7XG4gIH1cblxuICByZXR1cm4gZGV0YWlscztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBKU09OIFBvaW50ZXIuXG4gKlxuICogQSBzdHJpbmcgaXMgYSBKU09OIFBvaW50ZXIgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBzdHJpbmcgaXMgb2YgdHlwZSBgU3RyaW5nYFxuICogICAqIFRoZSBzdHJpbmcgbXVzdCBiZSBlbXB0eSwgYCNgIG9yIHN0YXJ0IHdpdGggYSBgL2Agb3IgYCMvYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdHIgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQGFsaWFzIG1vZHVsZTpKc29uUmVmcy5pc1B0clxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tM31cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2VwYXJhdGluZyB0aGUgZGlmZmVyZW50IHdheXMgdG8gaW52b2tlIGlzUHRyIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzXG4gKiBpZiAoaXNQdHIoc3RyKSkge1xuICogICAvLyBIYW5kbGUgYSB2YWxpZCBKU09OIFBvaW50ZXJcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIEdldCB0aGUgcmVhc29uIGFzIHRvIHdoeSB0aGUgdmFsdWUgaXMgbm90IGEgSlNPTiBQb2ludGVyIHNvIHlvdSBjYW4gZml4L3JlcG9ydCBpdFxuICogICB0cnkge1xuICogICAgIGlzUHRyKHN0ciwgdHJ1ZSk7XG4gKiAgIH0gY2F0Y2ggKGVycikge1xuICogICAgIC8vIFRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW5zIHRoZSBkZXRhaWxzIGFzIHRvIHdoeSB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgSlNPTiBQb2ludGVyXG4gKiAgIH1cbiAqIH1cbiAqL1xuZnVuY3Rpb24gaXNQdHIgKHB0ciwgdGhyb3dXaXRoRGV0YWlscykge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZmlyc3RDaGFyO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzVHlwZShwdHIsICdTdHJpbmcnKSkge1xuICAgICAgaWYgKHB0ciAhPT0gJycpIHtcbiAgICAgICAgZmlyc3RDaGFyID0gcHRyLmNoYXJBdCgwKTtcblxuICAgICAgICBpZiAoWycjJywgJy8nXS5pbmRleE9mKGZpcnN0Q2hhcikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBzdGFydCB3aXRoIGEgLyBvciAjLycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hhciA9PT0gJyMnICYmIHB0ciAhPT0gJyMnICYmIHB0ci5jaGFyQXQoMSkgIT09ICcvJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHRyIG11c3Qgc3RhcnQgd2l0aCBhIC8gb3IgIy8nKTtcbiAgICAgICAgfSBlbHNlIGlmIChwdHIubWF0Y2goYmFkUHRyVG9rZW5SZWdleCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBoYXMgaW52YWxpZCB0b2tlbihzKScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHRyIGlzIG5vdCBhIFN0cmluZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHRocm93V2l0aERldGFpbHMgPT09IHRydWUpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgYXJndW1lbnQgcmVwcmVzZW50cyBhIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEFuIG9iamVjdCBpcyBhIEpTT04gUmVmZXJlbmNlIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBvYmplY3QgaXMgb2YgdHlwZSBgT2JqZWN0YFxuICogICAqIFRoZSBvYmplY3QgaGFzIGEgYCRyZWZgIHByb3BlcnR5XG4gKiAgICogVGhlIGAkcmVmYCBwcm9wZXJ0eSBpcyBhIHZhbGlkIFVSSSAqKFdlIGRvIG5vdCByZXF1aXJlIDEwMCUgc3RyaWN0IFVSSXMgYW5kIHdpbGwgaGFuZGxlIHVuZXNjYXBlZCBzcGVjaWFsXG4gKiAgICAgY2hhcmFjdGVycy4pKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQGFsaWFzIG1vZHVsZTpKc29uUmVmcy5pc1JlZlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBicnlhbi16eXAtanNvbi1yZWYtMDMjc2VjdGlvbi0zfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXBhcmF0aW5nIHRoZSBkaWZmZXJlbnQgd2F5cyB0byBpbnZva2UgaXNSZWYgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXNcbiAqIGlmIChpc1JlZihvYmopKSB7XG4gKiAgIC8vIEhhbmRsZSBhIHZhbGlkIEpTT04gUmVmZXJlbmNlXG4gKiB9IGVsc2Uge1xuICogICAvLyBHZXQgdGhlIHJlYXNvbiBhcyB0byB3aHkgdGhlIHZhbHVlIGlzIG5vdCBhIEpTT04gUmVmZXJlbmNlIHNvIHlvdSBjYW4gZml4L3JlcG9ydCBpdFxuICogICB0cnkge1xuICogICAgIGlzUmVmKHN0ciwgdHJ1ZSk7XG4gKiAgIH0gY2F0Y2ggKGVycikge1xuICogICAgIC8vIFRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW5zIHRoZSBkZXRhaWxzIGFzIHRvIHdoeSB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgSlNPTiBSZWZlcmVuY2VcbiAqICAgfVxuICogfVxuICovXG5mdW5jdGlvbiBpc1JlZiAob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHJldHVybiBpc1JlZkxpa2Uob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSAmJiBnZXRSZWZEZXRhaWxzKG9iaiwgdGhyb3dXaXRoRGV0YWlscykudHlwZSAhPT0gJ2ludmFsaWQnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cyBmb3IgdGhlIHByb3ZpZGVkIEpTT04gUG9pbnRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHRyIC0gVGhlIEpTT04gUG9pbnRlclxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdGhlIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHByb3ZpZGVkIGBwdHJgIGFyZ3VtZW50IGlzIG5vdCBhIEpTT04gUG9pbnRlclxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMucGF0aEZyb21QdHJcbiAqL1xuZnVuY3Rpb24gcGF0aEZyb21QdHIgKHB0cikge1xuICBpZiAoIWlzUHRyKHB0cikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBtdXN0IGJlIGEgSlNPTiBQb2ludGVyJyk7XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBwdHIuc3BsaXQoJy8nKTtcblxuICAvLyBSZW1vdmUgdGhlIGZpcnN0IHNlZ21lbnRcbiAgc2VnbWVudHMuc2hpZnQoKTtcblxuICByZXR1cm4gZGVjb2RlUGF0aChzZWdtZW50cyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIEpTT04gUG9pbnRlciBmb3IgdGhlIHByb3ZpZGVkIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gKlxuICogKipOb3RlOioqIElmIGEgcGF0aCBzZWdtZW50IGluIGBwYXRoYCBpcyBub3QgYSBgU3RyaW5nYCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gb25lIHVzaW5nIGBKU09OLnN0cmluZ2lmeWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNoUHJlZml4PXRydWVdIC0gV2hldGhlciBvciBub3QgY3JlYXRlIGEgaGFzaC1wcmVmaXhlZCBKU09OIFBvaW50ZXJcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBKU09OIFBvaW50ZXJcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGBwYXRoYCBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXlcbiAqXG4gKiBAYWxpYXMgbW9kdWxlOkpzb25SZWZzLnBhdGhUb1B0clxuICovXG5mdW5jdGlvbiBwYXRoVG9QdHIgKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgaWYgKCFpc1R5cGUocGF0aCwgJ0FycmF5JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG5cbiAgLy8gRW5jb2RlIGVhY2ggc2VnbWVudCBhbmQgcmV0dXJuXG4gIHJldHVybiAoaGFzaFByZWZpeCAhPT0gZmFsc2UgPyAnIycgOiAnJykgKyAocGF0aC5sZW5ndGggPiAwID8gJy8nIDogJycpICsgZW5jb2RlUGF0aChwYXRoKS5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBhcnJheS9vYmplY3QgYW5kIHJlc29sdmVzIHRoZW0uXG4gKlxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IG9iaiAtIFRoZSBzdHJ1Y3R1cmUgdG8gZmluZCBKU09OIFJlZmVyZW5jZXMgd2l0aGluXG4gKiBAcGFyYW0ge21vZHVsZTpKc29uUmVmc35Kc29uUmVmc09wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBKc29uUmVmcyBvcHRpb25zXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGEge0BsaW5rIG1vZHVsZTpKc29uUmVmc35SZXNvbHZlZFJlZnNSZXN1bHRzfSBhbmQgcmVqZWN0cyB3aXRoIGFuXG4gKiBgRXJyb3JgIHdoZW4gdGhlIGlucHV0IGFyZ3VtZW50cyBmYWlsIHZhbGlkYXRpb24sIHdoZW4gYG9wdGlvbnMuc3ViRG9jUGF0aGAgcG9pbnRzIHRvIGFuIGludmFsaWQgbG9jYXRpb24gb3Igd2hlblxuICogIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZSByZXNvdXJjZVxuICpcbiAqIEBhbGlhcyBtb2R1bGU6SnNvblJlZnMucmVzb2x2ZVJlZnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVsYXRpdmUgYW5kIHJlbW90ZSByZWZlcmVuY2VzXG4gKiBKc29uUmVmcy5yZXNvbHZlUmVmcyhzd2FnZ2VyT2JqLCB7XG4gKiAgICAgZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddXG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnJlc29sdmVkOiBUaGUgZG9jdW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSlNPTiBSZWZlcmVuY2VzIHJlc29sdmVkXG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZnMgKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gICAgICBpZiAoIWlzVHlwZShvYmosICdBcnJheScpICYmICFpc1R5cGUob2JqLCAnT2JqZWN0JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqIG11c3QgYmUgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgb2JqKTtcblxuICAgICAgLy8gQ2xvbmUgdGhlIGlucHV0IHNvIHdlIGRvIG5vdCBhbHRlciBpdFxuICAgICAgb2JqID0gY2xvbmUob2JqKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaW5kUmVmc1JlY3Vyc2l2ZShvYmosIG9wdGlvbnMsIFtdLCBbXSwge1xuICAgICAgICBkb2N1bWVudHM6IHt9LFxuICAgICAgICByZWZzOiB7fVxuICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAoYWxsUmVmcykge1xuICAgICAgdmFyIGRlZmVycmVkUmVmcyA9IHt9O1xuICAgICAgdmFyIHJlZnMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gcGF0aFNvcnRlciAocDEsIHAyKSB7XG4gICAgICAgIHJldHVybiBwYXRoRnJvbVB0cihwMSkubGVuZ3RoIC0gcGF0aEZyb21QdHIocDIpLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBhbGwgcmVmZXJlbmNlcyB3aXRoIGEga25vd24gdmFsdWVcbiAgICAgIE9iamVjdC5rZXlzKGFsbFJlZnMucmVmcykuc29ydChwYXRoU29ydGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWZQdHIpIHtcbiAgICAgICAgdmFyIHJlZkRldGFpbHMgPSBhbGxSZWZzLnJlZnNbcmVmUHRyXTtcblxuICAgICAgICAvLyBSZWNvcmQgYWxsIGRpcmVjdCByZWZlcmVuY2VzXG4gICAgICAgIGlmICghcmVmRGV0YWlscy5pbmRpcmVjdCkge1xuICAgICAgICAgIHJlZnNbcmVmUHRyXSA9IHJlZkRldGFpbHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgaGVscGVyIHByb3BlcnR5XG4gICAgICAgIGRlbGV0ZSByZWZEZXRhaWxzLmluZGlyZWN0O1xuXG4gICAgICAgIGlmIChpc1R5cGUocmVmRGV0YWlscy5lcnJvciwgJ1VuZGVmaW5lZCcpICYmIHJlZkRldGFpbHMudHlwZSAhPT0gJ2ludmFsaWQnKSB7XG4gICAgICAgICAgaWYgKGlzVHlwZShyZWZEZXRhaWxzLnZhbHVlLCAnVW5kZWZpbmVkJykgJiYgcmVmRGV0YWlscy5jaXJjdWxhcikge1xuICAgICAgICAgICAgcmVmRGV0YWlscy52YWx1ZSA9IHJlZkRldGFpbHMuZGVmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIGRlZmVyIHByb2Nlc3NpbmcgYWxsIHJlZmVyZW5jZXMgd2l0aG91dCBhIHZhbHVlIHVudGlsIGxhdGVyXG4gICAgICAgICAgaWYgKGlzVHlwZShyZWZEZXRhaWxzLnZhbHVlLCAnVW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGRlZmVycmVkUmVmc1tyZWZQdHJdID0gcmVmRGV0YWlscztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlZlB0ciA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgIG9iaiA9IHJlZkRldGFpbHMudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRWYWx1ZShvYmosIHBhdGhGcm9tUHRyKHJlZlB0ciksIHJlZkRldGFpbHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWxldGUgaGVscGVyIHByb3BlcnR5XG4gICAgICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5hbmNlc3RvclB0cnM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlbGV0ZSBoZWxwZXIgcHJvcGVydHlcbiAgICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5hbmNlc3RvclB0cnM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXNvbHZlIGFsbCBkZWZlcnJlZCByZWZlcmVuY2VzXG4gICAgICBPYmplY3Qua2V5cyhkZWZlcnJlZFJlZnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZlB0cikge1xuICAgICAgICB2YXIgcmVmRGV0YWlscyA9IGRlZmVycmVkUmVmc1tyZWZQdHJdO1xuXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVzb2x2ZSB0aGUgdmFsdWUgYWdhaW5zdCBhbGwgaWYgaXRzIGFuY2VzdG9ycyBpbiBvcmRlclxuICAgICAgICByZWZEZXRhaWxzLmFuY2VzdG9yUHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhbmNlc3RvclB0ciwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaXNUeXBlKHJlZkRldGFpbHMudmFsdWUsICdVbmRlZmluZWQnKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVmRGV0YWlscy52YWx1ZSA9IGZpbmRWYWx1ZShhbGxSZWZzLmRvY3VtZW50c1thbmNlc3RvclB0cl0sIHBhdGhGcm9tUHRyKHJlZkRldGFpbHMudXJpKSk7XG5cbiAgICAgICAgICAgICAgLy8gRGVsZXRlIGhlbHBlciBwcm9wZXJ0eVxuICAgICAgICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5hbmNlc3RvclB0cnM7XG5cbiAgICAgICAgICAgICAgc2V0VmFsdWUob2JqLCBwYXRoRnJvbVB0cihyZWZQdHIpLCByZWZEZXRhaWxzLnZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHJlZkRldGFpbHMuYW5jZXN0b3JQdHJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZWZEZXRhaWxzLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgcmVmRGV0YWlscy5taXNzaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBoZWxwZXIgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5hbmNlc3RvclB0cnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnM6IHJlZnMsXG4gICAgICAgIHJlc29sdmVkOiBvYmpcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uLlxuICpcbiAqIFRoaXMgQVBJIGlzIGlkZW50aWNhbCB0byB7QGxpbmsgbW9kdWxlOkpzb25SZWZzLnJlc29sdmVSZWZzfSBleGNlcHQgdGhpcyBBUEkgd2lsbCByZXRyaWV2ZSBhIHJlbW90ZSBkb2N1bWVudCBhbmQgdGhlblxuICogcmV0dXJuIHRoZSByZXN1bHQgb2Yge0BsaW5rIG1vZHVsZTpKc29uUmVmcy5yZXNvbHZlUmVmc30gb24gdGhlIHJldHJpZXZlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gcmV0cmlldmUgKihDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIGp1c3QgbWFrZSBzdXJlIHlvdSBsb29rIGF0IHRoZVxuICoge0BsaW5rIG1vZHVsZTpKc29uUmVmc35Kc29uUmVmc09wdGlvbnN8b3B0aW9ucyBkb2N1bWVudGF0aW9ufSB0byBzZWUgaG93IHJlbGF0aXZlIHJlZmVyZW5jZXMgYXJlIGhhbmRsZWQuKSpcbiAqIEBwYXJhbSB7bW9kdWxlOkpzb25SZWZzfkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYSB7QGxpbmsgbW9kdWxlOkpzb25SZWZzflJldHJpZXZlZFJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW5cbiAqIGBFcnJvcmAgd2hlbiB0aGUgaW5wdXQgYXJndW1lbnRzIGZhaWwgdmFsaWRhdGlvbiwgd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuXG4gKiAgdGhlIGxvY2F0aW9uIGFyZ3VtZW50IHBvaW50cyB0byBhbiB1bmxvYWRhYmxlIHJlc291cmNlXG4gKlxuICogQGFsaWFzIG1vZHVsZTpKc29uUmVmcy5yZXNvbHZlUmVmc0F0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgdGhhdCBsb2FkcyBhIEpTT04gZG9jdW1lbnQgKE5vIG9wdGlvbnMubG9hZGVyT3B0aW9ucy5wcm9jZXNzQ29udGVudCByZXF1aXJlZCkgYW5kIHJlc29sdmVzIGFsbCByZWZlcmVuY2VzXG4gKiBKc29uUmVmcy5yZXNvbHZlUmVmc0F0KCcuL3N3YWdnZXIuanNvbicpXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnJlc29sdmVkOiBUaGUgZG9jdW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSlNPTiBSZWZlcmVuY2VzIHJlc29sdmVkXG4gKiAgICAgIC8vIHJlcy52YWx1ZTogVGhlIHJldHJpZXZlZCBkb2N1bWVudFxuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrKTtcbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVSZWZzQXQgKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICAgIGlmICghaXNUeXBlKGxvY2F0aW9uLCAnU3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbG9jYXRpb24gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAvLyBDb21iaW5lIHRoZSBsb2NhdGlvbiBhbmQgdGhlIG9wdGlvbmFsIHJlbGF0aXZlIGJhc2VcbiAgICAgIGxvY2F0aW9uID0gY29tYmluZVVSSXMob3B0aW9ucy5yZWxhdGl2ZUJhc2UsIGxvY2F0aW9uKTtcblxuICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KGxvY2F0aW9uLCBvcHRpb25zKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHZhciBjT3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xuICAgICAgdmFyIHVyaURldGFpbHMgPSBwYXJzZVVSSShsb2NhdGlvbik7XG5cbiAgICAgIC8vIFNldCB0aGUgc3ViIGRvY3VtZW50IHBhdGggaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoIWlzVHlwZSh1cmlEZXRhaWxzLmZyYWdtZW50LCAnVW5kZWZpbmVkJykpIHtcbiAgICAgICAgY09wdGlvbnMuc3ViRG9jUGF0aCA9IHBhdGhGcm9tUHRyKGRlY29kZVVSSSh1cmlEZXRhaWxzLmZyYWdtZW50KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcmVsYXRpdmUgYmFzZSBiYXNlZCBvbiB0aGUgcmV0cmlldmVkIGxvY2F0aW9uXG4gICAgICBjT3B0aW9ucy5yZWxhdGl2ZUJhc2UgPSBwYXRoLmRpcm5hbWUobG9jYXRpb24pO1xuXG4gICAgICByZXR1cm4gcmVzb2x2ZVJlZnMocmVzLCBjT3B0aW9ucylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlczIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmczogcmVzMi5yZWZzLFxuICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlczIucmVzb2x2ZWQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG4vKiBFeHBvcnQgdGhlIG1vZHVsZSBtZW1iZXJzICovXG5tb2R1bGUuZXhwb3J0cy5jbGVhckNhY2hlID0gY2xlYXJDYWNoZTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZVBhdGggPSBkZWNvZGVQYXRoO1xubW9kdWxlLmV4cG9ydHMuZW5jb2RlUGF0aCA9IGVuY29kZVBhdGg7XG5tb2R1bGUuZXhwb3J0cy5maW5kUmVmcyA9IGZpbmRSZWZzO1xubW9kdWxlLmV4cG9ydHMuZmluZFJlZnNBdCA9IGZpbmRSZWZzQXQ7XG5tb2R1bGUuZXhwb3J0cy5nZXRSZWZEZXRhaWxzID0gZ2V0UmVmRGV0YWlscztcbm1vZHVsZS5leHBvcnRzLmlzUHRyID0gaXNQdHI7XG5tb2R1bGUuZXhwb3J0cy5pc1JlZiA9IGlzUmVmO1xubW9kdWxlLmV4cG9ydHMucGF0aEZyb21QdHIgPSBwYXRoRnJvbVB0cjtcbm1vZHVsZS5leHBvcnRzLnBhdGhUb1B0ciA9IHBhdGhUb1B0cjtcbm1vZHVsZS5leHBvcnRzLnJlc29sdmVSZWZzID0gcmVzb2x2ZVJlZnM7XG5tb2R1bGUuZXhwb3J0cy5yZXNvbHZlUmVmc0F0ID0gcmVzb2x2ZVJlZnNBdDtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIi8qISBOYXRpdmUgUHJvbWlzZSBPbmx5XG4gICAgdjAuOC4xIChjKSBLeWxlIFNpbXBzb25cbiAgICBNSVQgTGljZW5zZTogaHR0cDovL2dldGlmeS5taXQtbGljZW5zZS5vcmdcbiovXG5cbihmdW5jdGlvbiBVTUQobmFtZSxjb250ZXh0LGRlZmluaXRpb24pe1xuXHQvLyBzcGVjaWFsIGZvcm0gb2YgVU1EIGZvciBwb2x5ZmlsbGluZyBhY3Jvc3MgZXZpcm9ubWVudHNcblx0Y29udGV4dFtuYW1lXSA9IGNvbnRleHRbbmFtZV0gfHwgZGVmaW5pdGlvbigpO1xuXHRpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7IG1vZHVsZS5leHBvcnRzID0gY29udGV4dFtuYW1lXTsgfVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7IGRlZmluZShmdW5jdGlvbiAkQU1EJCgpeyByZXR1cm4gY29udGV4dFtuYW1lXTsgfSk7IH1cbn0pKFwiUHJvbWlzZVwiLHR5cGVvZiBnbG9iYWwgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMsZnVuY3Rpb24gREVGKCl7XG5cdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBidWlsdEluUHJvcCwgY3ljbGUsIHNjaGVkdWxpbmdfcXVldWUsXG5cdFx0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRcdHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT0gXCJ1bmRlZmluZWRcIikgP1xuXHRcdFx0ZnVuY3Rpb24gdGltZXIoZm4pIHsgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7IH0gOlxuXHRcdFx0c2V0VGltZW91dFxuXHQ7XG5cblx0Ly8gZGFtbWl0LCBJRTguXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwieFwiLHt9KTtcblx0XHRidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLG5hbWUse1xuXHRcdFx0XHR2YWx1ZTogdmFsLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiBjb25maWcgIT09IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cdGNhdGNoIChlcnIpIHtcblx0XHRidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuXHRcdFx0b2JqW25hbWVdID0gdmFsO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cblx0Ly8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5cdHNjaGVkdWxpbmdfcXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG5cdFx0dmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG5cdFx0ZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG5cdFx0XHR0aGlzLmZuID0gZm47XG5cdFx0XHR0aGlzLnNlbGYgPSBzZWxmO1xuXHRcdFx0dGhpcy5uZXh0ID0gdm9pZCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIGFkZChmbixzZWxmKSB7XG5cdFx0XHRcdGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcblx0XHRcdFx0aWYgKGxhc3QpIHtcblx0XHRcdFx0XHRsYXN0Lm5leHQgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZpcnN0ID0gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0ID0gaXRlbTtcblx0XHRcdFx0aXRlbSA9IHZvaWQgMDtcblx0XHRcdH0sXG5cdFx0XHRkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG5cdFx0XHRcdHZhciBmID0gZmlyc3Q7XG5cdFx0XHRcdGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG5cdFx0XHRcdHdoaWxlIChmKSB7XG5cdFx0XHRcdFx0Zi5mbi5jYWxsKGYuc2VsZik7XG5cdFx0XHRcdFx0ZiA9IGYubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuXHRcdHNjaGVkdWxpbmdfcXVldWUuYWRkKGZuLHNlbGYpO1xuXHRcdGlmICghY3ljbGUpIHtcblx0XHRcdGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ19xdWV1ZS5kcmFpbik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuXHRmdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcblx0XHR2YXIgX3RoZW4sIG9fdHlwZSA9IHR5cGVvZiBvO1xuXG5cdFx0aWYgKG8gIT0gbnVsbCAmJlxuXHRcdFx0KFxuXHRcdFx0XHRvX3R5cGUgPT0gXCJvYmplY3RcIiB8fCBvX3R5cGUgPT0gXCJmdW5jdGlvblwiXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHRfdGhlbiA9IG8udGhlbjtcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGVvZiBfdGhlbiA9PSBcImZ1bmN0aW9uXCIgPyBfdGhlbiA6IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbm90aWZ5KCkge1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRub3RpZnlJc29sYXRlZChcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0KHRoaXMuc3RhdGUgPT09IDEpID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLFxuXHRcdFx0XHR0aGlzLmNoYWluW2ldXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR0aGlzLmNoYWluLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuXHQvLyB0aGUgYHRyeS4uY2F0Y2hgIHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gYmVcblx0Ly8gb3B0aW1pemVkIGJldHRlclxuXHRmdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG5cdFx0dmFyIHJldCwgX3RoZW47XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChjYiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoY2IgPT09IHRydWUpIHtcblx0XHRcdFx0XHRyZXQgPSBzZWxmLm1zZztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXQgPSBjYi5jYWxsKHZvaWQgMCxzZWxmLm1zZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVqZWN0KFR5cGVFcnJvcihcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG5cdFx0XHRcdFx0X3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNoYWluLnJlc29sdmUocmV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRjaGFpbi5yZWplY3QoZXJyKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlKG1zZykge1xuXHRcdHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG5cdFx0XHRcdHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGRlZl93cmFwcGVyID0gbmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRfdGhlbi5jYWxsKG1zZyxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gJHJlc29sdmUkKCl7IHJlc29sdmUuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gJHJlamVjdCQoKXsgcmVqZWN0LmFwcGx5KGRlZl93cmFwcGVyLGFyZ3VtZW50cyk7IH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlamVjdC5jYWxsKGRlZl93cmFwcGVyLGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNlbGYubXNnID0gbXNnO1xuXHRcdFx0XHRzZWxmLnN0YXRlID0gMTtcblx0XHRcdFx0aWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRyZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZWplY3QobXNnKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG5cdFx0aWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG5cdFx0c2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG5cdFx0Ly8gdW53cmFwXG5cdFx0aWYgKHNlbGYuZGVmKSB7XG5cdFx0XHRzZWxmID0gc2VsZi5kZWY7XG5cdFx0fVxuXG5cdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0c2VsZi5zdGF0ZSA9IDI7XG5cdFx0aWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIscmVzb2x2ZXIscmVqZWN0ZXIpIHtcblx0XHRmb3IgKHZhciBpZHg9MDsgaWR4PGFyci5sZW5ndGg7IGlkeCsrKSB7XG5cdFx0XHQoZnVuY3Rpb24gSUlGRShpZHgpe1xuXHRcdFx0XHRDb25zdHJ1Y3Rvci5yZXNvbHZlKGFycltpZHhdKVxuXHRcdFx0XHQudGhlbihcblx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZXIkKG1zZyl7XG5cdFx0XHRcdFx0XHRyZXNvbHZlcihpZHgsbXNnKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlamVjdGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9KShpZHgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcblx0XHR0aGlzLmRlZiA9IHNlbGY7XG5cdFx0dGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuXHRcdHRoaXMucHJvbWlzZSA9IHNlbGY7XG5cdFx0dGhpcy5zdGF0ZSA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcblx0XHR0aGlzLmNoYWluID0gW107XG5cdFx0dGhpcy5tc2cgPSB2b2lkIDA7XG5cdH1cblxuXHRmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjdXRvciAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9fTlBPX18gIT09IDApIHtcblx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIHByb21pc2VcIik7XG5cdFx0fVxuXG5cdFx0Ly8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG5cdFx0Ly8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2Vcblx0XHR0aGlzLl9fTlBPX18gPSAxO1xuXG5cdFx0dmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG5cdFx0dGhpc1tcInRoZW5cIl0gPSBmdW5jdGlvbiB0aGVuKHN1Y2Nlc3MsZmFpbHVyZSkge1xuXHRcdFx0dmFyIG8gPSB7XG5cdFx0XHRcdHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09IFwiZnVuY3Rpb25cIiA/IHN1Y2Nlc3MgOiB0cnVlLFxuXHRcdFx0XHRmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PSBcImZ1bmN0aW9uXCIgPyBmYWlsdXJlIDogZmFsc2Vcblx0XHRcdH07XG5cdFx0XHQvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG5cdFx0XHQvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcblx0XHRcdC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cblx0XHRcdG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLHJlamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHRvLnJlamVjdCA9IHJlamVjdDtcblx0XHRcdH0pO1xuXHRcdFx0ZGVmLmNoYWluLnB1c2gobyk7XG5cblx0XHRcdGlmIChkZWYuc3RhdGUgIT09IDApIHtcblx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LGRlZik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvLnByb21pc2U7XG5cdFx0fTtcblx0XHR0aGlzW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAkY2F0Y2gkKGZhaWx1cmUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuXHRcdH07XG5cblx0XHR0cnkge1xuXHRcdFx0ZXhlY3V0b3IuY2FsbChcblx0XHRcdFx0dm9pZCAwLFxuXHRcdFx0XHRmdW5jdGlvbiBwdWJsaWNSZXNvbHZlKG1zZyl7XG5cdFx0XHRcdFx0cmVzb2x2ZS5jYWxsKGRlZixtc2cpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG5cdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKGRlZixlcnIpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sXCJjb25zdHJ1Y3RvclwiLFByb21pc2UsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5cdFByb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuXHQvLyBidWlsdC1pbiBcImJyYW5kXCIgdG8gc2lnbmFsIGFuIFwidW5pbml0aWFsaXplZFwiIHByb21pc2Vcblx0YnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSxcIl9fTlBPX19cIiwwLFxuXHRcdC8qY29uZmlndXJhYmxlPSovZmFsc2Vcblx0KTtcblxuXHRidWlsdEluUHJvcChQcm9taXNlLFwicmVzb2x2ZVwiLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcblx0XHR2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG5cdFx0Ly8gc3BlYyBtYW5kYXRlZCBjaGVja3Ncblx0XHQvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG5cdFx0aWYgKG1zZyAmJiB0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnLl9fTlBPX18gPT09IDEpIHtcblx0XHRcdHJldHVybiBtc2c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNvbHZlKG1zZyk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZWplY3RcIixmdW5jdGlvbiBQcm9taXNlJHJlamVjdChtc2cpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuXHRcdFx0aWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KG1zZyk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJhbGxcIixmdW5jdGlvbiBQcm9taXNlJGFsbChhcnIpIHtcblx0XHR2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG5cdFx0Ly8gc3BlYyBtYW5kYXRlZCBjaGVja3Ncblx0XHRpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0cmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpO1xuXHRcdH1cblx0XHRpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuXHRcdFx0aWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZykge1xuXHRcdFx0XHRtc2dzW2lkeF0gPSBtc2c7XG5cdFx0XHRcdGlmICgrK2NvdW50ID09PSBsZW4pIHtcblx0XHRcdFx0XHRyZXNvbHZlKG1zZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LHJlamVjdCk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyYWNlXCIsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuXHRcdFx0XHRyZXNvbHZlKG1zZyk7XG5cdFx0XHR9LHJlamVjdCk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbGl0eSB0aGF0IHByb3ZpZGVzIGEgc2luZ2xlIEFQSSBmb3IgbG9hZGluZyB0aGUgY29udGVudCBvZiBhIHBhdGgvVVJMLlxuICpcbiAqIEBtb2R1bGUgUGF0aExvYWRlclxuICovXG5cbnZhciBzdXBwb3J0ZWRMb2FkZXJzID0ge1xuICBmaWxlOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2ZpbGUnKSxcbiAgaHR0cDogcmVxdWlyZSgnLi9saWIvbG9hZGVycy9odHRwJyksXG4gIGh0dHBzOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2h0dHAnKVxufTtcbnZhciBkZWZhdWx0TG9hZGVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicgP1xuICAgICAgc3VwcG9ydGVkTG9hZGVycy5odHRwIDpcbiAgICAgIHN1cHBvcnRlZExvYWRlcnMuZmlsZTtcblxuLy8gTG9hZCBwcm9taXNlcyBwb2x5ZmlsbCBpZiBuZWNlc3Nhcnlcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICByZXF1aXJlKCduYXRpdmUtcHJvbWlzZS1vbmx5Jyk7XG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtZSAobG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uLmluZGV4T2YoJzovLycpID09PSAtMSA/ICcnIDogbG9jYXRpb24uc3BsaXQoJzovLycpWzBdO1xuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIHVzZWQgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gYWx0ZXJpbmcgYSByZW1vdGUgcmVxdWVzdCBwcmlvciB0byB0aGUgcmVxdWVzdCBiZWluZyBtYWRlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gUHJlcGFyZVJlcXVlc3RDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXEgLSBUaGUgU3VwZXJhZ2VudCByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIGJlaW5nIHJldHJpZXZlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGaXJzdCBjYWxsYmFja1xuICpcbiAqIEBhbGlhcyBtb2R1bGU6UGF0aExvYWRlcn5QcmVwYXJlUmVxdWVzdENhbGxiYWNrXG4gKi9cblxuIC8qKlxuICAqIENhbGxiYWNrIHVzZWQgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gcHJvY2Vzc2luZyB0aGUgcmF3IHJlc3BvbnNlIG9mIHRoZSByZXF1ZXN0IGJlaW5nIG1hZGUuICooSFRUUCBsb2FkZXIgb25seSkqXG4gICpcbiAgKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFByb2Nlc3NSZXNwb25zZUNhbGxiYWNrXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gcmVzIC0gVGhlIFN1cGVyYWdlbnQgcmVzcG9uc2Ugb2JqZWN0ICooRm9yIG5vbi1IVFRQIGxvYWRlcnMsIHRoaXMgb2JqZWN0IHdpbGwgYmUgbGlrZSB0aGUgU3VwZXJhZ2VudFxuICAqIG9iamVjdCBpbiB0aGF0IGl0IHdpbGwgaGF2ZSBhIGB0ZXh0YCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyB0aGUgcmF3IHN0cmluZyB2YWx1ZSBiZWluZyBwcm9jZXNzZWQuICBUaGlzIHdhcyBkb25lXG4gICogZm9yIGNvbnNpc3RlbmN5LikqXG4gICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBFcnJvci1maXJzdCBjYWxsYmFja1xuICAqXG4gICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgcHJvY2Vzc2luZyB0aGUgcmVzcG9uc2V4c1xuICAqXG4gICogQGFsaWFzIG1vZHVsZTpQYXRoTG9hZGVyflByb2Nlc3NSZXNwb25zZUNhbGxiYWNrXG4gICovXG5cbmZ1bmN0aW9uIGdldExvYWRlciAobG9jYXRpb24pIHtcbiAgdmFyIHNjaGVtZSA9IGdldFNjaGVtZShsb2NhdGlvbik7XG4gIHZhciBsb2FkZXIgPSBzdXBwb3J0ZWRMb2FkZXJzW3NjaGVtZV07XG5cbiAgaWYgKHR5cGVvZiBsb2FkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHNjaGVtZSA9PT0gJycpIHtcbiAgICAgIGxvYWRlciA9IGRlZmF1bHRMb2FkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc2NoZW1lOiAnICsgc2NoZW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9hZGVyO1xufVxuXG4vKipcbiAqIExvYWRzIGEgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uIGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gLSBUaGUgZW5jb2RpbmcgdG8gdXNlIHdoZW4gbG9hZGluZyB0aGUgZmlsZSAqKEZpbGUgbG9hZGVyIG9ubHkpKlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIC0gVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QgKihIVFRQIGxvYWRlciBvbmx5KSpcbiAqIEBwYXJhbSB7bW9kdWxlOlBhdGhMb2FkZXJ+UHJlcGFyZVJlcXVlc3RDYWxsYmFja30gW29wdGlvbnMucHJlcGFyZVJlcXVlc3RdIC0gVGhlIGNhbGxiYWNrIHVzZWQgdG8gcHJlcGFyZSB0aGUgcmVxdWVzdFxuICogKihIVFRQIGxvYWRlciBvbmx5KSpcbiAqIEBwYXJhbSB7bW9kdWxlOlBhdGhMb2FkZXJ+UHJvY2Vzc1Jlc3BvbnNlQ2FsbGJhY2t9IFtvcHRpb25zLnByb2Nlc3NDb250ZW50XSAtIFRoZSBjYWxsYmFjayB1c2VkIHRvIHByb2Nlc3MgdGhlXG4gKiByZXNwb25zZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBbHdheXMgcmV0dXJucyBhIHByb21pc2UgZXZlbiBpZiB0aGVyZSBpcyBhIGNhbGxiYWNrIHByb3ZpZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgdXNpbmcgUHJvbWlzZXNcbiAqXG4gKiBQYXRoTG9hZGVyXG4gKiAgIC5sb2FkKCcuL3BhY2thZ2UuanNvbicpXG4gKiAgIC50aGVuKEpTT04ucGFyc2UpXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICogICAgIGNvbnNvbGUubG9nKGRvY3VtZW50Lm5hbWUgKyAnICgnICsgZG9jdW1lbnQudmVyc2lvbiArICcpOiAnICsgZG9jdW1lbnQuZGVzY3JpcHRpb24pO1xuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICogICB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB1c2luZyBvcHRpb25zLnByZXBhcmVSZXF1ZXN0IHRvIHByb3ZpZGUgYXV0aGVudGljYXRpb24gZGV0YWlscyBmb3IgYSByZW1vdGVseSBzZWN1cmUgVVJMXG4gKlxuICogUGF0aExvYWRlclxuICogICAubG9hZCgnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy93aGl0bG9ja2pjL3BhdGgtbG9hZGVyJywge1xuICogICAgIHByZXBhcmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxLCBjYWxsYmFjaykge1xuICogICAgICAgcmVxLmF1dGgoJ215LXVzZXJuYW1lJywgJ215LXBhc3N3b3JkJyk7XG4gKiAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlcSk7XG4gKiAgICAgfVxuICogICB9KVxuICogICAudGhlbihKU09OLnBhcnNlKVxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhkb2N1bWVudC5mdWxsX25hbWUgKyAnOiAnICsgZG9jdW1lbnQuZGVzY3JpcHRpb24pO1xuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICogICB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSBsb2FkaW5nIGEgWUFNTCBmaWxlXG4gKlxuICogUGF0aExvYWRlclxuICogICAubG9hZCgnL1VzZXJzL25vdC15b3UvcHJvamVjdHMvcGF0aC1sb2FkZXIvLnRyYXZpcy55bWwnKVxuICogICAudGhlbihZQU1MLnNhZmVMb2FkKVxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZygncGF0aC1sb2FkZXIgdXNlcyB0aGUnLCBkb2N1bWVudC5sYW5ndWFnZSwgJ2xhbmd1YWdlLicpO1xuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICogICB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSBsb2FkaW5nIGEgWUFNTCBmaWxlIHdpdGggb3B0aW9ucy5wcm9jZXNzQ29udGVudCAoVXNlZnVsIGlmIHlvdSBuZWVkIGluZm9ybWF0aW9uIGluIHRoZSByYXcgcmVzcG9uc2UpXG4gKlxuICogUGF0aExvYWRlclxuICogICAubG9hZCgnL1VzZXJzL25vdC15b3UvcHJvamVjdHMvcGF0aC1sb2FkZXIvLnRyYXZpcy55bWwnLCB7XG4gKiAgICAgcHJvY2Vzc0NvbnRlbnQ6IGZ1bmN0aW9uIChyZXMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICBjYWxsYmFjayhZQU1MLnNhZmVMb2FkKHJlcy50ZXh0KSk7XG4gKiAgICAgfVxuICogICB9KVxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZygncGF0aC1sb2FkZXIgdXNlcyB0aGUnLCBkb2N1bWVudC5sYW5ndWFnZSwgJ2xhbmd1YWdlLicpO1xuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgdG8gZW1wdHkgb2JqZWN0XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhcmd1bWVudHNcbiAgYWxsVGFza3MgPSBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbG9jYXRpb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xvY2F0aW9uIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLnByb2Nlc3NDb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMucHJvY2Vzc0NvbnRlbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBMb2FkIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBwcm92aWRlZCBsb2NhdGlvbiBhbmQgcHJvY2VzcyBpdFxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IGdldExvYWRlcihsb2NhdGlvbik7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQobG9jYXRpb24sIG9wdGlvbnMgfHwge30sIGZ1bmN0aW9uIChlcnIsIGRvY3VtZW50KSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZG9jdW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChvcHRpb25zLnByb2Nlc3NDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgLy8gRm9yIGNvbnNpc3RlbmN5IGJldHdlZW4gZmlsZSBhbmQgaHR0cCwgYWx3YXlzIHNlbmQgYW4gb2JqZWN0IHdpdGggYSAndGV4dCcgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcmF3XG4gICAgICAgICAgLy8gc3RyaW5nIHZhbHVlIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICBvcHRpb25zLnByb2Nlc3NDb250ZW50KHR5cGVvZiByZXMgPT09ICdvYmplY3QnID8gcmVzIDoge3RleHQ6IHJlc30sIGZ1bmN0aW9uIChlcnIsIHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gY29udGVudCBwcm9jZXNzb3IsIHdlIHdpbGwgYXNzdW1lIHRoYXQgZm9yIGFsbCBvYmplY3RzIHRoYXQgaXQgaXMgYSBTdXBlcmFnZW50IHJlc3BvbnNlXG4gICAgICAgIC8vIGFuZCB3aWxsIHJldHVybiBpdHMgYHRleHRgIHByb3BlcnR5IHZhbHVlLiAgT3RoZXJ3aXNlLCB3ZSB3aWxsIHJldHVybiB0aGUgcmF3IHJlc3BvbnNlLlxuICAgICAgICByZXR1cm4gdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgPyByZXMudGV4dCA6IHJlcztcbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gYWxsVGFza3M7XG59O1xuIiwiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHVuc3VwcG9ydGVkRXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUaGUgXFwnZmlsZVxcJyBzY2hlbWUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlcicpO1xuXG4vKipcbiAqIFRoZSBmaWxlIGxvYWRlciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEB0aHJvd3Mge2Vycm9yfSB0aGUgZmlsZSBsb2FkZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlclxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRCYXNlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB1bnN1cHBvcnRlZEVycm9yO1xufTtcblxuLyoqXG4gKiBUaGUgZmlsZSBsb2FkZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4odW5zdXBwb3J0ZWRFcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgdW5zdXBwb3J0ZWRFcnJvcjtcbiAgfVxufTtcbiIsIi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4vKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEplcmVteSBXaGl0bG9ja1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcblxudmFyIHN1cHBvcnRlZEh0dHBNZXRob2RzID0gWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncGF0Y2gnLCAncG9zdCcsICdwdXQnXTtcblxuLyoqXG4gKiBMb2FkcyBhIGZpbGUgZnJvbSBhbiBodHRwIG9yIGh0dHBzIFVSTC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgZG9jdW1lbnQgVVJMIChJZiByZWxhdGl2ZSwgbG9jYXRpb24gaXMgcmVsYXRpdmUgdG8gd2luZG93LmxvY2F0aW9uLm9yaWdpbikuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBsb2FkZXIgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIC0gVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7bW9kdWxlOlBhdGhMb2FkZXJ+UHJlcGFyZVJlcXVlc3RDYWxsYmFja30gW29wdGlvbnMucHJlcGFyZVJlcXVlc3RdIC0gVGhlIGNhbGxiYWNrIHVzZWQgdG8gcHJlcGFyZSBhIHJlcXVlc3RcbiAqIEBwYXJhbSB7bW9kdWxlOlBhdGhMb2FkZXJ+UHJvY2Vzc1Jlc3BvbnNlQ2FsbGJhY2t9IFtvcHRpb25zLnByb2Nlc3NDb250ZW50XSAtIFRoZSBjYWxsYmFjayB1c2VkIHRvIHByb2Nlc3MgdGhlXG4gKiByZXNwb25zZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZXJyb3ItZmlyc3QgY2FsbGJhY2tcbiAqL1xubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHJlYWxNZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvTG93ZXJDYXNlKCkgOiAnZ2V0JztcbiAgdmFyIGVycjtcbiAgdmFyIHJlYWxSZXF1ZXN0O1xuXG4gIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0IChlcnIsIHJlcSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJ1ZmZlcigpIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGUuanNcbiAgICAgIGlmICh0eXBlb2YgcmVxLmJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXEuYnVmZmVyKHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXFcbiAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyMiwgcmVzKSB7XG4gICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycjIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMubWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0ZWRIdHRwTWV0aG9kcy5pbmRleE9mKG9wdGlvbnMubWV0aG9kKSA9PT0gLTEpIHtcbiAgICAgIGVyciA9IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubWV0aG9kIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6ICcgK1xuICAgICAgICBzdXBwb3J0ZWRIdHRwTWV0aG9kcy5zbGljZSgwLCBzdXBwb3J0ZWRIdHRwTWV0aG9kcy5sZW5ndGggLSAxKS5qb2luKCcsICcpICsgJyBvciAnICtcbiAgICAgICAgc3VwcG9ydGVkSHR0cE1ldGhvZHNbc3VwcG9ydGVkSHR0cE1ldGhvZHMubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdGlvbnMucHJlcGFyZVJlcXVlc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnByZXBhcmVSZXF1ZXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCFlcnIpIHtcbiAgICByZWFsUmVxdWVzdCA9IHJlcXVlc3RbcmVhbE1ldGhvZCA9PT0gJ2RlbGV0ZScgPyAnZGVsJyA6IHJlYWxNZXRob2RdKGxvY2F0aW9uKTtcblxuICAgIGlmIChvcHRpb25zLnByZXBhcmVSZXF1ZXN0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBvcHRpb25zLnByZXBhcmVSZXF1ZXN0KHJlYWxSZXF1ZXN0LCBtYWtlUmVxdWVzdCk7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlUmVxdWVzdCh1bmRlZmluZWQsIHJlYWxSZXF1ZXN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJcbi8qKlxuICogUmVkdWNlIGBhcnJgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge01peGVkfSBpbml0aWFsXG4gKlxuICogVE9ETzogY29tYmF0aWJsZSBlcnJvciBoYW5kbGluZz9cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgZm4sIGluaXRpYWwpeyAgXG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGN1cnIgPSBhcmd1bWVudHMubGVuZ3RoID09IDNcbiAgICA/IGluaXRpYWxcbiAgICA6IGFycltpZHgrK107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGN1cnIgPSBmbi5jYWxsKG51bGwsIGN1cnIsIGFycltpZHhdLCArK2lkeCwgYXJyKTtcbiAgfVxuICBcbiAgcmV0dXJuIGN1cnI7XG59OyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHR2YXIgaXNFeHRlbmRlZExlbmd0aFBhdGggPSAvXlxcXFxcXFxcXFw/XFxcXC8udGVzdChzdHIpO1xuXHR2YXIgaGFzTm9uQXNjaWkgPSAvW15cXHgwMC1cXHg4MF0rLy50ZXN0KHN0cik7XG5cblx0aWYgKGlzRXh0ZW5kZWRMZW5ndGhQYXRoIHx8IGhhc05vbkFzY2lpKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdyZWR1Y2UnKTtcbnZhciByZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHsgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIHJvb3QgPSB0aGlzO1xufVxuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNIb3N0KG9iaikge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIHN3aXRjaCAoc3RyKSB7XG4gICAgY2FzZSAnW29iamVjdCBGaWxlXSc6XG4gICAgY2FzZSAnW29iamVjdCBCbG9iXSc6XG4gICAgY2FzZSAnW29iamVjdCBGb3JtRGF0YV0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLmJpbmQobnVsbCwgUmVxdWVzdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG51bGwgIT0gb2JqW2tleV0pIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgIH0pO1xuICB9XG4gIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4gLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFydHM7XG4gIHZhciBwYWlyO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeVxuIH07XG5cbiAvKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgbGluZXMucG9wKCk7IC8vIHRyYWlsaW5nIENSTEZcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICByZXR1cm4gL1tcXC8rXWpzb25cXGIvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFtcyhzdHIpe1xuICByZXR1cm4gcmVkdWNlKHN0ci5zcGxpdCgvICo7ICovKSwgZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKVxuICAgICAgLCBrZXkgPSBwYXJ0cy5zaGlmdCgpXG4gICAgICAsIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdGhpcy5zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcbiAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgID8gdGhpcy5wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICB2YXIgb2JqID0gcGFyYW1zKGN0KTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnBhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cil7XG4gIHZhciBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5yYXdSZXNwb25zZSA9IHNlbGYueGhyICYmIHNlbGYueGhyLnJlc3BvbnNlVGV4dCA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gc2VsZi54aHIgJiYgc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDApIHtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuXG4gICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGByZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBrZXkgaW4gcmVxdWVzdEJhc2UpIHtcbiAgUmVxdWVzdC5wcm90b3R5cGVba2V5XSA9IHJlcXVlc3RCYXNlW2tleV07XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmFib3J0ZWQpIHJldHVybjtcbiAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIuYWJvcnQoKTtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHJlc3BvbnNlVHlwZSB0byBgdmFsYC4gUHJlc2VudGx5IHZhbGlkIHJlc3BvbnNlVHlwZXMgYXJlICdibG9iJyBhbmQgXG4gKiAnYXJyYXlidWZmZXInLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycgb3IgJ2Jhc2ljJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpYydcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYGZpbGVuYW1lYC5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2gobmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIGZpbGVuYW1lKXtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lIHx8IGZpbGUubmFtZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAgKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAgKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gdGhpcy5fZGF0YSArICcmJyArIGRhdGFcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIW9iaiB8fCBpc0hvc3QoZGF0YSkpIHJldHVybiB0aGlzO1xuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuUmVzcG9uc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgaWYgKHJvb3QuY29uc29sZSkge1xuICAgIGNvbnNvbGUud2FybihcIkNsaWVudC1zaWRlIHBhcnNlKCkgbWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gc2VyaWFsaXplKCkuIFRoaXMgbWV0aG9kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggc3VwZXJhZ2VudCB2Mi4wXCIpO1xuICB9XG4gIHRoaXMuc2VyaWFsaXplKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgdmFyIGZuID0gdGhpcy5fY2FsbGJhY2s7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50aW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKDAgPT0gc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCkgcmV0dXJuIHNlbGYudGltZW91dEVycm9yKCk7XG4gICAgICBpZiAoc2VsZi5hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZSl7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gJ2Rvd25sb2FkJztcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAoeGhyLnVwbG9hZCAmJiB0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gIH1cblxuICAvLyB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi50aW1lZG91dCA9IHRydWU7XG4gICAgICBzZWxmLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBxdWVyeXN0cmluZ1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0KHF1ZXJ5KTtcbiAgICB0aGlzLnVybCArPSB+dGhpcy51cmwuaW5kZXhPZignPycpXG4gICAgICA/ICcmJyArIHF1ZXJ5XG4gICAgICA6ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgfSBlbHNlIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICgnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIWlzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3BhcnNlciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPSBvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZvcmNlIGdpdmVuIHBhcnNlclxuICpcbiAqIFNldHMgdGhlIGJvZHkgcGFyc2VyIG5vIG1hdHRlciB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXQgdG8gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmF1eCBwcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuZXhwb3J0cy50aGVuID0gZnVuY3Rpb24gdGhlbihmdWxmaWxsLCByZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgZXJyID8gcmVqZWN0KGVycikgOiBmdWxmaWxsKHJlcyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbmV4cG9ydHMuZ2V0SGVhZGVyID0gZXhwb3J0cy5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuZXhwb3J0cy51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICogcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzLCBtb2RpZmllZCBmb3IgVVJJLmpzICovXHJcblxyXG52YXIgcHVueWNvZGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXHJcblx0ICogQG5hbWUgcHVueWNvZGVcclxuXHQgKiBAdHlwZSBPYmplY3RcclxuXHQgKi9cclxuXHR2YXIgcHVueWNvZGUsXHJcblxyXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cclxuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXHJcblxyXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cclxuXHRiYXNlID0gMzYsXHJcblx0dE1pbiA9IDEsXHJcblx0dE1heCA9IDI2LFxyXG5cdHNrZXcgPSAzOCxcclxuXHRkYW1wID0gNzAwLFxyXG5cdGluaXRpYWxCaWFzID0gNzIsXHJcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcclxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcclxuXHJcblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cclxuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcclxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcclxuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXHJcblxyXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xyXG5cdGVycm9ycyA9IHtcclxuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXHJcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxyXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcclxuXHR9LFxyXG5cclxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXHJcblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxyXG5cdGZsb29yID0gTWF0aC5mbG9vcixcclxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxyXG5cclxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXHJcblx0a2V5O1xyXG5cclxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0LyoqXHJcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cclxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcclxuXHQgKiBpdGVtLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XHJcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XHJcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXHJcblx0ICogYWRkcmVzc2VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcclxuXHQgKiBjaGFyYWN0ZXIuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcclxuXHQgKiBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xyXG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XHJcblx0XHR2YXIgcmVzdWx0ID0gJyc7XHJcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXHJcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXHJcblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xyXG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcclxuXHRcdH1cclxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cclxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XHJcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XHJcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XHJcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcclxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXHJcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcclxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcclxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXHJcblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXHJcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcclxuXHQgKiBAbmFtZSBkZWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xyXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxyXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxyXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXHJcblx0XHQgICAgdmFsdWUsXHJcblx0XHQgICAgZXh0cmE7XHJcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xyXG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XHJcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcclxuXHRcdFx0XHRcdGNvdW50ZXItLTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxyXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXHJcblx0ICogQG5hbWUgZW5jb2RlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xyXG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xyXG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcclxuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xyXG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xyXG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcclxuXHRcdFx0fVxyXG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcclxuXHRcdFx0cmV0dXJuIG91dHB1dDtcclxuXHRcdH0pLmpvaW4oJycpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxyXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxyXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcclxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XHJcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XHJcblx0XHR9XHJcblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XHJcblx0XHR9XHJcblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYmFzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cclxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXHJcblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxyXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xyXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXHJcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcclxuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXHJcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcclxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxyXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcclxuXHRcdHZhciBrID0gMDtcclxuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XHJcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XHJcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xyXG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXHJcblx0ICogc3ltYm9scy5cclxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xyXG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXHJcblx0XHR2YXIgb3V0cHV0ID0gW10sXHJcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXHJcblx0XHQgICAgb3V0LFxyXG5cdFx0ICAgIGkgPSAwLFxyXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcclxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXHJcblx0XHQgICAgYmFzaWMsXHJcblx0XHQgICAgaixcclxuXHRcdCAgICBpbmRleCxcclxuXHRcdCAgICBvbGRpLFxyXG5cdFx0ICAgIHcsXHJcblx0XHQgICAgayxcclxuXHRcdCAgICBkaWdpdCxcclxuXHRcdCAgICB0LFxyXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xyXG5cdFx0ICAgIGJhc2VNaW51c1Q7XHJcblxyXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXHJcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxyXG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXHJcblxyXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xyXG5cdFx0aWYgKGJhc2ljIDwgMCkge1xyXG5cdFx0XHRiYXNpYyA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcclxuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XHJcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcclxuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxyXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cclxuXHJcblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xyXG5cclxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxyXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXHJcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXHJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXHJcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXHJcblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcclxuXHJcblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XHJcblxyXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcclxuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XHJcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XHJcblxyXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xyXG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcclxuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XHJcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xyXG5cclxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcclxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcclxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xyXG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xyXG5cdFx0XHRpICU9IG91dDtcclxuXHJcblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcclxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcclxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XHJcblx0XHR2YXIgbixcclxuXHRcdCAgICBkZWx0YSxcclxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcclxuXHRcdCAgICBiYXNpY0xlbmd0aCxcclxuXHRcdCAgICBiaWFzLFxyXG5cdFx0ICAgIGosXHJcblx0XHQgICAgbSxcclxuXHRcdCAgICBxLFxyXG5cdFx0ICAgIGssXHJcblx0XHQgICAgdCxcclxuXHRcdCAgICBjdXJyZW50VmFsdWUsXHJcblx0XHQgICAgb3V0cHV0ID0gW10sXHJcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cclxuXHRcdCAgICBpbnB1dExlbmd0aCxcclxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cclxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXHJcblx0XHQgICAgYmFzZU1pbnVzVCxcclxuXHRcdCAgICBxTWludXNUO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcclxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxyXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcclxuXHRcdG4gPSBpbml0aWFsTjtcclxuXHRcdGRlbHRhID0gMDtcclxuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcclxuXHJcblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXHJcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcclxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcclxuXHJcblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcclxuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cclxuXHJcblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xyXG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcclxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XHJcblxyXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XHJcblx0XHRcdC8vIGxhcmdlciBvbmU6XHJcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XHJcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XHJcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcclxuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXHJcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XHJcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcclxuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcclxuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcclxuXHRcdFx0biA9IG07XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xyXG5cclxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XHJcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xyXG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcclxuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XHJcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcclxuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xyXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcclxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xyXG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcclxuXHRcdFx0XHRcdGRlbHRhID0gMDtcclxuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQrK2RlbHRhO1xyXG5cdFx0XHQrK247XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcclxuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXHJcblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXHJcblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xyXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcclxuXHQgKiBzdHJpbmcuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XHJcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXHJcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXHJcblx0XHRcdFx0OiBzdHJpbmc7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xyXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxyXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxyXG5cdCAqIEFTQ0lJLlxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXHJcblx0ICogVW5pY29kZSBzdHJpbmcuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxyXG5cdCAqIGVtYWlsIGFkZHJlc3MuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xyXG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XHJcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxyXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcclxuXHRcdFx0XHQ6IHN0cmluZztcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cclxuXHRwdW55Y29kZSA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxyXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0XHQgKiBAdHlwZSBTdHJpbmdcclxuXHRcdCAqL1xyXG5cdFx0dmVyc2lvbjogJzEuMy4yJyxcclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXHJcblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cclxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKi9cclxuXHRcdHVjczI6IHtcclxuXHRcdFx0ZGVjb2RlOiB1Y3MyZGVjb2RlLFxyXG5cdFx0XHRlbmNvZGU6IHVjczJlbmNvZGVcclxuXHRcdH0sXHJcblx0XHRkZWNvZGU6IGRlY29kZSxcclxuXHRcdGVuY29kZTogZW5jb2RlLFxyXG5cdFx0dG9BU0NJSTogdG9BU0NJSSxcclxuXHRcdHRvVW5pY29kZTogdG9Vbmljb2RlXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHB1bnljb2RlO1xyXG59KCkpO1xyXG5cclxuaWYgKHR5cGVvZiBDT01QSUxFRCA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlOyIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cImNvbW1vbmpzLmQudHNcIi8+XHJcbnJlcXVpcmUoXCIuL3NjaGVtZXMvaHR0cFwiKTtcclxucmVxdWlyZShcIi4vc2NoZW1lcy91cm5cIik7XHJcbnJlcXVpcmUoXCIuL3NjaGVtZXMvbWFpbHRvXCIpO1xyXG4iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi91cmkudHNcIi8+XHJcbmlmICh0eXBlb2YgQ09NUElMRUQgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVSSSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgdmFyIFVSSSA9IHJlcXVpcmUoXCIuLi91cmlcIik7XHJcblVSSS5TQ0hFTUVTW1wiaHR0cFwiXSA9IFVSSS5TQ0hFTUVTW1wiaHR0cHNcIl0gPSB7XHJcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICB9LFxyXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoY29tcG9uZW50cywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcclxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpICE9PSBcImh0dHBzXCIgPyA4MCA6IDQ0MykgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcclxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXHJcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcclxuICAgICAgICAvL2FuZCBub3QgdGhlIEhUVFAgc3BlYy4gXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICB9XHJcbn07XHJcbiIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL3VyaS50c1wiLz5cclxuaWYgKHR5cGVvZiBDT01QSUxFRCA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVVJJID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHZhciBVUkkgPSByZXF1aXJlKFwiLi4vdXJpXCIpLCBwdW55Y29kZSA9IHJlcXVpcmUoXCIuLi9wdW55Y29kZVwiKTtcclxufVxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gbWVyZ2UoKSB7XHJcbiAgICAgICAgdmFyIHNldHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBzZXRzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcclxuICAgICAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcclxuICAgICAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgdmFyIE8gPSB7fSwgaXNJUkkgPSBVUkkuSVJJX1NVUFBPUlQsIFxyXG4gICAgLy9SRkMgMzk4NlxyXG4gICAgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiLCBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIiwgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLCBcclxuICAgIC8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPSBcclxuICAgIC8vQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiLFxyXG4gICAgLy9XU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiLFxyXG4gICAgLy9PQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIiwgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcclxuICAgIC8vUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKSwgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxyXG4gICAgLy9WQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiLFxyXG4gICAgLy9XU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiLFxyXG4gICAgLy9PQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKSwgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxyXG4gICAgLy9GV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIiksXHJcbiAgICAvL1FVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpLFxyXG4gICAgLy9RVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyksXHJcbiAgICBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIiwgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiLCBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIiksIERPVF9BVE9NX1RFWFQkID0gc3ViZXhwKEFURVhUJCQgKyBcIitcIiArIHN1YmV4cChcIlxcXFwuXCIgKyBBVEVYVCQkICsgXCIrXCIpICsgXCIqXCIpLCBRVU9URURfUEFJUiQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgVkNIQVIkJCksIFFDT05URU5UJCA9IHN1YmV4cChRVEVYVCQkICsgXCJ8XCIgKyBRVU9URURfUEFJUiQpLCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIFFDT05URU5UJCArIFwiKlwiICsgJ1xcXFxcIicpLCBcclxuICAgIC8vUkZDIDYwNjhcclxuICAgIERURVhUX05PX09CUyQkID0gXCJbXFxcXHgyMS1cXFxceDVBXFxcXHg1RS1cXFxceDdFXVwiLCBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIiwgUUNIQVIkID0gc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBTT01FX0RFTElNUyQkKSwgRE9NQUlOJCA9IHN1YmV4cChET1RfQVRPTV9URVhUJCArIFwifFwiICsgXCJcXFxcW1wiICsgRFRFWFRfTk9fT0JTJCQgKyBcIipcIiArIFwiXFxcXF1cIiksIExPQ0FMX1BBUlQkID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBRVU9URURfU1RSSU5HJCksIEFERFJfU1BFQyQgPSBzdWJleHAoTE9DQUxfUEFSVCQgKyBcIlxcXFxAXCIgKyBET01BSU4kKSwgVE8kID0gc3ViZXhwKEFERFJfU1BFQyQgKyBzdWJleHAoXCJcXFxcLFwiICsgQUREUl9TUEVDJCkgKyBcIipcIiksIEhGTkFNRSQgPSBzdWJleHAoUUNIQVIkICsgXCIqXCIpLCBIRlZBTFVFJCA9IEhGTkFNRSQsIEhGSUVMRCQgPSBzdWJleHAoSEZOQU1FJCArIFwiXFxcXD1cIiArIEhGVkFMVUUkKSwgSEZJRUxEUzIkID0gc3ViZXhwKEhGSUVMRCQgKyBzdWJleHAoXCJcXFxcJlwiICsgSEZJRUxEJCkgKyBcIipcIiksIEhGSUVMRFMkID0gc3ViZXhwKFwiXFxcXD9cIiArIEhGSUVMRFMyJCksIE1BSUxUT19VUkkgPSBVUkkuVkFMSURBVEVfU1VQUE9SVCAmJiBuZXcgUmVnRXhwKFwiXm1haWx0b1xcXFw6XCIgKyBUTyQgKyBcIj9cIiArIEhGSUVMRFMkICsgXCI/JFwiKSwgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSwgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpLCBOT1RfRE9NQUlOID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgXCJbXFxcXFtdXCIsIERURVhUX05PX09CUyQkLCBcIltcXFxcXV1cIiksIFwiZ1wiKSwgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpLCBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUUsIFRPID0gVVJJLlZBTElEQVRFX1NVUFBPUlQgJiYgbmV3IFJlZ0V4cChcIl5cIiArIFRPJCArIFwiJFwiKSwgSEZJRUxEUyA9IFVSSS5WQUxJREFURV9TVVBQT1JUICYmIG5ldyBSZWdFeHAoXCJeXCIgKyBIRklFTERTMiQgKyBcIiRcIik7XHJcbiAgICBmdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xyXG4gICAgICAgIHZhciBkZWNTdHIgPSBVUkkucGN0RGVjQ2hhcnMoc3RyKTtcclxuICAgICAgICByZXR1cm4gKCFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsID8gKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmICFvYmouY2FsbGVlID8gb2JqIDogKHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikpKSA6IFtdO1xyXG4gICAgfVxyXG4gICAgVVJJLlNDSEVNRVNbXCJtYWlsdG9cIl0gPSB7XHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChVUkkuVkFMSURBVEVfU1VQUE9SVCAmJiAhY29tcG9uZW50cy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiAhVE8udGVzdChjb21wb25lbnRzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IFwiRW1haWwgYWRkcmVzcyBpcyBub3QgdmFsaWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMucXVlcnkgJiYgIUhGSUVMRFMudGVzdChjb21wb25lbnRzLnF1ZXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBcIkhlYWRlciBmaWVsZHMgYXJlIGludmFsaWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG8gPSBjb21wb25lbnRzLnRvID0gKGNvbXBvbmVudHMucGF0aCA/IGNvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXSk7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMucXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlLCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkcyA9IGNvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaGZpZWxkWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeF8xID0gMCwgeGxfMSA9IHRvQWRkcnMubGVuZ3RoOyB4XzEgPCB4bF8xOyArK3hfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1t4XzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5zdWJqZWN0ID0gVVJJLnVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuYm9keSA9IFVSSS51bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1VSSS51bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IFVSSS51bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1t4XS5zcGxpdChcIkBcIik7XHJcbiAgICAgICAgICAgICAgICBhZGRyWzBdID0gVVJJLnVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwdW55Y29kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSShVUkkudW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBVUkkudW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvW3hdID0gYWRkci5qb2luKFwiQFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHRvID0gdG9BcnJheShjb21wb25lbnRzLnRvKTtcclxuICAgICAgICAgICAgaWYgKHRvKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gdG9BZGRyLnNsaWNlKDAsIGF0SWR4KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0ID0gbG9jYWxQYXJ0LnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBVUkkucGN0RW5jQ2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwdW55Y29kZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoVVJJLnVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBkb21haW4ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfRE9NQUlOLCBVUkkucGN0RW5jQ2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IGNvbXBvbmVudHMuaGVhZGVycyA9IGNvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMuc3ViamVjdClcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gY29tcG9uZW50cy5zdWJqZWN0O1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ib2R5KVxyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tcImJvZHlcIl0gPSBjb21wb25lbnRzLmJvZHk7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVfMV0gIT09IE9bbmFtZV8xXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWVfMS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBVUkkucGN0RW5jQ2hhcikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj1cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV8xXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgVVJJLnBjdEVuY0NoYXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG4iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi91cmkudHNcIi8+XHJcbmlmICh0eXBlb2YgQ09NUElMRUQgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVSSSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgdmFyIFVSSSA9IHJlcXVpcmUoXCIuLi91cmlcIik7XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcGN0RW5jQ2hhciA9IFVSSS5wY3RFbmNDaGFyLCBOSUQkID0gXCIoPzpbMC05QS1aYS16XVswLTlBLVphLXpcXFxcLV17MSwzMX0pXCIsIFBDVF9FTkNPREVEJCA9IFwiKD86XFxcXCVbMC05QS1GYS1mXXsyfSlcIiwgVFJBTlMkJCA9IFwiWzAtOUEtWmEtelxcXFwoXFxcXClcXFxcK1xcXFwsXFxcXC1cXFxcLlxcXFw6XFxcXD1cXFxcQFxcXFw7XFxcXCRcXFxcX1xcXFwhXFxcXCpcXFxcJ1xcXFwvXFxcXD9cXFxcI11cIiwgTlNTJCA9IFwiKD86KD86XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFRSQU5TJCQgKyBcIikrKVwiLCBVUk5fU0NIRU1FID0gbmV3IFJlZ0V4cChcIl51cm5cXFxcOihcIiArIE5JRCQgKyBcIikkXCIpLCBVUk5fUEFUSCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgTklEJCArIFwiKVxcXFw6KFwiICsgTlNTJCArIFwiKSRcIiksIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS8sIFVSTl9FWENMVURFRCA9IC9bXFx4MDAtXFx4MjBcXFxcXFxcIlxcJlxcPFxcPlxcW1xcXVxcXlxcYFxce1xcfFxcfVxcflxceDdGLVxceEZGXS9nLCBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xyXG4gICAgLy9SRkMgMjE0MVxyXG4gICAgVVJJLlNDSEVNRVNbXCJ1cm5cIl0gPSB7XHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVRIKSwgc2NoZW1lLCBzY2hlbWVIYW5kbGVyO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGlzIG5vdCBzdHJpY3RseSB2YWxpZC5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgc2NoZW1lID0gXCJ1cm46XCIgKyBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWVIYW5kbGVyID0gVVJJLlNDSEVNRVNbc2NoZW1lXTtcclxuICAgICAgICAgICAgICAgIC8vaW4gb3JkZXIgdG8gc2VyaWFsaXplIHByb3Blcmx5LCBcclxuICAgICAgICAgICAgICAgIC8vZXZlcnkgVVJOIG11c3QgaGF2ZSBhIHNlcmlhbGl6ZXIgdGhhdCBjYWxscyB0aGUgVVJOIHNlcmlhbGl6ZXIgXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVtZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBmYWtlIHNjaGVtZSBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lSGFuZGxlciA9IFVSSS5TQ0hFTUVTW3NjaGVtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoY29tcG9uZW50cywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogVVJJLlNDSEVNRVNbXCJ1cm5cIl0uc2VyaWFsaXplXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gc2NoZW1lO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1syXTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBjb21wb25lbnRzLnNjaGVtZSB8fCBvcHRpb25zLnNjaGVtZSwgbWF0Y2hlcztcclxuICAgICAgICAgICAgaWYgKHNjaGVtZSAmJiBzY2hlbWUgIT09IFwidXJuXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gc2NoZW1lLm1hdGNoKFVSTl9TQ0hFTUUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtcInVybjpcIiArIHNjaGVtZSwgc2NoZW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gXCJ1cm5cIjtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbMV0gKyBcIjpcIiArIChjb21wb25lbnRzLnBhdGggPyBjb21wb25lbnRzLnBhdGgucmVwbGFjZShVUk5fRVhDTFVERUQsIHBjdEVuY0NoYXIpIDogXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vUkZDIDQxMjJcclxuICAgIFVSSS5TQ0hFTUVTW1widXJuOnV1aWRcIl0gPSB7XHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIWNvbXBvbmVudHMucGF0aCB8fCAhY29tcG9uZW50cy5wYXRoLm1hdGNoKFVVSUQpKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy9lbnN1cmUgVVVJRCBpcyB2YWxpZFxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCFjb21wb25lbnRzLnBhdGggfHwgIWNvbXBvbmVudHMucGF0aC5tYXRjaChVVUlEKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vaW52YWxpZCBVVUlEcyBjYW4gbm90IGhhdmUgdGhpcyBzY2hlbWVcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9ub3JtYWxpemUgVVVJRFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gKGNvbXBvbmVudHMucGF0aCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBVUkkuU0NIRU1FU1tcInVyblwiXS5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIFVSSS5qc1xyXG4gKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cclxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cclxuICogQHZlcnNpb24gMi4wLjBcclxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXHJcbiAqIEBsaWNlbnNlIFVSSS5qcyB2Mi4wLjAgKGMpIDIwMTEgR2FyeSBDb3VydC4gTGljZW5zZTogaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xyXG4gKi9cclxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKlxyXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxyXG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xyXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcclxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxyXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXHJcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcclxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqXHJcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXHJcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXHJcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXHJcbiAqL1xyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJwdW55Y29kZS5kLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJjb21tb25qcy5kLnRzXCIvPlxyXG4vKipcclxuICogQ29tcGlsZXIgc3dpdGNoIGZvciBpbmRpY2F0aW5nIGNvZGUgaXMgY29tcGlsZWRcclxuICogQGRlZmluZSB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBDT01QSUxFRCA9IGZhbHNlO1xyXG4vKipcclxuICogQ29tcGlsZXIgc3dpdGNoIGZvciBzdXBwb3J0aW5nIElSSSBVUklzXHJcbiAqIEBkZWZpbmUge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgVVJJX19JUklfU1VQUE9SVCA9IHRydWU7XHJcbi8qKlxyXG4gKiBDb21waWxlciBzd2l0Y2ggZm9yIHN1cHBvcnRpbmcgVVJJIHZhbGlkYXRpb25cclxuICogQGRlZmluZSB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBVUklfX1ZBTElEQVRFX1NVUFBPUlQgPSB0cnVlO1xyXG52YXIgVVJJID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIG1lcmdlKCkge1xyXG4gICAgICAgIHZhciBzZXRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgc2V0c1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgIHZhciB4bCA9IHNldHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB4bDsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0c1t4bF0gPSBzZXRzW3hsXS5zbGljZSgxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHMuam9pbignJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0c1swXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdWJleHAoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xyXG4gICAgICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLCBDUiQgPSBcIltcXFxceDBEXVwiLCBESUdJVCQkID0gXCJbMC05XVwiLCBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSwgTEYkJCA9IFwiW1xcXFx4MEFdXCIsIFNQJCQgPSBcIltcXFxceDIwXVwiLCBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLCBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLCBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLCBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIiwgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIiwgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSwgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksIElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVQkKSwgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksIElQVjZBRERSRVNTJCA9IHN1YmV4cChtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLCBJUFZGVVRVUkUkID0gc3ViZXhwKFwidlwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSwgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLCBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSwgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSwgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSwgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSwgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLCBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSwgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLCBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSwgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSwgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSwgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSwgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSwgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLCBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLCBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIiwgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLCBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgVVJJX1JFRjogVVJJX19WQUxJREFURV9TVVBQT1JUICYmIG5ldyBSZWdFeHAoXCIoXCIgKyBHRU5FUklDX1JFRiQgKyBcIil8KFwiICsgUkVMQVRJVkVfUkVGJCArIFwiKVwiKSxcclxuICAgICAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXHJcbiAgICAgICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXHJcbiAgICAgICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXHJcbiAgICAgICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXHJcbiAgICAgICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxyXG4gICAgICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXHJcbiAgICAgICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcclxuICAgICAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxyXG4gICAgICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxyXG4gICAgICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcclxuICAgICAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIilcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIFVSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyhmYWxzZSksIElSSV9QUk9UT0NPTCA9IFVSSV9fSVJJX1NVUFBPUlQgPyBidWlsZEV4cHModHJ1ZSkgOiB1bmRlZmluZWQsIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxuKSopKT8vaSwgUkRTMSA9IC9eXFwuXFwuP1xcLy8sIFJEUzIgPSAvXlxcL1xcLihcXC98JCkvLCBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLywgUkRTNCA9IC9eXFwuXFwuPyQvLCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvLCBOT19NQVRDSF9JU19VTkRFRklORUQgPSAoXCJcIikubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcclxuICAgIGZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XHJcbiAgICAgICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKSwgZTtcclxuICAgICAgICBpZiAoYyA8IDE2KVxyXG4gICAgICAgICAgICBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBlID0gXCIlXCIgKyAoKGMgPj4gNikgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZSA9IFwiJVwiICsgKChjID4+IDEyKSB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoKGMgPj4gNikgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XHJcbiAgICAgICAgdmFyIG5ld1N0ciA9IFwiXCIsIGkgPSAwLCBpbCA9IHN0ci5sZW5ndGgsIGMsIGMyLCBjMztcclxuICAgICAgICB3aGlsZSAoaSA8IGlsKSB7XHJcbiAgICAgICAgICAgIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xyXG4gICAgICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChpbCAtIGkpID49IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSArPSA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPj0gMjI0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlsIC0gaSkgPj0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U3RyO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdHlwZU9mKG8pIHtcclxuICAgICAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IChvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIFNDSEVNRVMgPSB7fTtcclxuICAgIGZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUpXHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gU3RyaW5nKGNvbXBvbmVudHMuaG9zdCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKChjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUpLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHByb3RvY29sID0gKFVSSV9fSVJJX1NVUFBPUlQgJiYgb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKSwgbWF0Y2hlcywgcGFyc2VFcnJvciA9IGZhbHNlLCBjb21wb25lbnRzID0ge30sIHNjaGVtZUhhbmRsZXI7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKVxyXG4gICAgICAgICAgICB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XHJcbiAgICAgICAgaWYgKFVSSV9fVkFMSURBVEVfU1VQUE9SVCkge1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKHByb3RvY29sLlVSSV9SRUYpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dlbmVyaWMgVVJJXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMSwgMTApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWxhdGl2ZSBVUklcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgxMCwgMTkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IHN0cmljdGx5IHZhbGlkLlwiO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgICAgIC8vY29tcG9uZW50cy5hdXRob3JpdHkgPSBtYXRjaGVzWzJdO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcclxuICAgICAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgLy9jb21wb25lbnRzLmF1dGhvcml0eSA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbMl0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAodXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSAodXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIiNcIikgIT09IC0xID8gbWF0Y2hlc1s4XSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSAodXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZGV0ZXJtaW5lIHJlZmVyZW5jZSB0eXBlXHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcclxuICAgICAgICAgICAgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xyXG4gICAgICAgICAgICBpZiAoVVJJX19JUklfU1VQUE9SVCAmJiB0eXBlb2YgcHVueWNvZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xyXG4gICAgICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSVJJIC0+IFVSSVxyXG4gICAgICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ3NcclxuICAgICAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXHJcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBjYW4gbm90IGJlIHBhcnNlZC5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBmdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdXJpVG9rZW5zID0gW107XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcclxuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCJAXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5ob3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xyXG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnBvcnQudG9TdHJpbmcoMTApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdLCBzO1xyXG4gICAgICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHMgPSBpbnB1dC5tYXRjaChSRFM1KVswXTtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciBwcm90b2NvbCA9IChVUklfX0lSSV9TVVBQT1JUICYmIG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKSwgdXJpVG9rZW5zID0gW10sIHNjaGVtZUhhbmRsZXIsIGF1dGhvcml0eSwgcztcclxuICAgICAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcclxuICAgICAgICBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXHJcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpXHJcbiAgICAgICAgICAgIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xyXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxyXG4gICAgICAgIGlmIChVUklfX0lSSV9TVVBQT1JUICYmIHR5cGVvZiBwdW55Y29kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSkge1xyXG4gICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcclxuICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xyXG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XHJcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XHJcbiAgICAgICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcclxuICAgICAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcyA9IGNvbXBvbmVudHMucGF0aDtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcclxuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIjXCIpO1xyXG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLmZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUsIG9wdGlvbnMsIHNraXBOb3JtYWxpemF0aW9uKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xyXG4gICAgICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXHJcbiAgICAgICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xyXG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XHJcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xyXG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XHJcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcclxuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJhc2UucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIG9wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgb3B0aW9ucyksIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVPZih1cmlCKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB1cmlCID0gc2VyaWFsaXplKHVyaUIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJpQSA9PT0gdXJpQjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFVUklfX0lSSV9TVVBQT1JUIHx8ICFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFKSwgcGN0RW5jQ2hhcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFVUklfX0lSSV9TVVBQT1JUIHx8ICFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCksIHBjdERlY0NoYXJzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgSVJJX1NVUFBPUlQ6IFVSSV9fSVJJX1NVUFBPUlQsXHJcbiAgICAgICAgVkFMSURBVEVfU1VQUE9SVDogVVJJX19WQUxJREFURV9TVVBQT1JULFxyXG4gICAgICAgIHBjdEVuY0NoYXI6IHBjdEVuY0NoYXIsXHJcbiAgICAgICAgcGN0RGVjQ2hhcnM6IHBjdERlY0NoYXJzLFxyXG4gICAgICAgIFNDSEVNRVM6IFNDSEVNRVMsXHJcbiAgICAgICAgcGFyc2U6IHBhcnNlLFxyXG4gICAgICAgIF9yZWNvbXBvc2VBdXRob3JpdHk6IF9yZWNvbXBvc2VBdXRob3JpdHksXHJcbiAgICAgICAgcmVtb3ZlRG90U2VnbWVudHM6IHJlbW92ZURvdFNlZ21lbnRzLFxyXG4gICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxyXG4gICAgICAgIHJlc29sdmVDb21wb25lbnRzOiByZXNvbHZlQ29tcG9uZW50cyxcclxuICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxyXG4gICAgICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxyXG4gICAgICAgIGVxdWFsOiBlcXVhbCxcclxuICAgICAgICBlc2NhcGVDb21wb25lbnQ6IGVzY2FwZUNvbXBvbmVudCxcclxuICAgICAgICB1bmVzY2FwZUNvbXBvbmVudDogdW5lc2NhcGVDb21wb25lbnRcclxuICAgIH07XHJcbn0pKCk7XHJcbmlmICghQ09NUElMRUQgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICB2YXIgcHVueWNvZGUgPSByZXF1aXJlKFwiLi9wdW55Y29kZVwiKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gVVJJO1xyXG4gICAgcmVxdWlyZShcIi4vc2NoZW1lc1wiKTtcclxufVxyXG4iXX0=\n  ","module.exports = require('./dist/cjs/Core');\r\n","module.exports = require('./lib/ObjectPath.js').ObjectPath;\n","'use strict';\n\n;!function(undefined) {\n\n\tvar ObjectPath = {\n\t\tparse: function(str){\n\t\t\tif(typeof str !== 'string'){\n\t\t\t\tthrow new TypeError('ObjectPath.parse must be passed a string');\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\tvar parts = [];\n\t\t\tvar d, b, q, c;\n\t\t\twhile (i < str.length){\n\t\t\t\td = str.indexOf('.', i);\n\t\t\t\tb = str.indexOf('[', i);\n\n\t\t\t\t// we've reached the end\n\t\t\t\tif (d === -1 && b === -1){\n\t\t\t\t\tparts.push(str.slice(i, str.length));\n\t\t\t\t\ti = str.length;\n\t\t\t\t}\n\n\t\t\t\t// dots\n\t\t\t\telse if (b === -1 || (d !== -1 && d < b)) {\n\t\t\t\t\tparts.push(str.slice(i, d));\n\t\t\t\t\ti = d + 1;\n\t\t\t\t}\n\n\t\t\t\t// brackets\n\t\t\t\telse {\n\t\t\t\t\tif (b > i){\n\t\t\t\t\t\tparts.push(str.slice(i, b));\n\t\t\t\t\t\ti = b;\n\t\t\t\t\t}\n\t\t\t\t\tq = str.slice(b+1, b+2);\n\t\t\t\t\tif (q !== '\"' && q !=='\\'') {\n\t\t\t\t\t\tc = str.indexOf(']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\tparts.push(str.slice(i + 1, c));\n\t\t\t\t\t\ti = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\twhile (str.slice(c - 1, c) === '\\\\' && b < str.length){\n\t\t\t\t\t\t\tb++;\n\t\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts.push(str.slice(i + 2, c).replace(new RegExp('\\\\'+q,'g'), q));\n\t\t\t\t\t\ti = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parts;\n\t\t},\n\n\t\t// root === true : auto calculate root; must be dot-notation friendly\n\t\t// root String : the string to use as root\n\t\tstringify: function(arr, quote){\n\n\t\t\tif(!Array.isArray(arr))\n\t\t\t\tarr = [arr.toString()];\n\n\t\t\tquote = quote === '\"' ? '\"' : '\\'';\n\n\t\t\treturn arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\\\' + quote) + quote + ']'; }).join('');\n\t\t},\n\n\t\tnormalize: function(data, quote){\n\t\t\treturn ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);\n\t\t},\n\n\t\t// Angular\n\t\tregisterModule: function(angular) {\n\t\t\tangular.module('ObjectPath', []).provider('ObjectPath', function(){\n\t\t\t\tthis.parse = ObjectPath.parse;\n\t\t\t\tthis.stringify = ObjectPath.stringify;\n\t\t\t\tthis.normalize = ObjectPath.normalize;\n\t\t\t\tthis.$get = function(){\n\t\t\t\t\treturn ObjectPath;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t};\n\n\t// AMD\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn {ObjectPath: ObjectPath};\n\t\t});\n\t}\n\n\t// CommonJS\n\telse if (typeof exports === 'object') {\n\t\texports.ObjectPath = ObjectPath;\n\t}\n\n\t// Browser global\n\telse {\n\t\twindow.ObjectPath = ObjectPath;\n\t}\n\t\n}();","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import angular from 'angular';\r\n\r\n/**\r\n * I am the schema-validate directive\r\n *\r\n * @param  {function} sfValidator\r\n * @param  {function} $parse\r\n * @param  {function} sfSelect\r\n * @param  {function} $interpolate\r\n *\r\n * @return {object}   I am the directive properties made available to Angular\r\n */\r\nexport default function(sfValidator, $parse, sfSelect, $interpolate) {\r\n  return {\r\n    restrict: 'A',\r\n    scope: false,\r\n    // We want the link function to be *after* the input directives link function so we get access\r\n    // the parsed value, ex. a number instead of a string\r\n    priority: 500,\r\n    require: 'ngModel',\r\n    link: function(scope, element, attrs, ngModel) {\r\n      // We need the ngModelController on several places,\r\n      // most notably for errors.\r\n      // So we emit it up to the decorator directive so it can put it on scope.\r\n      scope.$emit('schemaFormPropagateNgModelController', ngModel);\r\n\r\n      let error = null;\r\n      let form = scope.$eval(attrs.schemaValidate);\r\n\r\n      // TODO move this out of validate and refactor to generate a function prepopulated to $i[] to reduce repetition\r\n      let copyTo = (typeof form.copyValueTo === 'string')? [ form.copyValueTo ]: form.copyValueTo;\r\n      if (copyTo && copyTo.length) {\r\n        ngModel.$viewChangeListeners.push(function() {\r\n          let context = {\r\n            'model': scope.model,\r\n            'form': form,\r\n            'arrayIndex': scope.$index,\r\n            'arrayIndices': scope.arrayIndices,\r\n            'path': scope.path,\r\n            '$i': scope.$i,\r\n            '$index': scope.$index,\r\n          };\r\n          angular.forEach(copyTo, function(copyToPath) {\r\n            let path = copyToPath\r\n              .replace(/(\\[)([^\\[\\]]*(\\]|\\[[^\\]]*\\]))(\\])/, '$1{{$2}}$4')\r\n              .replace(/^model\\./, '');\r\n            let i = -1;\r\n            path = path.replace(/\\[\\]/gi, function(matched) {\r\n              i++;\r\n              return '[' + scope.$i[i] + ']';\r\n            });\r\n            path = $interpolate(path)(context);\r\n            sfSelect(path, scope.model, ngModel.$modelValue);\r\n          });\r\n        });\r\n      };\r\n      // Validate against the schema.\r\n\r\n      let validate = function(viewValue, triggered) {\r\n        // Still might be undefined\r\n        if (!form) {\r\n          return viewValue;\r\n        }\r\n\r\n        // Omit TV4 validation\r\n        if (scope.options && scope.options.tv4Validation === false) {\r\n          return viewValue;\r\n        }\r\n\r\n        let result = sfValidator(form, viewValue);\r\n        // console.log('result is', result)\r\n        // Since we might have different tv4 errors we must clear all\r\n        // errors that start with tv4-\r\n        Object.keys(ngModel.$error)\r\n            .filter(function(k) { return k.indexOf('tv4-') === 0; })\r\n            .forEach(function(k) { ngModel.$setValidity(k, true); });\r\n\r\n        if (!result.valid && (!ngModel.$pristine || triggered || scope.options.validateOnRender === true)) {\r\n          // it is invalid, return undefined (no model update)\r\n          ngModel.$setValidity('tv4-' + result.error.code, false);\r\n          error = result.error;\r\n\r\n          // In Angular 1.3+ return the viewValue, otherwise we inadvertenly\r\n          // will trigger a 'parse' error.\r\n          // we will stop the model value from updating with our own $validator\r\n          // later.\r\n          if (ngModel.$validators) {\r\n            return viewValue;\r\n          };\r\n\r\n          // Angular 1.2 on the other hand lacks $validators and don't add a 'parse' error.\r\n          return undefined;\r\n        };\r\n\r\n        return viewValue;\r\n      };\r\n\r\n      // Custom validators, parsers, formatters etc\r\n      if (typeof form.ngModel === 'function') {\r\n        form.ngModel(ngModel);\r\n      }\r\n\r\n      [ '$parsers', '$viewChangeListeners', '$formatters' ].forEach(function(attr) {\r\n        if (form[attr] && ngModel[attr]) {\r\n          form[attr].forEach(function(fn) {\r\n            ngModel[attr].push(fn);\r\n          });\r\n        }\r\n      });\r\n\r\n      [ '$validators', '$asyncValidators' ].forEach(function(attr) {\r\n        // Check if our version of angular has validators, i.e. 1.3+\r\n        if (form[attr] && ngModel[attr]) {\r\n          angular.forEach(form[attr], function(fn, name) {\r\n            ngModel[attr][name] = function(modelValue, viewValue) {\r\n              return fn(modelValue, viewValue, scope.model, form);\r\n            };\r\n          });\r\n        }\r\n      });\r\n\r\n      // Get in last of the parses so the parsed value has the correct type.\r\n      // We don't use $validators since we like to set different errors depending tv4 error codes\r\n      ngModel.$parsers.push(validate);\r\n\r\n      // But we do use one custom validator in the case of Angular 1.3 to stop the model from\r\n      // updating if we've found an error.\r\n      if (ngModel.$validators) {\r\n        ngModel.$validators.schemaForm = function() {\r\n          // console.log('validators called.')\r\n          // Any error and we're out of here!\r\n          return !Object.keys(ngModel.$error).some(function(err) { return err !== 'schemaForm';});\r\n        };\r\n      }\r\n\r\n      let schema = form.schema;\r\n\r\n      // A bit ugly but useful.\r\n      scope.validateField = function(formName, triggered) {\r\n        let noField = (formName === undefined);\r\n        // If we have specified a form name, and this model is not within\r\n        // that form, then leave things be.\r\n        if (!noField && ngModel.$$parentForm.$name !== formName) {\r\n          return;\r\n        };\r\n\r\n        // Special case: arrays\r\n        // TODO: Can this be generalized in a way that works consistently?\r\n        // Just setting the viewValue isn't enough to trigger validation\r\n        // since it's the same value. This will be better when we drop\r\n        // 1.2 support.\r\n        if (noField || schema && schema.type.indexOf('array') !== -1) {\r\n          validate(ngModel.$modelValue, triggered);\r\n        };\r\n\r\n        // We set the viewValue to trigger parsers,\r\n        // since modelValue might be empty and validating just that\r\n        // might change an existing error to a \"required\" error message.\r\n        if (ngModel.$setDirty) {\r\n          // Angular 1.3+\r\n          ngModel.$setDirty();\r\n          ngModel.$setViewValue(ngModel.$viewValue);\r\n          ngModel.$commitViewValue();\r\n\r\n          // In Angular 1.3 setting undefined as a viewValue does not trigger parsers\r\n          // so we need to do a special required check.\r\n\r\n          // angulars checkbox directive isEmpty does not do the check we want.\r\n          if (form.type === 'checkbox') {\r\n            if (form.required && ngModel.$modelValue === undefined) {\r\n              ngModel.$setValidity('tv4-302', false);\r\n            };\r\n          }\r\n          else if (form.required && ngModel.$isEmpty(ngModel.$modelValue)) {\r\n            ngModel.$setValidity('tv4-302', false);\r\n          };\r\n        }\r\n        else {\r\n          // Angular 1.2\r\n          // In angular 1.2 setting a viewValue of undefined will trigger the parser.\r\n          // hence required works.\r\n          ngModel.$setViewValue(ngModel.$viewValue);\r\n        }\r\n      };\r\n\r\n      let first = true;\r\n      ngModel.$formatters.push(function(val) {\r\n        // When a form first loads this will be called for each field.\r\n        // we usually don't want that.\r\n        if (ngModel.$pristine && first &&\r\n            (!scope.options || scope.options.validateOnRender !== true)) {\r\n          first = false;\r\n          return val;\r\n        }\r\n        validate(ngModel.$modelValue);\r\n        return val;\r\n      });\r\n\r\n      // Listen to an event so we can validate the input on request\r\n      scope.$on('schemaFormValidate', function(event, formName) {\r\n        scope.validateField(formName, true);\r\n      });\r\n\r\n      scope.schemaError = function() {\r\n        return error;\r\n      };\r\n    },\r\n  };\r\n}\r\n","import angular from 'angular';\r\n\r\n/**\r\n * Directive that handles the model arrays\r\n */\r\nexport default function(sfSelect, sfPath, schemaForm) {\r\n  return {\r\n    scope: true,\r\n    controller: [ '$scope', function SFArrayController($scope) {\r\n      this.key = ($scope.form && $scope.form.key) ? $scope.form.key.splice(0, -2) : [];\r\n    } ],\r\n    link: function(scope, element, attrs) {\r\n      scope.min = 0;\r\n\r\n      scope.trackBy = function (item, index) {\r\n        if(item && typeof item === 'object') return item;\r\n        return index;\r\n      };\r\n\r\n      scope.modelArray = scope.$eval(attrs.sfNewArray);\r\n\r\n      // We need to have a ngModel to hook into validation. It doesn't really play well with\r\n      // arrays though so we both need to trigger validation and onChange.\r\n      // So we watch the value as well. But watching an array can be tricky. We wan't to know\r\n      // when it changes so we can validate,\r\n      let watchFn = function() {\r\n        // scope.modelArray = modelArray;\r\n        scope.modelArray = scope.$eval(attrs.sfNewArray);\r\n        // validateField method is exported by schema-validate\r\n        if (scope.ngModel && scope.ngModel.$pristine && scope.firstDigest &&\r\n            (!scope.options || scope.options.validateOnRender !== true)) {\r\n          return;\r\n        }\r\n        else if (scope.validateField) {\r\n          scope.validateField();\r\n        }\r\n      };\r\n\r\n      let onChangeFn = function() {\r\n        if (scope.form && scope.form.onChange) {\r\n          if (angular.isFunction(scope.form.onChange)) {\r\n            scope.form.onChange(scope.modelArray, scope.form);\r\n          }\r\n          else {\r\n            scope.evalExpr(scope.form.onChange, { 'modelValue': scope.modelArray, 'form': scope.form });\r\n          }\r\n        }\r\n      };\r\n\r\n      // If model is undefined make sure it gets set.\r\n      let getOrCreateModel = function() {\r\n        let model = scope.modelArray;\r\n        if (!model) {\r\n          let selection = sfPath.parse(attrs.sfNewArray);\r\n          model = [];\r\n          sfSelect(selection, scope, model);\r\n          scope.modelArray = model;\r\n        }\r\n        return model;\r\n      };\r\n\r\n      // We need the form definition to make a decision on how we should listen.\r\n      let once = scope.$watch('form', function(form) {\r\n        if (!form) {\r\n          return;\r\n        }\r\n\r\n        // Always start with one empty form unless configured otherwise.\r\n        // Special case: don't do it if form has a titleMap\r\n        if (!form.titleMap && form.startEmpty !== true && (!scope.modelArray || scope.modelArray.length === 0)) {\r\n          scope.appendToArray();\r\n        }\r\n\r\n        scope.$watch(\r\n          ($scope) => { return JSON.stringify($scope.modelArray); },\r\n          () => { watchFn(); onChangeFn(); }\r\n        );\r\n\r\n        // Title Map handling\r\n        // If form has a titleMap configured we'd like to enable looping over\r\n        // titleMap instead of modelArray, this is used for intance in\r\n        // checkboxes. So instead of letiable number of things we like to create\r\n        // a array value from a subset of values in the titleMap.\r\n        // The problem here is that ng-model on a checkbox doesn't really map to\r\n        // a list of values. This is here to fix that.\r\n        if (form.titleMap && form.titleMap.length > 0) {\r\n          scope.titleMapValues = [];\r\n\r\n          // We watch the model for changes and the titleMapValues to reflect\r\n          // the modelArray\r\n          let updateTitleMapValues = function(arr) {\r\n            scope.titleMapValues = [];\r\n            arr = arr || [];\r\n\r\n            form.titleMap.forEach(function(item) {\r\n              scope.titleMapValues.push(arr.indexOf(item.value) !== -1);\r\n            });\r\n          };\r\n\r\n          // Catch default values\r\n          updateTitleMapValues(scope.modelArray);\r\n\r\n          // TODO: Refactor and see if we can get rid of this watch by piggy backing on the\r\n          // validation watch.\r\n          scope.$watchCollection('modelArray', updateTitleMapValues);\r\n\r\n          // To get two way binding we also watch our titleMapValues\r\n          scope.$watchCollection('titleMapValues', function(vals, old) {\r\n            if (vals && vals !== old) {\r\n              let arr = getOrCreateModel();\r\n\r\n              form.titleMap.forEach(function(item, index) {\r\n                let arrIndex = arr.indexOf(item.value);\r\n                if (arrIndex === -1 && vals[index]) {\r\n                  arr.push(item.value);\r\n                };\r\n\r\n                if (arrIndex !== -1 && !vals[index]) {\r\n                  arr.splice(arrIndex, 1);\r\n                };\r\n              });\r\n              // Time to validate the rebuilt array.\r\n              // validateField method is exported by schema-validate\r\n              if (scope.validateField) {\r\n                scope.validateField();\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        once();\r\n      });\r\n\r\n      scope.appendToArray = function() {\r\n        let empty;\r\n\r\n        // Create and set an array if needed.\r\n        let model = getOrCreateModel();\r\n\r\n        // Same old add empty things to the array hack :(\r\n        if (scope.form && scope.form.schema && scope.form.schema.items) {\r\n          let items = scope.form.schema.items;\r\n          if (items.type && items.type.indexOf('object') !== -1) {\r\n            empty = {};\r\n\r\n            // Check for possible defaults\r\n            if (!scope.options || scope.options.setSchemaDefaults !== false) {\r\n              empty = angular.isDefined(items['default']) ? items['default'] : empty;\r\n\r\n              // Check for defaults further down in the schema.\r\n              // If the default instance sets the new array item to something falsy, i.e. null\r\n              // then there is no need to go further down.\r\n              if (empty) {\r\n                schemaForm.traverseSchema(items, function(prop, path) {\r\n                  if (angular.isDefined(prop['default'])) {\r\n                    sfSelect(path, empty, prop['default']);\r\n                  }\r\n                });\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            if (items.type) {\r\n              if(items.type.indexOf('array') !== -1) {\r\n                empty = [];\r\n              }\r\n              else if(items.type.indexOf('string') !== -1 || items.type.indexOf('number') !== -1) {\r\n                empty = '';\r\n              }\r\n            }\r\n            // No type? could still have defaults.\r\n            if (!scope.options || scope.options.setSchemaDefaults !== false) {\r\n              empty = items['default'] || empty;\r\n            }\r\n          }\r\n        }\r\n        model.push(empty);\r\n\r\n        return model;\r\n      };\r\n\r\n      scope.deleteFromArray = function(item) {\r\n        let index = scope.modelArray.indexOf(item);\r\n        let model = scope.modelArray;\r\n        if (model) {\r\n          model.splice(index, 1);\r\n        }\r\n\r\n        if(item.$$hashKey) {\r\n          scope.destroyed = item.$$hashKey;\r\n        }\r\n\r\n        return model;\r\n      };\r\n\r\n      // For backwards compatability, i.e. when a bootstrap-decorator tag is used\r\n      // as child to the array.\r\n      let setIndex = function(index) {\r\n        return function(form) {\r\n          if (form.key) {\r\n            form.key[form.key.indexOf('')] = index;\r\n          }\r\n        };\r\n      };\r\n\r\n      let formDefCache = {};\r\n      scope.copyWithIndex = function(index) {\r\n        let form = scope.form;\r\n        if (!formDefCache[index]) {\r\n          // To be more compatible with JSON Form we support an array of items\r\n          // in the form definition of \"array\" (the schema just a value).\r\n          // for the subforms code to work this means we wrap everything in a\r\n          // section. Unless there is just one.\r\n          let subForm = form.items[0];\r\n          if (form.items.length > 1) {\r\n            subForm = {\r\n              type: 'section',\r\n              items: form.items.map(function(item) {\r\n                item.ngModelOptions = form.ngModelOptions;\r\n                if (angular.isUndefined(item.readonly)) {\r\n                  item.readonly = form.readonly;\r\n                }\r\n                return item;\r\n              }),\r\n            };\r\n          }\r\n\r\n          if (subForm) {\r\n            let copy = angular.copy(subForm);\r\n            copy.arrayIndex = index;\r\n            schemaForm.traverseForm(copy, setIndex(index));\r\n            formDefCache[index] = copy;\r\n          }\r\n        }\r\n        return formDefCache[index];\r\n      };\r\n    },\r\n  };\r\n}\r\n","import angular from 'angular';\r\n\r\n/**\r\n * A version of ng-changed that only listens if\r\n * there is actually a onChange defined on the form\r\n *\r\n * Takes the form definition as argument.\r\n * If the form definition has a \"onChange\" defined as either a function or\r\n */\r\nexport default function() {\r\n  return {\r\n    require: 'ngModel',\r\n    restrict: 'AC',\r\n    scope: false,\r\n    link: function(scope, element, attrs, ctrl) {\r\n      let form = scope.$eval(attrs.sfChanged);\r\n      // \"form\" is really guaranteed to be here since the decorator directive\r\n      // waits for it. But best be sure.\r\n      if (form && form.onChange) {\r\n        ctrl.$viewChangeListeners.push(function() {\r\n          if (angular.isFunction(form.onChange)) {\r\n            form.onChange(ctrl.$modelValue, form);\r\n          }\r\n          else {\r\n            scope.evalExpr(form.onChange, {\r\n              'modelValue': ctrl.$modelValue,\r\n              'form': form,\r\n              'arrayIndex': scope.$index,\r\n              'arrayIndices': scope.arrayIndices,\r\n              'path': scope.path,\r\n              '$i': scope.$i,\r\n              '$index': scope.$index,\r\n            });\r\n          }\r\n        });\r\n      }\r\n    },\r\n  };\r\n}\r\n","import angular from 'angular';\r\n\r\n/**\r\n * I am the directive for managing field properties\r\n *\r\n * @param  {function} $parse\r\n * @param  {function} $compile\r\n * @param  {function} $interpolate\r\n * @param  {object}   sfErrorMessage\r\n * @param  {object}   sfPath\r\n * @param  {function} sfSelect\r\n *\r\n * @return {object}   I am the object providing the directive API to Angular\r\n */\r\nexport default function($parse, $compile, $interpolate, sfErrorMessage, sfPath, sfSelect) {\r\n  const keyFormat = {\r\n    COMPLETE: '*',\r\n    PATH: 'string',\r\n    INDICES: 'number',\r\n  };\r\n\r\n  return {\r\n    restrict: 'AE',\r\n    replace: false,\r\n    transclude: false,\r\n    scope: true,\r\n    require: [ '^sfSchema', '?^form', '?^^sfKeyController' ],\r\n    link: {\r\n      pre: function(scope, element, attrs, ctrl) {\r\n        let sfSchema = ctrl[0];\r\n\r\n        // The ngModelController is used in some templates and\r\n        // is needed for error messages,\r\n        scope.$on('schemaFormPropagateNgModelController', function(event, ngModel) {\r\n          event.stopPropagation();\r\n          event.preventDefault();\r\n          scope.ngModel = ngModel;\r\n        });\r\n\r\n        // Fetch our form.\r\n        scope.initialForm = Object.assign({}, sfSchema.lookup['f' + attrs.sfField]);\r\n        scope.form = sfSchema.lookup['f' + attrs.sfField];\r\n      },\r\n      post: function(scope, element, attrs, ctrl) {\r\n        let sfSchema = ctrl[0];\r\n        let formCtrl = ctrl[1];\r\n\r\n        scope.getKey = function(requiredFormat) {\r\n          let format = requiredFormat || keyFormat.COMPLETE;\r\n          let key = (scope.parentKey) ? scope.parentKey.slice(0, scope.parentKey.length-1) : [];\r\n\r\n          // Only calculate completeKey if not already saved to form.key\r\n          if(scope.completeKey !== scope.form.key) {\r\n            if (typeof scope.$index === 'number') {\r\n              key = key.concat(scope.$index);\r\n            }\r\n\r\n            if(scope.form.key && scope.form.key.length) {\r\n              if(typeof key[key.length-1] === 'number' && scope.form.key.length >= 1) {\r\n                let trim = scope.form.key.length - key.length;\r\n                scope.completeKey =\r\n                  trim > 0 ? key.concat(scope.form.key.slice(-trim)) : key;\r\n              }\r\n              else {\r\n                scope.completeKey = scope.form.key.slice();\r\n              }\r\n            }\r\n          }\r\n\r\n          // If there is no key then there's nothing to return\r\n          if(!Array.isArray(scope.completeKey)) {\r\n            return undefined;\r\n          }\r\n\r\n          // return the full key if not omiting any types via reduce\r\n          if (format === keyFormat.COMPLETE) {\r\n            return scope.completeKey;\r\n          }\r\n          else {\r\n            // else to clearly show that data must be ommited\r\n            return scope.completeKey.reduce((output, input, i) => {\r\n              if (-1 !== [ format ].indexOf((typeof input))) {\r\n                return output.concat(input);\r\n              }\r\n              return output;\r\n            }, []);\r\n          }\r\n        };\r\n\r\n        // Now that getKey is defined, run it! ...if there's a key.\r\n        if(scope.form.key) {\r\n          scope.form.key = scope.completeKey = scope.getKey();\r\n        }\r\n\r\n        // Keep error prone logic from the template\r\n        scope.showTitle = function() {\r\n          return scope.form && scope.form.notitle !== true && scope.form.title;\r\n        };\r\n\r\n        // Normalise names and ids\r\n        scope.fieldId = function(prependFormName, omitArrayIndexes) {\r\n          let omit = omitArrayIndexes || false;\r\n          let formName = (prependFormName && formCtrl && formCtrl.$name) ? formCtrl.$name : undefined;\r\n          let key = scope.completeKey;\r\n\r\n          if(Array.isArray(key)) {\r\n            return sfPath.name(key, '-', formName, omit);\r\n          }\r\n          else {\r\n            return '';\r\n          }\r\n        };\r\n\r\n        scope.listToCheckboxValues = function(list) {\r\n          let values = {};\r\n          angular.forEach(list, function(v) {\r\n            values[v] = true;\r\n          });\r\n          return values;\r\n        };\r\n\r\n        scope.checkboxValuesToList = function(values) {\r\n          let lst = [];\r\n          angular.forEach(values, function(v, k) {\r\n            if (v) {\r\n              lst.push(k);\r\n            }\r\n          });\r\n          return lst;\r\n        };\r\n\r\n        scope.buttonClick = function($event, form) {\r\n          if (angular.isFunction(form.onClick)) {\r\n            form.onClick($event, form);\r\n          }\r\n          else if (angular.isString(form.onClick)) {\r\n            if (sfSchema) {\r\n              // evaluating in scope outside of sfSchemas isolated scope\r\n              sfSchema.evalInParentScope(form.onClick, { '$event': $event, 'form': form });\r\n            }\r\n            else {\r\n              scope.$eval(form.onClick, { '$event': $event, 'form': form });\r\n            }\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Evaluate an expression, i.e. scope.$eval\r\n         * but do it in sfSchemas parent scope sf-schema directive is used\r\n         *\r\n         * @param {string} expression\r\n         * @param {Object} locals (optional)\r\n         * @return {Any} the result of the expression\r\n         */\r\n        scope.evalExpr = function(expression, locals) {\r\n          if (sfSchema) {\r\n            // evaluating in scope outside of sfSchemas isolated scope\r\n            return sfSchema.evalInParentScope(expression, locals);\r\n          }\r\n\r\n          return scope.$eval(expression, locals);\r\n        };\r\n\r\n        /**\r\n         * Evaluate an expression, i.e. scope.$eval\r\n         * in this decorators scope\r\n         *\r\n         * @param {string} expression\r\n         * @param {Object} locals (optional)\r\n         * @return {Any} the result of the expression\r\n         */\r\n        scope.evalInScope = function(expression, locals) {\r\n          if (expression) {\r\n            return scope.$eval(expression, locals);\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Interpolate the expression.\r\n         * Similar to `evalExpr()` and `evalInScope()`\r\n         * but will not fail if the expression is\r\n         * text that contains spaces.\r\n         *\r\n         * Use the Angular `{{ interpolation }}`\r\n         * braces to access properties on `locals`.\r\n         *\r\n         * @param  {string} expression The string to interpolate.\r\n         * @param  {Object} locals (optional) Properties that may be accessed in the\r\n         *                         `expression` string.\r\n         * @return {Any} The result of the expression or `undefined`.\r\n         */\r\n        scope.interp = function(expression, locals) {\r\n          return (expression && $interpolate(expression)(locals));\r\n        };\r\n\r\n        // This works since we get the ngModel from the array or the schema-validate directive.\r\n        scope.hasSuccess = function() {\r\n          if (!scope.ngModel) {\r\n            return false;\r\n          }\r\n          if (scope.options && scope.options.pristine &&\r\n              scope.options.pristine.success === false) {\r\n            return scope.ngModel.$valid &&\r\n                !scope.ngModel.$pristine && !scope.ngModel.$isEmpty(scope.ngModel.$modelValue);\r\n          }\r\n          else {\r\n            return scope.ngModel.$valid &&\r\n              (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue));\r\n          }\r\n        };\r\n\r\n        scope.hasError = function() {\r\n          if (!scope.ngModel) {\r\n            return false;\r\n          }\r\n          if (!scope.options || !scope.options.pristine || scope.options.pristine.errors !== false) {\r\n            // Show errors in pristine forms. The default.\r\n            // Note that \"validateOnRender\" option defaults to *not* validate initial form.\r\n            // so as a default there won't be any error anyway, but if the model is modified\r\n            // from the outside the error will show even if the field is pristine.\r\n            return scope.ngModel.$invalid;\r\n          }\r\n          else {\r\n            // Don't show errors in pristine forms.\r\n            return scope.ngModel.$invalid && !scope.ngModel.$pristine;\r\n          }\r\n        };\r\n\r\n        /**\r\n         * DEPRECATED: use sf-messages instead.\r\n         * Error message handler\r\n         * An error can either be a schema validation message or a angular js validtion\r\n         * error (i.e. required)\r\n         */\r\n        scope.errorMessage = function(schemaError) {\r\n          return sfErrorMessage.interpolate(\r\n            (schemaError && schemaError.code + '') || 'default',\r\n            (scope.ngModel && scope.ngModel.$modelValue) || '',\r\n            (scope.ngModel && scope.ngModel.$viewValue) || '',\r\n            scope.form,\r\n            scope.options && scope.options.validationMessage\r\n          );\r\n        };\r\n\r\n        // append the field-id to the htmlClass\r\n        scope.form.htmlClass = scope.form.htmlClass || '';\r\n        scope.idClass = scope.fieldId(false) + ' ' + scope.fieldId(false, true);\r\n\r\n        let form = scope.form;\r\n\r\n        // Where there is a key there is probably a ngModel\r\n        if (form.key) {\r\n          // It looks better with dot notation.\r\n          scope.$on(\r\n            'schemaForm.error.' + form.key.join('.'),\r\n            function(event, error, validationMessage, validity, formName) {\r\n              // validationMessage and validity are mutually exclusive\r\n              formName = validity;\r\n              if (validationMessage === true || validationMessage === false) {\r\n                validity = validationMessage;\r\n                validationMessage = undefined;\r\n              };\r\n\r\n              // If we have specified a form name, and this model is not within\r\n              // that form, then leave things be.\r\n              if (formName != undefined && scope.ngModel.$$parentForm.$name !== formName) {\r\n                return;\r\n              };\r\n\r\n              if (scope.ngModel && error) {\r\n                if (scope.ngModel.$setDirty) {\r\n                  scope.ngModel.$setDirty();\r\n                }\r\n                else {\r\n                  // FIXME: Check that this actually works on 1.2\r\n                  scope.ngModel.$dirty = true;\r\n                  scope.ngModel.$pristine = false;\r\n                }\r\n\r\n                // Set the new validation message if one is supplied\r\n                // Does not work when validationMessage is just a string.\r\n                if (validationMessage) {\r\n                  if (!form.validationMessage) {\r\n                    form.validationMessage = {};\r\n                  }\r\n                  form.validationMessage[error] = validationMessage;\r\n                }\r\n\r\n                scope.ngModel.$setValidity(error, validity === true);\r\n\r\n                if (validity === true) {\r\n                  // Re-trigger model validator, that model itself would be re-validated\r\n                  scope.ngModel.$validate();\r\n\r\n                  // Setting or removing a validity can change the field to believe its valid\r\n                  // but its not. So lets trigger its validation as well.\r\n                  scope.$broadcast('schemaFormValidate');\r\n                }\r\n              }\r\n            }\r\n          );\r\n\r\n          // Clean up the model when the corresponding form field is $destroy-ed.\r\n          // Default behavior can be supplied as a globalOption, and behavior can be overridden\r\n          // in the form definition.\r\n          scope.$on('$destroy', function() {\r\n            let key = scope.getKey();\r\n\r\n            // If the entire schema form is destroyed we don't touch the model\r\n            if (!scope.externalDestructionInProgress) {\r\n              const destroyStrategy = form.destroyStrategy ||\r\n                                    (scope.options && scope.options.destroyStrategy) || 'remove';\r\n              // No key no model, and we might have strategy 'retain'\r\n              if (key && destroyStrategy !== 'retain') {\r\n                let obj = scope.model;\r\n\r\n                if (key.length > 1) {\r\n                  obj = sfSelect(key.slice(0, key.length - 1), obj);\r\n                }\r\n\r\n                if(obj && scope.destroyed && obj.$$hashKey && obj.$$hashKey !== scope.destroyed) {\t\t\r\n                  return;\r\n                }\r\n\r\n                // We can get undefined here if the form hasn't been filled out entirely\r\n                if (obj === undefined) {\r\n                  return;\r\n                }\r\n\r\n                // Type can also be a list in JSON Schema\r\n                const type = (form.schema && form.schema.type) || '';\r\n\r\n                // Empty means '',{} and [] for appropriate types and undefined for the rest\r\n                let value;\r\n                if (destroyStrategy === 'empty') {\r\n                  value = type.indexOf('string') !== -1 ? '' :\r\n                    type.indexOf('object') !== -1 ? {} :\r\n                    type.indexOf('array') !== -1 ? [] : undefined;\r\n                }\r\n                else if (destroyStrategy === 'null') {\r\n                  value = null;\r\n                }\r\n\r\n                if (value !== undefined) {\r\n                  sfSelect(key, scope.model, value);\r\n                }\r\n                else {\r\n                  // Get the object parent object\r\n                  let obj = scope.model;\r\n                  if (key.length > 1) {\r\n                    obj = sfSelect(key.slice(0, key.length - 1), obj);\r\n                  }\r\n\r\n                  // parent can be undefined if the form hasn't been filled out\r\n                  // entirely\r\n                  if (obj === undefined) {\r\n                    return;\r\n                  }\r\n\r\n                  // if parent is an array, then we have already been removed.\r\n                  // set flag to all children (who are about to recieve a $destroy\r\n                  // event as well) that we have already been destroyed\r\n                  if (angular.isArray(obj)) {\r\n                    scope.externalDestructionInProgress = true;\r\n                    return;\r\n                  }\r\n\r\n                  delete obj[key[key.length-1]];\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n      },\r\n    },\r\n  };\r\n}\r\n","/**\r\n * I am the directive that handles keys and array indexes\r\n *\r\n * @param  {function} sfPath\r\n *\r\n * @return {[type]}            [description]\r\n */\r\nexport default function(sfPath) {\r\n  return {\r\n    scope: true,\r\n    require: [ '?^^sfNewArray' ],\r\n    link: {\r\n      pre: function(scope, element, attrs, ctrl) {\r\n        scope.parentKey = scope.parentKey || [];\r\n\r\n        let currentKey = sfPath.parse(attrs.sfParentKey);\r\n        let trim = currentKey.length - scope.parentKey.length;\r\n\r\n        if(currentKey.length > 1) currentKey = currentKey.splice(-trim);\r\n\r\n        scope.parentKey = scope.parentKey.concat(currentKey, Number(attrs.sfIndex));\r\n        scope.arrayIndex = Number(attrs.sfIndex);\r\n        scope.arrayIndices = scope.arrayIndices || [];\r\n        scope.arrayIndices = scope.arrayIndices.concat(scope.arrayIndex);\r\n        scope.$i = scope.arrayIndices;\r\n        scope.path = function(modelPath) {\r\n          let i = -1;\r\n          modelPath = modelPath.replace(/\\[\\]/gi, function(matched) {\r\n            i++;\r\n            return '[' + scope.$i[i] + ']';\r\n          });\r\n          let fixedPath = scope.$eval(modelPath, scope);\r\n          return fixedPath;\r\n        };\r\n      },\r\n    },\r\n  };\r\n};\r\n","import angular from 'angular';\r\n\r\n/**\r\n * I am the messages directive for description and error message handling\r\n *\r\n * @param  {object} $injector I am the Angular injector for optional dependencies\r\n * @param  {object} sfErrorMessage I contain the interpolation function for messages\r\n *\r\n * @return {object} I am the message directive API\r\n */\r\nexport default function($injector, sfErrorMessage) {\r\n  // Inject sanitizer if it exists\r\n  let $sanitize = $injector.has('$sanitize') ?\r\n                  $injector.get('$sanitize') : function(html) { return html; };\r\n\r\n  return {\r\n    scope: false,\r\n    restrict: 'EA',\r\n    link: function(scope, element, attrs) {\r\n      let message = '';\r\n      if (attrs.sfMessage) {\r\n        scope.$watch(attrs.sfMessage, function(msg) {\r\n          if (msg) {\r\n            message = $sanitize(msg);\r\n            update(!!scope.ngModel);\r\n          }\r\n        });\r\n      }\r\n\r\n      let currentMessage;\r\n      // Only call html() if needed.\r\n      let setMessage = function(msg) {\r\n        if (msg !== currentMessage) {\r\n          element.html(msg);\r\n          currentMessage = msg;\r\n        }\r\n      };\r\n\r\n      let update = function(checkForErrors) {\r\n        if (checkForErrors) {\r\n          if (!scope.hasError()) {\r\n            setMessage(message);\r\n          }\r\n          else {\r\n            let errors = [];\r\n            angular.forEach(scope.ngModel && scope.ngModel.$error, function(status, code) {\r\n              if (status) {\r\n                // if true then there is an error\r\n                // Angular 1.3 removes properties, so we will always just have errors.\r\n                // Angular 1.2 sets them to false.\r\n                errors.push(code);\r\n              }\r\n            });\r\n\r\n            // In Angular 1.3 we use one $validator to stop the model value from getting updated.\r\n            // this means that we always end up with a 'schemaForm' error.\r\n            errors = errors.filter(function(error) { return error !== 'schemaForm'; });\r\n\r\n            // We only show one error.\r\n            // TODO: Make that optional\r\n            let error = errors[0];\r\n\r\n            if (error) {\r\n              setMessage(sfErrorMessage.interpolate(\r\n                error,\r\n                scope.ngModel.$modelValue,\r\n                scope.ngModel.$viewValue,\r\n                scope.form,\r\n                scope.options && scope.options.validationMessage\r\n              ));\r\n            }\r\n            else {\r\n              setMessage(message);\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          setMessage(message);\r\n        }\r\n      };\r\n\r\n      // Update once.\r\n      update();\r\n\r\n      let once = scope.$watch('ngModel', function(ngModel) {\r\n        if (ngModel) {\r\n          // We also listen to changes of the model via parsers and formatters.\r\n          // This is since both the error message can change and given a pristine\r\n          // option to not show errors the ngModel.$error might not have changed\r\n          // but we're not pristine any more so we should change!\r\n          ngModel.$parsers.push(function(val) { update(true); return val; });\r\n          ngModel.$formatters.push(function(val) { update(true); return val; });\r\n          once();\r\n        }\r\n      });\r\n\r\n      // We watch for changes in $error\r\n      scope.$watchCollection('ngModel.$error', function() {\r\n        update(!!scope.ngModel);\r\n      });\r\n    },\r\n  };\r\n}\r\n","import angular from 'angular';\r\n\r\n/**\r\nFIXME: real documentation\r\n<form sf-form=\"form\"  sf-schema=\"schema\" sf-decorator=\"foobar\"></form>\r\n*/\r\n/**\r\n * [description]\r\n *\r\n * @param  {Function} $compile             [description]\r\n * @param  {object}   $http                [description]\r\n * @param  {Function} $templateCache       [description]\r\n * @param  {object}   $q                   [description]\r\n * @param  {object}   schemaForm           [description]\r\n * @param  {object}   schemaFormDecorators [description]\r\n * @param  {Function} sfSelect             [description]\r\n * @param  {object}   sfBuilder            [description]\r\n *\r\n * @return {object}                        [description]\r\n */\r\nexport default function($compile, $http, $templateCache, $q, schemaForm, schemaFormDecorators,\r\nsfSelect, sfBuilder) {\r\n  return {\r\n    scope: {\r\n      schema: '=sfSchema',\r\n      initialForm: '=sfForm',\r\n      model: '=sfModel',\r\n      options: '=sfOptions',\r\n    },\r\n    controller: [ '$scope', function($scope) {\r\n      this.$onInit = function() {\r\n        this.evalInParentScope = function(expr, locals) {\r\n          return $scope.$parent.$eval(expr, locals);\r\n        };\r\n\r\n        // Set up form lookup map\r\n        let that = this;\r\n        $scope.lookup = function(lookup) {\r\n          if (lookup) {\r\n            that.lookup = lookup;\r\n          }\r\n          return that.lookup;\r\n        };\r\n      };\r\n\r\n      // Prior to v1.5, we need to call `$onInit()` manually.\r\n      // (Bindings will always be pre-assigned in these versions.)\r\n      if (angular.version.major === 1 && angular.version.minor < 5) {\r\n        this.$onInit();\r\n      }\r\n    } ],\r\n    replace: false,\r\n    restrict: 'A',\r\n    transclude: true,\r\n    require: '?form',\r\n    link: function(scope, element, attrs, formCtrl, transclude) {\r\n      // expose form controller on scope so that we don't force authors to use name on form\r\n      scope.formCtrl = formCtrl;\r\n\r\n      // We'd like to handle existing markup,\r\n      // besides using it in our template we also\r\n      // check for ng-model and add that to an ignore list\r\n      // i.e. even if form has a definition for it or form is [\"*\"]\r\n      // we don't generate it.\r\n      let ignore = {};\r\n      transclude(scope, function(clone) {\r\n        clone.addClass('schema-form-ignore');\r\n        element.prepend(clone);\r\n\r\n        if (element[0].querySelectorAll) {\r\n          let models = element[0].querySelectorAll('[ng-model]');\r\n          if (models) {\r\n            for (let i = 0; i < models.length; i++) {\r\n              let key = models[i].getAttribute('ng-model');\r\n              // skip first part before .\r\n              ignore[key.substring(key.indexOf('.') + 1)] = true;\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      let lastDigest = {};\r\n      let childScope;\r\n\r\n      // Common renderer function, can either be triggered by a watch or by an event.\r\n      scope.resolveReferences = function (schema, form) {\r\n        schemaForm\r\n          .jsonref(schema)\r\n          .then((resolved) => {\r\n            scope.render(resolved, form);\r\n          })\r\n          .catch((err) => {\r\n            new Error(err);\r\n          });\r\n      };\r\n\r\n      scope.render = function(schema, form) {\r\n        let asyncTemplates = [];\r\n        let merged = schemaForm.merge(schema, form, undefined, ignore, scope.options, undefined, asyncTemplates);\r\n\r\n        if (asyncTemplates.length > 0) {\r\n          // Pre load all async templates and put them on the form for the builder to use.\r\n          $q.all(\r\n            asyncTemplates\r\n              .map(function(form) {\r\n                return $http.get(form.templateUrl, { cache: $templateCache })\r\n                  .then(function(res) {\r\n                    form.template = res.data;\r\n                  });\r\n              })\r\n          )\r\n          .then(function() {\r\n            scope.internalRender(schema, form, merged);\r\n          });\r\n        }\r\n        else {\r\n          scope.internalRender(schema, form, merged);\r\n        };\r\n      };\r\n\r\n      scope.internalRender = function(schema, form, merged) {\r\n        // Create a new form and destroy the old one.\r\n        // Not doing keeps old form elements hanging around after\r\n        // they have been removed from the DOM\r\n        // https:// github.com/Textalk/angular-schema-form/issues/200\r\n        if (childScope) {\r\n          // Destroy strategy should not be acted upon\r\n          scope.externalDestructionInProgress = true;\r\n          childScope.$destroy();\r\n          scope.externalDestructionInProgress = false;\r\n        };\r\n        childScope = scope.$new();\r\n\r\n        // make the form available to decorators\r\n        childScope.schemaForm = { form: merged, schema: schema };\r\n\r\n        // clean all but pre existing html.\r\n        Array.prototype.forEach.call(element.children(), function(child) {\r\n          let jchild = angular.element(child);\r\n          if (false === jchild.hasClass('schema-form-ignore')) {\r\n            jchild.remove();\r\n          };\r\n        });\r\n\r\n        // Find all slots.\r\n        let slots = {};\r\n        let slotsFound = element[0].querySelectorAll('*[sf-insert-field]');\r\n\r\n        for (let i = 0; i < slotsFound.length; i++) {\r\n          slots[slotsFound[i].getAttribute('sf-insert-field')] = slotsFound[i];\r\n        }\r\n\r\n        // if sfUseDecorator is undefined the default decorator is used.\r\n        let decorator = schemaFormDecorators.decorator(attrs.sfUseDecorator);\r\n        // Use the builder to build it and append the result\r\n        let lookup = Object.create(null);\r\n        scope.lookup(lookup); // give the new lookup to the controller.\r\n        element[0].appendChild(sfBuilder.build(merged, decorator, slots, lookup));\r\n\r\n        // We need to know if we're in the first digest looping\r\n        // I.e. just rendered the form so we know not to validate\r\n        // empty fields.\r\n        childScope.firstDigest = true;\r\n        // We use a ordinary timeout since we don't need a digest after this.\r\n        setTimeout(function() {\r\n          childScope.firstDigest = false;\r\n          scope.$apply();\r\n        }, 0);\r\n\r\n        // compile only children\r\n        $compile(element.children())(childScope);\r\n\r\n        // ok, now that that is done let's set any defaults\r\n        if (!scope.options || scope.options.setSchemaDefaults !== false) {\r\n          schemaForm.traverseSchema(schema, function(prop, path) {\r\n            if (angular.isDefined(prop['default'])) {\r\n              let val = sfSelect(path, scope.model);\r\n              if (angular.isUndefined(val)) {\r\n                let defVal = prop['default'];\r\n                if (angular.isObject(defVal)) defVal = angular.copy(defVal);\r\n                sfSelect(path, scope.model, defVal);\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        scope.$emit('sf-render-finished', element);\r\n      };\r\n\r\n      let defaultForm = [ '*' ];\r\n\r\n      // Since we are dependant on up to three\r\n      // attributes we'll do a common watch\r\n      scope.$watch(function() {\r\n        let schema = scope.schema;\r\n        let form = scope.initialForm || defaultForm;\r\n\r\n        // The check for schema.type is to ensure that schema is not {}\r\n        if (form && schema && schema.type && // schema.properties &&\r\n            (lastDigest.form !== form || lastDigest.schema !== schema)) {\r\n          if((!schema.properties || Object.keys(schema.properties).length === 0) &&\r\n              (form.indexOf('*') || form.indexOf('...'))) {\r\n            // form.unshift({\"key\":\"submit\", \"type\": \"hidden\"});\r\n          };\r\n\r\n          lastDigest.schema = schema;\r\n          lastDigest.form = form;\r\n\r\n          scope.resolveReferences(schema, form);\r\n        }\r\n      });\r\n\r\n      // We also listen to the event schemaFormRedraw so you can manually trigger a change if\r\n      // part of the form or schema is chnaged without it being a new instance.\r\n      scope.$on('schemaFormRedraw', function() {\r\n        let schema = scope.schema;\r\n        let form = scope.initialForm ? angular.copy(scope.initialForm) : [ '*' ];\r\n        if (schema) {\r\n          scope.resolveReferences(schema, form);\r\n        }\r\n      });\r\n\r\n      scope.$on('$destroy', function() {\r\n        // Each field listens to the $destroy event so that it can remove any value\r\n        // from the model if that field is removed from the form. This is the default\r\n        // destroy strategy. But if the entire form (or at least the part we're on)\r\n        // gets removed, like when routing away to another page, then we definetly want to\r\n        // keep the model intact. So therefore we set a flag to tell the others it's time to just\r\n        // let it be.\r\n        scope.externalDestructionInProgress = true;\r\n      });\r\n\r\n      /**\r\n       * Evaluate an expression, i.e. scope.$eval\r\n       * but do it in parent scope\r\n       *\r\n       * @param {String} expression\r\n       * @param {Object} locals (optional)\r\n       * @return {any} the result of the expression\r\n       */\r\n      scope.evalExpr = function(expression, locals) {\r\n        return scope.$parent.$eval(expression, locals);\r\n      };\r\n    },\r\n  };\r\n}\r\n","import * as JSONSchemaFormCore from '@jsonschema/core';\r\nimport angular from 'angular';\r\n\r\n// ./services/\r\nimport sfBuilderProvider from './services/sf-builder.provider';\r\nimport schemaFormDecoratorsProvider from './services/schema-form-decorators.provider';\r\nimport schemaFormProvider from './services/schema-form.provider';\r\nimport sfErrorMessageProvider from './services/sf-error-message.provider';\r\nimport sfPathProvider from './services/sf-path.provider';\r\n// ./directives/\r\nimport sfChangedDirective from './directives/sf-changed.directive';\r\nimport sfFieldDirective from './directives/sf-field.directive';\r\nimport sfMessageDirective from './directives/sf-message.directive';\r\nimport sfArrayDirective from './directives/sf-array.directive';\r\nimport sfKeyDirective from './directives/sf-key.directive';\r\nimport sfSchemaDirective from './directives/sf-schema.directive';\r\nimport schemaValidateDirective from './directives/schema-validate.directive';\r\n\r\n// Deps is sort of a problem for us, maybe in the future we will ask the user to depend\r\n// on modules for add-ons\r\nconst deps = [];\r\n\r\ntry {\r\n  // This throws an expection if module does not exist.\r\n  angular.module('ngSanitize');\r\n  deps.push('ngSanitize');\r\n}\r\ncatch (e) {}\r\n\r\ntry {\r\n  // This throws an expection if module does not exist.\r\n  angular.module('ui.sortable');\r\n  deps.push('ui.sortable');\r\n}\r\ncatch (e) {}\r\n\r\ntry {\r\n  // This throws an expection if module does not exist.\r\n  angular.module('angularSpectrumColorpicker');\r\n  deps.push('angularSpectrumColorpicker');\r\n}\r\ncatch (e) {}\r\n\r\nangular\r\n.module('schemaForm', deps)\r\n\r\n// Providers and services\r\n.provider('sfPath', sfPathProvider)\r\n.provider('sfBuilder', [ 'sfPathProvider', sfBuilderProvider ])\r\n.provider('schemaFormDecorators', [ '$compileProvider', 'sfPathProvider', schemaFormDecoratorsProvider ])\r\n.provider('sfErrorMessage', sfErrorMessageProvider)\r\n.provider('schemaForm', [ 'sfPathProvider', schemaFormProvider ])\r\n.factory('sfSelect', () => JSONSchemaFormCore.select)\r\n.factory('sfValidator', () => JSONSchemaFormCore.validate)\r\n\r\n// Directives\r\n.directive('sfChanged', sfChangedDirective)\r\n.directive('sfField', [ '$parse', '$compile', '$interpolate', 'sfErrorMessage', 'sfPath', 'sfSelect', sfFieldDirective ])\r\n.directive('sfMessage', [ '$injector', 'sfErrorMessage', sfMessageDirective ])\r\n.directive('sfNewArray', [ 'sfSelect', 'sfPath', 'schemaForm', sfArrayDirective ])\r\n.directive('sfSchema', [ '$compile', '$http', '$templateCache', '$q',\r\n                         'schemaForm', 'schemaFormDecorators', 'sfSelect', 'sfBuilder', sfSchemaDirective ])\r\n.directive('schemaValidate', [ 'sfValidator', '$parse', 'sfSelect', '$interpolate', schemaValidateDirective ])\r\n.directive('sfKeyController', [ 'sfPath', sfKeyDirective ]);\r\n","import angular from 'angular';\r\n\r\n/**\r\n * I am the schema-form-decorators provider and manage the decorator API\r\n *\r\n * @param  {object} $compileProvider\r\n * @param  {object} sfPathProvider\r\n *\r\n * @return {object} I am the directive properties made available to Angular\r\n */\r\nexport default function($compileProvider, sfPathProvider) {\r\n  let defaultDecorator = '';\r\n  let decorators = {};\r\n\r\n  // Map template after decorator and type.\r\n  let templateUrl = function(name, form) {\r\n    // schemaDecorator is alias for whatever is set as default\r\n    if (name === 'sfDecorator') {\r\n      name = defaultDecorator;\r\n    }\r\n\r\n    let decorator = decorators[name];\r\n    if (decorator[form.type]) {\r\n      return decorator[form.type].template;\r\n    }\r\n\r\n    // try default\r\n    return decorator['default'].template;\r\n  };\r\n\r\n  /** ************************************************\r\n   * DEPRECATED                                      *\r\n   * The new builder and sf-field is preferred, but  *\r\n   * we keep this in during a transitional period    *\r\n   * so that add-ons that don't use the new builder  *\r\n   * works.                                          *\r\n   ************************************************ **/\r\n  // TODO: Move to a compatability extra script.\r\n  let createDirective = function(name) {\r\n    $compileProvider.directive(name,\r\n      [ '$parse', '$compile', '$http', '$templateCache', '$interpolate', '$q', 'sfErrorMessage',\r\n       'sfPath', 'sfSelect',\r\n      function($parse, $compile, $http, $templateCache, $interpolate, $q, sfErrorMessage,\r\n               sfPath, sfSelect) {\r\n        return {\r\n          restrict: 'AE',\r\n          replace: false,\r\n          transclude: false,\r\n          scope: true,\r\n          require: [ '?^sfSchema', '?^form' ],\r\n          link: function(scope, element, attrs, ctrl) {\r\n            let sfSchema = ctrl[0];\r\n            let formCtrl = ctrl[1];\r\n\r\n            // The ngModelController is used in some templates and\r\n            // is needed for error messages,\r\n            scope.$on('schemaFormPropagateNgModelController', function(event, ngModel) {\r\n              event.stopPropagation();\r\n              event.preventDefault();\r\n              scope.ngModel = ngModel;\r\n            });\r\n\r\n            // Keep error prone logic from the template\r\n            scope.showTitle = function() {\r\n              return scope.form && scope.form.notitle !== true && scope.form.title;\r\n            };\r\n\r\n            // Normalise names and ids\r\n            scope.fieldId = function(prependFormName, omitArrayIndexes) {\r\n              let key = scope.parentKey || [];\r\n              if(scope.form.key) {\r\n                if(typeof key[key.length-1] === 'number') {\r\n                  let combinedKey = key.concat(scope.form.key.slice(-1));\r\n                  let formName = (prependFormName && formCtrl && formCtrl.$name) ? formCtrl.$name : undefined;\r\n                  return sfPath.name(combinedKey, '-', formName, omitArrayIndexes);\r\n                }\r\n                else {\r\n                  let formName = (prependFormName && formCtrl && formCtrl.$name) ? formCtrl.$name : undefined;\r\n                  return sfPath.name(scope.form.key, '-', formName, omitArrayIndexes);\r\n                }\r\n              }\r\n              else {\r\n                return '';\r\n              }\r\n            };\r\n\r\n            scope.listToCheckboxValues = function(list) {\r\n              let values = {};\r\n              angular.forEach(list, function(v) {\r\n                values[v] = true;\r\n              });\r\n              return values;\r\n            };\r\n\r\n            scope.checkboxValuesToList = function(values) {\r\n              let lst = [];\r\n              angular.forEach(values, function(v, k) {\r\n                if (v) {\r\n                  lst.push(k);\r\n                }\r\n              });\r\n              return lst;\r\n            };\r\n\r\n            scope.buttonClick = function($event, form) {\r\n              if (angular.isFunction(form.onClick)) {\r\n                form.onClick($event, form);\r\n              }\r\n              else if (angular.isString(form.onClick)) {\r\n                if (sfSchema) {\r\n                  // evaluating in scope outside of sfSchemas isolated scope\r\n                  sfSchema.evalInParentScope(form.onClick, { '$event': $event, 'form': form });\r\n                }\r\n                else {\r\n                  scope.$eval(form.onClick, { '$event': $event, 'form': form });\r\n                };\r\n              };\r\n            };\r\n\r\n            /**\r\n             * Evaluate an expression, i.e. scope.$eval\r\n             * but do it in sfSchemas parent scope sf-schema directive is used\r\n             *\r\n             * @param {string} expression\r\n             * @param {Object} locals (optional)\r\n             * @return {Any} the result of the expression\r\n             */\r\n            scope.evalExpr = function(expression, locals) {\r\n              if (sfSchema) {\r\n                // evaluating in scope outside of sfSchemas isolated scope\r\n                return sfSchema.evalInParentScope(expression, locals);\r\n              }\r\n\r\n              return scope.$eval(expression, locals);\r\n            };\r\n\r\n            /**\r\n             * Evaluate an expression, i.e. scope.$eval\r\n             * in this decorators scope\r\n             *\r\n             * @param {string} expression\r\n             * @param {Object} locals (optional)\r\n             * @return {Any} the result of the expression\r\n             */\r\n            scope.evalInScope = function(expression, locals) {\r\n              if (expression) {\r\n                return scope.$eval(expression, locals);\r\n              }\r\n            };\r\n\r\n            /**\r\n             * Interpolate the expression.\r\n             * Similar to `evalExpr()` and `evalInScope()`\r\n             * but will not fail if the expression is\r\n             * text that contains spaces.\r\n             *\r\n             * Use the Angular `{{ interpolation }}`\r\n             * braces to access properties on `locals`.\r\n             *\r\n             * @param  {string} expression The string to interpolate.\r\n             * @param  {Object} locals (optional) Properties that may be accessed in the\r\n             *                         `expression` string.\r\n             * @return {Any} The result of the expression or `undefined`.\r\n             */\r\n            scope.interp = function(expression, locals) {\r\n              return (expression && $interpolate(expression)(locals));\r\n            };\r\n\r\n            // This works since we ot the ngModel from the array or the schema-validate directive.\r\n            scope.hasSuccess = function() {\r\n              if (!scope.ngModel) {\r\n                return false;\r\n              }\r\n              if (scope.options && scope.options.pristine &&\r\n                  scope.options.pristine.success === false) {\r\n                return scope.ngModel.$valid &&\r\n                (!scope.ngModel.$pristine && !scope.ngModel.$isEmpty(scope.ngModel.$modelValue));\r\n              }\r\n              else {\r\n                return scope.ngModel.$valid &&\r\n                (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue));\r\n              }\r\n            };\r\n\r\n            scope.hasError = function() {\r\n              if (!scope.ngModel) {\r\n                return false;\r\n              }\r\n              return scope.ngModel.$invalid && !scope.ngModel.$pristine;\r\n            };\r\n\r\n            /**\r\n             * DEPRECATED: use sf-messages instead.\r\n             * Error message handler\r\n             * An error can either be a schema validation message or a angular js validtion\r\n             * error (i.e. required)\r\n             */\r\n            scope.errorMessage = function(schemaError) {\r\n              return sfErrorMessage.interpolate(\r\n                (schemaError && schemaError.code + '') || 'default',\r\n                (scope.ngModel && scope.ngModel.$modelValue) || '',\r\n                (scope.ngModel && scope.ngModel.$viewValue) || '',\r\n                scope.form,\r\n                scope.options && scope.options.validationMessage\r\n              );\r\n            };\r\n\r\n            // Rebind our part of the form to the scope.\r\n            let once = scope.$watch(attrs.form, function(form) {\r\n              if (form) {\r\n                // Workaround for 'updateOn' error from ngModelOptions\r\n                // see https:// github.com/Textalk/angular-schema-form/issues/255\r\n                // and https:// github.com/Textalk/angular-schema-form/issues/206\r\n                form.ngModelOptions = form.ngModelOptions || {};\r\n                scope.form = form;\r\n\r\n                // ok let's replace that template!\r\n                // We do this manually since we need to bind ng-model properly and also\r\n                // for fieldsets to recurse properly.\r\n                let templatePromise;\r\n\r\n                // type: \"template\" is a special case. It can contain a template inline or an url.\r\n                // otherwise we find out the url to the template and load them.\r\n                if (form.type === 'template' && form.template) {\r\n                  templatePromise = $q.when(form.template);\r\n                }\r\n                else {\r\n                  let url = form.type === 'template' ? form.templateUrl : templateUrl(name, form);\r\n                  templatePromise = $http.get(url, { cache: $templateCache }).then(function(res) {\r\n                                      return res.data;\r\n                                    });\r\n                }\r\n\r\n                templatePromise.then(function(template) {\r\n                  if (form.key) {\r\n                    let key = form.key ?\r\n                              sfPathProvider.stringify(form.key).replace(/\"/g, '&quot;') : '';\r\n                    template = template.replace(\r\n                      /\\$\\$value\\$\\$/g,\r\n                      'model' + (key[0] !== '[' ? '.' : '') + key\r\n                    );\r\n                  }\r\n                  element.html(template);\r\n\r\n                  // Do we have a condition? Then we slap on an ng-if on all children,\r\n                  // but be nice to existing ng-if.\r\n                  if (form.condition) {\r\n                    let evalExpr = 'evalExpr(form.condition,{ model: model, \"arrayIndex\": arrayIndex})';\r\n                    if (form.key) {\r\n                      evalExpr = 'evalExpr(form.condition, {' +\r\n                        'model: model, \"arrayIndex\": arrayIndex, \"modelValue\": model' + sfPath.stringify(form.key) +\r\n                      '})';\r\n                    }\r\n\r\n                    angular.forEach(element.children(), function(child) {\r\n                      let ngIf = child.getAttribute('ng-if');\r\n                      child.setAttribute(\r\n                        'ng-if',\r\n                        ngIf ?\r\n                        '(' + ngIf +\r\n                        ') || (' + evalExpr + ')'\r\n                        : evalExpr\r\n                      );\r\n                    });\r\n                  }\r\n                  $compile(element.contents())(scope);\r\n                });\r\n\r\n                // Where there is a key there is probably a ngModel\r\n                if (form.key) {\r\n                  // It looks better with dot notation.\r\n                  scope.$on(\r\n                    'schemaForm.error.' + form.key.join('.'),\r\n                    function(event, error, validationMessage, validity, formName) {\r\n                      // validationMessage and validity are mutually exclusive\r\n                      formName = validity;\r\n                      if (validationMessage === true || validationMessage === false) {\r\n                        validity = validationMessage;\r\n                        validationMessage = undefined;\r\n                      };\r\n\r\n                      // If we have specified a form name, and this model is not within\r\n                      // that form, then leave things be.\r\n                      if (formName != undefined && scope.ngModel.$$parentForm.$name !== formName) {\r\n                        return;\r\n                      };\r\n\r\n                      // If we have specified a form name, and this model is not within\r\n                      // that form, then leave things be.\r\n                      if(formName != undefined && scope.ngModel.$$parentForm.$name !== formName) {\r\n                        return;\r\n                      }\r\n\r\n                      if (scope.ngModel && error) {\r\n                        if (scope.ngModel.$setDirty) {\r\n                          scope.ngModel.$setDirty();\r\n                        }\r\n                        else {\r\n                          // FIXME: Check that this actually works on 1.2\r\n                          scope.ngModel.$dirty = true;\r\n                          scope.ngModel.$pristine = false;\r\n                        };\r\n\r\n                        // Set the new validation message if one is supplied\r\n                        // Does not work when validationMessage is just a string.\r\n                        if (validationMessage) {\r\n                          if (!form.validationMessage) {\r\n                            form.validationMessage = {};\r\n                          }\r\n                          form.validationMessage[error] = validationMessage;\r\n                        }\r\n\r\n                        scope.ngModel.$setValidity(error, validity === true);\r\n\r\n                        if (validity === true) {\r\n                          // Re-trigger model validator, that model itself would be re-validated\r\n                          scope.ngModel.$validate();\r\n\r\n                          // Setting or removing a validity can change the field to believe its valid\r\n                          // but its not. So lets trigger its validation as well.\r\n                          scope.$broadcast('schemaFormValidate');\r\n                        }\r\n                      }\r\n                    }\r\n                  );\r\n\r\n                  // Clean up the model when the corresponding form field is $destroy-ed.\r\n                  // Default behavior can be supplied as a globalOption, and behavior can be overridden\r\n                  // in the form definition.\r\n                  scope.$on('$destroy', function() {\r\n                    // If the entire schema form is destroyed we don't touch the model\r\n                    if (!scope.externalDestructionInProgress) {\r\n                      let destroyStrategy = form.destroyStrategy ||\r\n                                            (scope.options && scope.options.destroyStrategy) || 'remove';\r\n                      // No key no model, and we might have strategy 'retain'\r\n                      if (form.key && destroyStrategy !== 'retain') {\r\n                        // Get the object that has the property we wan't to clear.\r\n                        let obj = scope.model;\r\n                        if (form.key.length > 1) {\r\n                          obj = sfSelect(form.key.slice(0, form.key.length - 1), obj);\r\n                        }\r\n\r\n                        // We can get undefined here if the form hasn't been filled out entirely\r\n                        if (obj === undefined) {\r\n                          return;\r\n                        }\r\n\r\n                        // Type can also be a list in JSON Schema\r\n                        let type = (form.schema && form.schema.type) || '';\r\n\r\n                        // Empty means '',{} and [] for appropriate types and undefined for the rest\r\n                        if (destroyStrategy === 'empty' && type.indexOf('string') !== -1) {\r\n                          obj[form.key.slice(-1)] = '';\r\n                        }\r\n                        else if (destroyStrategy === 'empty' && type.indexOf('object') !== -1) {\r\n                          obj[form.key.slice(-1)] = {};\r\n                        }\r\n                        else if (destroyStrategy === 'empty' && type.indexOf('array') !== -1) {\r\n                          obj[form.key.slice(-1)] = [];\r\n                        }\r\n                        else if (destroyStrategy === 'null') {\r\n                          obj[form.key.slice(-1)] = null;\r\n                        }\r\n                        else {\r\n                          delete obj[form.key.slice(-1)];\r\n                        }\r\n                      }\r\n                    }\r\n                  });\r\n                }\r\n\r\n                once();\r\n              }\r\n            });\r\n          },\r\n        };\r\n      },\r\n    ]);\r\n  };\r\n\r\n  let createManualDirective = function(type, templateUrl, transclude) {\r\n    transclude = angular.isDefined(transclude) ? transclude : false;\r\n    $compileProvider.directive('sf' + angular.uppercase(type[0]) + type.substr(1), function() {\r\n      return {\r\n        restrict: 'EAC',\r\n        scope: true,\r\n        replace: true,\r\n        transclude: transclude,\r\n        template: '<sf-decorator form=\"form\"></sf-decorator>',\r\n        link: function(scope, element, attrs) {\r\n          let watchThis = {\r\n            'items': 'c',\r\n            'titleMap': 'c',\r\n            'schema': 'c',\r\n          };\r\n          let form = { type: type };\r\n          let once = true;\r\n          angular.forEach(attrs, function(value, name) {\r\n            if (name[0] !== '$' && name.indexOf('ng') !== 0 && name !== 'sfField') {\r\n              let updateForm = function(val) {\r\n                if (angular.isDefined(val) && val !== form[name]) {\r\n                  form[name] = val;\r\n\r\n                  // when we have type, and if specified key we apply it on scope.\r\n                  if (once && form.type && (form.key || angular.isUndefined(attrs.key))) {\r\n                    scope.form = form;\r\n                    once = false;\r\n                  }\r\n                }\r\n              };\r\n\r\n              if (name === 'model') {\r\n                // \"model\" is bound to scope under the name \"model\" since this is what the decorators\r\n                // know and love.\r\n                scope.$watch(value, function(val) {\r\n                  if (val && scope.model !== val) {\r\n                    scope.model = val;\r\n                  }\r\n                });\r\n              }\r\n              else if (watchThis[name] === 'c') {\r\n                // watch collection\r\n                scope.$watchCollection(value, updateForm);\r\n              }\r\n              else {\r\n                // $observe\r\n                attrs.$observe(name, updateForm);\r\n              }\r\n            }\r\n          });\r\n        },\r\n      };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * DEPRECATED: use defineDecorator instead.\r\n   * Create a decorator directive and its sibling \"manual\" use decorators.\r\n   * The directive can be used to create form fields or other form entities.\r\n   * It can be used in conjunction with <schema-form> directive in which case the decorator is\r\n   * given it's configuration via a the \"form\" attribute.\r\n   *\r\n   * ex. Basic usage\r\n   *   <sf-decorator form=\"myform\"></sf-decorator>\r\n   **\r\n   * @param {string} name directive name (CamelCased)\r\n   * @param {Object} templates, an object that maps \"type\" => \"templateUrl\"\r\n   */\r\n  this.createDecorator = function(name, templates) {\r\n    // console.warn('schemaFormDecorators.createDecorator is DEPRECATED, use defineDecorator instead.');\r\n    decorators[name] = { '__name': name };\r\n\r\n    angular.forEach(templates, function(url, type) {\r\n      decorators[name][type] = { template: url, replace: false, builder: []};\r\n    });\r\n\r\n    if (!decorators[defaultDecorator]) {\r\n      defaultDecorator = name;\r\n    }\r\n    createDirective(name);\r\n  };\r\n\r\n  /**\r\n   * Define a decorator. A decorator is a set of form types with templates and builder functions\r\n   * that help set up the form.\r\n   *\r\n   * @param {string} name directive name (CamelCased)\r\n   * @param {Object} fields, an object that maps \"type\" => `{ template, builder, replace}`.\r\n                     attributes `builder` and `replace` are optional, and replace defaults to true.\r\n\r\n                     `template` should be the key of the template to load and it should be pre-loaded\r\n                     in `$templateCache`.\r\n\r\n                     `builder` can be a function or an array of functions. They will be called in\r\n                     the order they are supplied.\r\n\r\n                     `replace` (DEPRECATED) is for backwards compatability. If false the builder\r\n                     will use the \"old\" way of building that form field using a <sf-decorator>\r\n                     directive.\r\n   */\r\n  this.defineDecorator = function(name, fields) {\r\n    decorators[name] = { '__name': name }; // TODO: this feels like a hack, come up with a better way.\r\n\r\n    angular.forEach(fields, function(field, type) {\r\n      field.builder = field.builder || [];\r\n      field.replace = angular.isDefined(field.replace) ? field.replace : true;\r\n      decorators[name][type] = field;\r\n    });\r\n\r\n    if (!decorators[defaultDecorator]) {\r\n      defaultDecorator = name;\r\n    }\r\n    createDirective(name);\r\n  };\r\n\r\n  /**\r\n   * DEPRECATED\r\n   * Creates a directive of a decorator\r\n   * Usable when you want to use the decorators without using <schema-form> directive.\r\n   * Specifically when you need to reuse styling.\r\n   *\r\n   * ex. createDirective('text','...')\r\n   *  <sf-text title=\"foobar\" model=\"person\" key=\"name\" schema=\"schema\"></sf-text>\r\n   *\r\n   * @param {string}  type The type of the directive, resulting directive will have sf- prefixed\r\n   * @param {string}  templateUrl\r\n   * @param {boolean} transclude (optional) sets transclude option of directive, defaults to false.\r\n   */\r\n  this.createDirective = createManualDirective;\r\n\r\n  /**\r\n   * DEPRECATED\r\n   * Same as createDirective, but takes an object where key is 'type' and value is 'templateUrl'\r\n   * Useful for batching.\r\n   *\r\n   * @param {Object} templates\r\n   */\r\n  this.createDirectives = function(templates) {\r\n    angular.forEach(templates, function(url, type) {\r\n      createManualDirective(type, url);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Getter for decorator settings\r\n   *\r\n   * @param {string} name (optional) defaults to defaultDecorator\r\n   * @return {Object} rules and templates { rules: [],templates: {}}\r\n   */\r\n  this.decorator = function(name) {\r\n    name = name || defaultDecorator;\r\n    return decorators[name];\r\n  };\r\n\r\n  /**\r\n   * DEPRECATED use defineAddOn() instead.\r\n   * Adds a mapping to an existing decorator.\r\n   *\r\n   * @param {String} name Decorator name\r\n   * @param {String} type Form type for the mapping\r\n   * @param {String} url  The template url\r\n   * @param {Function} builder (optional) builder function\r\n   * @param {boolean} replace (optional) defaults to false. Replace decorator directive with template.\r\n   */\r\n  this.addMapping = function(name, type, url, builder, replace) {\r\n    if (decorators[name]) {\r\n      decorators[name][type] = {\r\n        template: url,\r\n        builder: builder,\r\n        replace: !!replace,\r\n      };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Adds an add-on to an existing decorator.\r\n   *\r\n   * @param {String} name Decorator name\r\n   * @param {String} type Form type for the mapping\r\n   * @param {String} url  The template url\r\n   * @param {Function|Array} builder (optional) builder function(s),\r\n   */\r\n  this.defineAddOn = function(name, type, url, builder) {\r\n    if (decorators[name]) {\r\n      decorators[name][type] = {\r\n        template: url,\r\n        builder: builder,\r\n        replace: true,\r\n      };\r\n    }\r\n  };\r\n\r\n  // Service is just a getter for directive templates and rules\r\n  this.$get = function() {\r\n    return {\r\n      decorator: function(name) {\r\n        return decorators[name] || decorators[defaultDecorator];\r\n      },\r\n      defaultDecorator: defaultDecorator,\r\n    };\r\n  };\r\n\r\n  // Create a default directive\r\n  createDirective('sfDecorator');\r\n};\r\n","import {\r\n  schemaDefaults,\r\n  jsonref,\r\n  merge,\r\n  traverseSchema,\r\n  traverseForm,\r\n} from 'json-schema-form-core';\r\n\r\n/**\r\n * Schema form service.\r\n */\r\nexport default function() {\r\n  let postProcessFn = (form) => form;\r\n  const defaults = schemaDefaults.createDefaults();\r\n\r\n  /**\r\n   * Provider API\r\n   */\r\n  this.defaults = defaults;\r\n  this.stdFormObj = schemaDefaults.stdFormObj;\r\n  this.defaultFormDefinition = schemaDefaults.defaultFormDefinition;\r\n\r\n  /**\r\n   * Register a post process function.\r\n   * This function is called with the fully merged\r\n   * form definition (i.e. after merging with schema)\r\n   * and whatever it returns is used as form.\r\n   */\r\n  this.postProcess = function(fn) {\r\n    postProcessFn = fn;\r\n  };\r\n\r\n  /**\r\n   * Append default form rule\r\n   *\r\n   * @param {string}   type json schema type\r\n   * @param {Function} rule a function(propertyName,propertySchema,options) that returns a form\r\n   *                        definition or undefined\r\n   */\r\n  this.appendRule = function(type, rule) {\r\n    if (!this.defaults[type]) {\r\n      this.defaults[type] = [];\r\n    }\r\n    this.defaults[type].push(rule);\r\n  };\r\n\r\n  /**\r\n   * Prepend default form rule\r\n   *\r\n   * @param {string}   type json schema type\r\n   * @param {Function} rule a function(propertyName,propertySchema,options) that returns a form\r\n   *                        definition or undefined\r\n   */\r\n  this.prependRule = function(type, rule) {\r\n    if (!this.defaults[type]) {\r\n      this.defaults[type] = [];\r\n    }\r\n    this.defaults[type].unshift(rule);\r\n  };\r\n\r\n  /**\r\n   * Utility function to create a standard form object.\r\n   * This does *not* set the type of the form but rather all shared attributes.\r\n   * You probably want to start your rule with creating the form with this method\r\n   * then setting type and any other values you need.\r\n   * @param {Object} schema\r\n   * @param {Object} options\r\n   * @return {Object} a form field defintion\r\n   */\r\n  this.createStandardForm = schemaDefaults.stdFormObj;\r\n  /* End Provider API */\r\n\r\n  this.$get = function() {\r\n    let service = {};\r\n    let typeDefault = this.defaults;\r\n\r\n    service.jsonref = jsonref;\r\n\r\n    /**\r\n    * Create form defaults from schema\r\n    */\r\n    service.defaults = function(schema, types, ignore, options) {\r\n      let defaultTypes = types || typeDefault;\r\n      return schemaDefaults.defaultForm(schema, defaultTypes, ignore, options);\r\n    };\r\n\r\n    /**\r\n     * merge\r\n     *\r\n     * @param  {Object}  schema                             [description]\r\n     * @param  {Array}   [form=['*']]                       [description]\r\n     * @param  {Object}  [typeDefaults=service.typeDefault] [description]\r\n     * @param  {boolean} ignore                             [description]\r\n     * @param  {Object}  [options={}]                       [description]\r\n     * @param  {Boolean} [readonly=false]                   [description]\r\n     * @param  {[type]}  asyncTemplates                     [description]\r\n     *\r\n     * @return {array}   I am the canonical schema with the combined schema and ui-schema\r\n     */\r\n    service.merge = function(schema, form = [ '*' ], typeDefaults=service.typeDefault, ignore, options = {}, readonly = false, asyncTemplates) {\r\n      // We look at the supplied form and extend it with schema standards\r\n      const canonical = merge(schema, form, typeDefaults, ignore, options, readonly, asyncTemplates);\r\n      return postProcessFn(canonical);\r\n    };\r\n\r\n    // Utility functions\r\n    /**\r\n     * Form defaults for schema by type\r\n     * As a form is generated from a schema these are the definitions of each json-schema type\r\n     */\r\n    service.typeDefault = typeDefault;\r\n\r\n    /**\r\n     * Traverse a schema, applying a function(schema,path) on every sub schema\r\n     * i.e. every property of an object.\r\n     */\r\n    service.traverseSchema = traverseSchema;\r\n\r\n    service.traverseForm = traverseForm;\r\n\r\n    return service;\r\n  };\r\n}\r\n","// FIXME: type template (using custom builder)\r\n/**\r\n * I build the canonical schema\r\n *\r\n * @param  {[type]} sfPathProvider [description]\r\n *\r\n * @return {[type]}                [description]\r\n */\r\nexport default function(sfPathProvider) {\r\n  let SNAKE_CASE_REGEXP = /[A-Z]/g;\r\n  let snakeCase = function(name, separator) {\r\n    separator = separator || '_';\r\n    return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\r\n      return (pos ? separator : '') + letter.toLowerCase();\r\n    });\r\n  };\r\n  let formId = 0;\r\n\r\n  if (!('firstElementChild' in document.createDocumentFragment())) {\r\n    Object.defineProperty(DocumentFragment.prototype, 'firstElementChild', {\r\n      get: function () {\r\n        for (let nodes = this.childNodes, n, i = 0, l = nodes.length; i < l; ++i)\r\n          if (n = nodes[i], 1 === n.nodeType) return n;\r\n        return null;\r\n      },\r\n    });\r\n  }\r\n\r\n  let builders = {\r\n    sfField: function(args) {\r\n      args.fieldFrag.firstElementChild.setAttribute('sf-field', formId);\r\n\r\n      // We use a lookup table for easy access to our form.\r\n      args.lookup['f' + formId] = args.form;\r\n      formId++;\r\n    },\r\n    ngModel: function(args) {\r\n      if (!args.form.key) {\r\n        return;\r\n      };\r\n\r\n      let key = args.form.key;\r\n\r\n      // Redact part of the key, used in arrays\r\n      // KISS keyRedaction is a number.\r\n      if (args.state.keyRedaction) {\r\n        key = key.slice(args.state.keyRedaction);\r\n      }\r\n\r\n      // Stringify key.\r\n      let modelValue;\r\n      if (!args.state.modelValue) {\r\n        let strKey = sfPathProvider.stringify(key).replace(/\"/g, '&quot;');\r\n        modelValue = (args.state.modelName || 'model');\r\n\r\n        if (strKey) { // Sometimes, like with arrays directly in arrays strKey is nothing.\r\n          modelValue += (strKey[0] !== '[' ? '.' : '') + strKey;\r\n        }\r\n      }\r\n      else {\r\n        // Another builder, i.e. array has overriden the modelValue\r\n        modelValue = args.state.modelValue;\r\n      }\r\n\r\n      // Find all sf-field-value attributes.\r\n      // No value means a add a ng-model.\r\n      // sf-field-value=\"replaceAll\", loop over attributes and replace $$value$$ in each.\r\n      // sf-field-value=\"attrName\", replace or set value of that attribute.\r\n      let nodes = args.fieldFrag.querySelectorAll('[sf-field-model]');\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        let n = nodes[i];\r\n        let conf = n.getAttribute('sf-field-model');\r\n        if (!conf || conf === '') {\r\n          n.setAttribute('ng-model', modelValue);\r\n        }\r\n        else if (conf === 'replaceAll') {\r\n          let attributes = n.attributes;\r\n          for (let j = 0; j < attributes.length; j++) {\r\n            if (attributes[j].value && attributes[j].value.indexOf('$$value') !== -1) {\r\n              attributes[j].value = attributes[j].value.replace(/\\$\\$value\\$\\$/g, modelValue);\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          let val = n.getAttribute(conf);\r\n          if (val && val.indexOf('$$value$$')) {\r\n            n.setAttribute(conf, val.replace(/\\$\\$value\\$\\$/g, modelValue));\r\n          }\r\n          else {\r\n            n.setAttribute(conf, modelValue);\r\n          }\r\n        }\r\n      }\r\n    },\r\n    simpleTransclusion: function(args) {\r\n      let children = args.build(args.form.items, args.path + '.items', args.state);\r\n      args.fieldFrag.firstChild.appendChild(children);\r\n    },\r\n\r\n    // Patch on ngModelOptions, since it doesn't like waiting for its value.\r\n    ngModelOptions: function(args) {\r\n      if (args.form.ngModelOptions && Object.keys(args.form.ngModelOptions).length > 0) {\r\n        args.fieldFrag\r\n          .firstChild\r\n          .setAttribute('ng-model-options', JSON.stringify(args.form.ngModelOptions));\r\n      }\r\n    },\r\n    transclusion: function(args) {\r\n      let transclusions = args.fieldFrag.querySelectorAll('[sf-field-transclude]');\r\n\r\n      if (transclusions.length) {\r\n        for (let i = 0; i < transclusions.length; i++) {\r\n          let n = transclusions[i];\r\n\r\n          // The sf-transclude attribute is not a directive,\r\n          // but has the name of what we're supposed to\r\n          // traverse. Default to `items`\r\n          let sub = n.getAttribute('sf-field-transclude') || 'items';\r\n          let items = args.form[sub];\r\n\r\n          if (items) {\r\n            let childFrag = args.build(items, args.path + '.' + sub, args.state);\r\n            n.appendChild(childFrag);\r\n          }\r\n        }\r\n      }\r\n    },\r\n    condition: function(args) {\r\n      let strKey = '';\r\n      let strModel = 'undefined';\r\n      let ngIf = '';\r\n      // Do we have a condition? Then we slap on an ng-if on all children,\r\n      // but be nice to existing ng-if.\r\n      if (args.form.condition) {\r\n        if (args.form.key) {\r\n          strKey = sfPathProvider.stringify(args.form.key);\r\n          strModel = 'model' + (strKey[0] === '[' ? '' : '.') + strKey;\r\n        }\r\n\r\n        let evalExpr = 'evalExpr(' + args.path + '.condition, { model: model, ' +\r\n                       '\"arrayIndex\": $index, ' +\r\n                       '\"arrayIndices\": arrayIndices, ' +\r\n                       '\"path\": path, ' +\r\n                       '\"$i\": $i, ' +\r\n                       '\"$index\": $index, ' +\r\n                       '\"modelValue\": ' + strModel + '})';\r\n\r\n        let children = args.fieldFrag.children || args.fieldFrag.childNodes;\r\n\r\n        for (let i = 0; i < children.length; i++) {\r\n          let child = children[i];\r\n\r\n          if(child.hasAttribute && child.hasAttribute('ng-if')) {\r\n            ngIf = child.getAttribute('ng-if');\r\n          };\r\n\r\n          if(child.setAttribute) {\r\n            child.setAttribute('ng-if',\r\n              ngIf\r\n              ? '(' + ngIf + ') || (' + evalExpr + ')'\r\n              : evalExpr\r\n            );\r\n          };\r\n        }\r\n      }\r\n    },\r\n    array: function(args) {\r\n      let items = args.fieldFrag.querySelector('[schema-form-array-items]');\r\n\r\n      if (items) {\r\n        let state = angular.copy(args.state);\r\n        state.keyRedaction = 0;\r\n        state.keyRedaction += args.form.key.length + 1;\r\n\r\n        // Special case, an array with just one item in it that is not an object.\r\n        // So then we just override the modelValue\r\n        if (args.form.schema && args.form.schema.items &&\r\n            args.form.schema.items.type &&\r\n            args.form.schema.items.type.indexOf('object') === -1 &&\r\n            args.form.schema.items.type.indexOf('array') === -1) {\r\n          state.modelValue = 'modelArray[$index]';\r\n        }\r\n        else {\r\n          state.modelName = 'item';\r\n        }\r\n\r\n        // Flag to the builder that we're in an array.\r\n        // This is needed for compatabiliy if a \"old\" add-on is used that\r\n        // hasn't been transitioned to the new builder.\r\n        state.arrayCompatFlag = true;\r\n\r\n        let childFrag = args.build(args.form.items, args.path + '.items', state);\r\n        items.appendChild(childFrag);\r\n      }\r\n    },\r\n    numeric: function(args) {\r\n      let inputFrag = args.fieldFrag.querySelector('input');\r\n      let maximum = args.form.maximum || false;\r\n      let exclusiveMaximum = args.form.exclusiveMaximum || false;\r\n      let minimum = args.form.minimum || false;\r\n      let exclusiveMinimum = args.form.exclusiveMinimum || false;\r\n      let multipleOf = args.form.multipleOf || false;\r\n      if (inputFrag) {\r\n        if (multipleOf !== false) {\r\n          inputFrag.setAttribute('step', multipleOf);\r\n        };\r\n\r\n        if (maximum !== false) {\r\n          if (exclusiveMaximum !== false && multipleOf !== false) {\r\n            maximum = maximum - multipleOf;\r\n          };\r\n          inputFrag.setAttribute('max', maximum);\r\n        };\r\n\r\n        if (minimum !== false) {\r\n          if (exclusiveMinimum !== false && multipleOf !== false) {\r\n            minimum = minimum + multipleOf;\r\n          };\r\n          inputFrag.setAttribute('min', minimum);\r\n        };\r\n      };\r\n    },\r\n  };\r\n  this.builders = builders;\r\n  let stdBuilders = [\r\n    builders.sfField,\r\n    builders.ngModel,\r\n    builders.ngModelOptions,\r\n    builders.condition,\r\n  ];\r\n  this.stdBuilders = stdBuilders;\r\n\r\n  this.$get = [ '$templateCache', 'schemaFormDecorators', 'sfPath',\r\n      function($templateCache, schemaFormDecorators, sfPath) {\r\n    let checkForSlot = function(form, slots) {\r\n      // Finally append this field to the frag.\r\n      // Check for slots\r\n      if (form.key) {\r\n        let slot = slots[sfPath.stringify(form.key)];\r\n        if (slot) {\r\n          while (slot.firstChild) {\r\n            slot.removeChild(slot.firstChild);\r\n          }\r\n          return slot;\r\n        }\r\n      }\r\n    };\r\n\r\n    let build = function(items, decorator, templateFn, slots, path, state, lookup) {\r\n      state = state || {};\r\n      state = state || {};\r\n      lookup = lookup || Object.create(null);\r\n      path = path || 'schemaForm.form';\r\n      let container = document.createDocumentFragment();\r\n      items.reduce(function(frag, f, index) {\r\n        // Sanity check.\r\n        if (!f.type) {\r\n          return frag;\r\n        }\r\n\r\n        let field = decorator[f.type] || decorator['default'];\r\n        if (!field.replace) {\r\n          // Backwards compatability build\r\n          let n = document.createElement(snakeCase(decorator.__name, '-'));\r\n          if (state.arrayCompatFlag) {\r\n            n.setAttribute('form', 'copyWithIndex($index)');\r\n          }\r\n          else {\r\n            n.setAttribute('form', path + '[' + index + ']');\r\n          }\r\n\r\n          (checkForSlot(f, slots) || frag).appendChild(n);\r\n        }\r\n        else {\r\n          let tmpl;\r\n\r\n          // Reset arrayCompatFlag, it's only valid for direct children of the array.\r\n          state.arrayCompatFlag = false;\r\n\r\n          // TODO: Create a couple of testcases, small and large and\r\n          //       measure optmization. A good start is probably a\r\n          //       cache of DOM nodes for a particular template\r\n          //       that can be cloned instead of using innerHTML\r\n          let div = document.createElement('div');\r\n          let template = templateFn(f, field) || templateFn(f, decorator['default']);\r\n          div.innerHTML = template;\r\n\r\n          // Move node to a document fragment, we don't want the div.\r\n          tmpl = document.createDocumentFragment();\r\n          while (div.childNodes.length > 0) {\r\n            tmpl.appendChild(div.childNodes[0]);\r\n          }\r\n\r\n          // Possible builder, often a noop\r\n          let args = {\r\n            fieldFrag: tmpl,\r\n            form: f,\r\n            lookup: lookup,\r\n            state: state,\r\n            path: path + '[' + index + ']',\r\n\r\n            // Recursive build fn\r\n            build: function(items, path, state) {\r\n              return build(items, decorator, templateFn, slots, path, state, lookup);\r\n            },\r\n\r\n          };\r\n\r\n          // Let the form definiton override builders if it wants to.\r\n          let builderFn = f.builder || field.builder;\r\n\r\n          // Builders are either a function or a list of functions.\r\n          if (typeof builderFn === 'function') {\r\n            builderFn(args);\r\n          }\r\n          else {\r\n            builderFn.forEach(function(fn) { fn(args); });\r\n          }\r\n\r\n          // Append\r\n          (checkForSlot(f, slots) || frag).appendChild(tmpl);\r\n        }\r\n        return frag;\r\n      },\r\n      container);\r\n\r\n      return container;\r\n    };\r\n\r\n    return {\r\n      /**\r\n       * Builds a form from a canonical form definition\r\n       */\r\n      build: function(form, decorator, slots, lookup) {\r\n        return build(form, decorator, function(form, field) {\r\n          if (form.type === 'template') {\r\n            return form.template;\r\n          }\r\n          return $templateCache.get(field.template);\r\n        }, slots, undefined, undefined, lookup);\r\n      },\r\n      builder: builders,\r\n      stdBuilders: stdBuilders,\r\n      internalBuild: build,\r\n    };\r\n  } ];\r\n}\r\n","/* eslint-disable quote-props, no-invalid-this */\r\nimport angular from 'angular';\r\n\r\n/**\r\n * I am the error message provider\r\n *\r\n * @return {object} I return a service provider for error messages\r\n */\r\nexport default function() {\r\n  let self = this;\r\n  // The codes are tv4 error codes.\r\n  // Not all of these can actually happen in a field, but for\r\n  // we never know when one might pop up so it's best to cover them all.\r\n\r\n  // TODO: Humanize these.\r\n  let defaultMessages = {\r\n    'default': 'Field does not validate',\r\n    0: 'Invalid type, expected {{schema.type}}',\r\n    1: 'No enum match for: {{viewValue}}',\r\n    10: 'Data does not match any schemas from \"anyOf\"',\r\n    11: 'Data does not match any schemas from \"oneOf\"',\r\n    12: 'Data is valid against more than one schema from \"oneOf\"',\r\n    13: 'Data matches schema from \"not\"',\r\n    // Numeric errors\r\n    100: 'Value is not a multiple of {{schema.multipleOf}}',\r\n    101: '{{viewValue}} is less than the allowed minimum of {{schema.minimum}}',\r\n    102: '{{viewValue}} is equal to the exclusive minimum {{schema.minimum}}',\r\n    103: '{{viewValue}} is greater than the allowed maximum of {{schema.maximum}}',\r\n    104: '{{viewValue}} is equal to the exclusive maximum {{schema.maximum}}',\r\n    105: 'Value is not a valid number',\r\n    // String errors\r\n    200: 'String is too short ({{viewValue.length}} chars), minimum {{schema.minLength}}',\r\n    201: 'String is too long ({{viewValue.length}} chars), maximum {{schema.maxLength}}',\r\n    202: 'String does not match pattern: {{schema.pattern}}',\r\n    // Object errors\r\n    300: 'Too few properties defined, minimum {{schema.minProperties}}',\r\n    301: 'Too many properties defined, maximum {{schema.maxProperties}}',\r\n    302: 'Required',\r\n    303: 'Additional properties not allowed',\r\n    304: 'Dependency failed - key must exist',\r\n    // Array errors\r\n    400: 'Array is too short ({{value.length}}), minimum {{schema.minItems}}',\r\n    401: 'Array is too long ({{value.length}}), maximum {{schema.maxItems}}',\r\n    402: 'Array items are not unique',\r\n    403: 'Additional items not allowed',\r\n    // Format errors\r\n    500: 'Format validation failed',\r\n    501: 'Keyword failed: \"{{title}}\"',\r\n    // Schema structure\r\n    600: 'Circular $refs',\r\n    // Non-standard validation options\r\n    1000: 'Unknown property (not in schema)',\r\n  };\r\n\r\n  // In some cases we get hit with an angular validation error\r\n  defaultMessages.number = defaultMessages[105];\r\n  defaultMessages.required = defaultMessages[302];\r\n  defaultMessages.min = defaultMessages[101];\r\n  defaultMessages.max = defaultMessages[103];\r\n  defaultMessages.maxlength = defaultMessages[201];\r\n  defaultMessages.minlength = defaultMessages[200];\r\n  defaultMessages.pattern = defaultMessages[202];\r\n\r\n  self.setDefaultMessages = function(messages) {\r\n    defaultMessages = messages;\r\n  };\r\n\r\n  self.getDefaultMessages = function() {\r\n    return defaultMessages;\r\n  };\r\n\r\n  self.setDefaultMessage = function(error, msg) {\r\n    defaultMessages[error] = msg;\r\n  };\r\n\r\n  self.$get = [ '$interpolate', function($interpolate) {\r\n    let service = {};\r\n    service.defaultMessages = defaultMessages;\r\n\r\n    /**\r\n     * Interpolate and return proper error for an eror code.\r\n     * Validation message on form trumps global error messages.\r\n     * and if the message is a function instead of a string that function will be called instead.\r\n     *\r\n     * @param {string} error the error code, i.e. tv4-xxx for tv4 errors, otherwise it's whats on\r\n     *                       ngModel.$error for custom errors.\r\n     * @param {Any} value the actual model value.\r\n     * @param {Any} viewValue the viewValue\r\n     * @param {Object} form a form definition object for this field\r\n     * @param  {Object} global the global validation messages object (even though its called global\r\n     *                         its actually just shared in one instance of sf-schema)\r\n     * @return {string} The error message.\r\n     */\r\n    service.interpolate = function(error, value, viewValue, form, global) {\r\n      global = global || {};\r\n      let validationMessage = form.validationMessage || {};\r\n\r\n      // Drop tv4 prefix so only the code is left.\r\n      if (error.indexOf('tv4-') === 0) {\r\n        error = error.substring(4);\r\n      }\r\n\r\n      // First find apropriate message or function\r\n      let message = validationMessage['default'] || global['default'] || '';\r\n\r\n      [ validationMessage, global, defaultMessages ].some(function(val) {\r\n        if (angular.isString(val) || angular.isFunction(val)) {\r\n          message = val;\r\n          return true;\r\n        }\r\n        if (val && val[error]) {\r\n          message = val[error];\r\n          return true;\r\n        }\r\n      });\r\n\r\n      let context = {\r\n        error: error,\r\n        value: value,\r\n        viewValue: viewValue,\r\n        form: form,\r\n        schema: form.schema,\r\n        title: form.title || (form.schema && form.schema.title),\r\n      };\r\n      if (angular.isFunction(message)) {\r\n        return message(context);\r\n      }\r\n      else {\r\n        return $interpolate(message)(context);\r\n      }\r\n    };\r\n\r\n    return service;\r\n  } ];\r\n}\r\n","import { sfPath } from 'json-schema-form-core';\r\n\r\n/**\r\n * @class SFPathProviderClass\r\n */\r\nclass SFPathProviderClass {\r\n  /**\r\n   * @method constructor\r\n   */\r\n  constructor() {\r\n    this.name = sfPath.name;\r\n    this.parse = sfPath.parse;\r\n    this.stringify = sfPath.stringify;\r\n    this.normalize = sfPath.normalize;\r\n  }\r\n\r\n  /**\r\n   * @method $get\r\n   */\r\n  $get() {\r\n    return sfPath;\r\n  }\r\n}\r\n\r\nexport default () => {\r\n  return new SFPathProviderClass();\r\n};\r\n","if(typeof undefined === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = undefined;","module.exports = angular;","if(typeof undefined === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = undefined;","if(typeof undefined === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = undefined;"],"sourceRoot":""}